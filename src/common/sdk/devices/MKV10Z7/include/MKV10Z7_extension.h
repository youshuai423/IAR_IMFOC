/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          GNU C Compiler - CodeSourcery Sourcery G++
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    KV10P48M75RM Rev.6, June 2014
**     Version:             rev. 1.2, 2014-08-28
**     Build:               b150215
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2014 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2013-05-09)
**         Initial version.
**     - rev. 1.1 (2014-02-20)
**         ADC module - removed PGA registers
**         UART0 module - removed CEA709.1 registers
**     - rev. 1.2 (2014-08-28)
**         Update of system files - default clock configuration changed.
**         Update of startup files - possibility to override DefaultISR added.
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __MKV10Z7_EXTENSION_H__
#define __MKV10Z7_EXTENSION_H__

#include "MKV10Z7.h"
#include "fsl_bitaccess.h"

/*
 * MKV10Z7 ADC
 *
 * Analog-to-Digital Converter
 *
 * Registers defined in this header file:
 * - ADC_SC1 - ADC Status and Control Registers 1
 * - ADC_CFG1 - ADC Configuration Register 1
 * - ADC_CFG2 - ADC Configuration Register 2
 * - ADC_R - ADC Data Result Register
 * - ADC_CV1 - Compare Value Registers
 * - ADC_CV2 - Compare Value Registers
 * - ADC_SC2 - Status and Control Register 2
 * - ADC_SC3 - Status and Control Register 3
 * - ADC_OFS - ADC Offset Correction Register
 * - ADC_PG - ADC Plus-Side Gain Register
 * - ADC_MG - ADC Minus-Side Gain Register
 * - ADC_CLPD - ADC Plus-Side General Calibration Value Register
 * - ADC_CLPS - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLMD - ADC Minus-Side General Calibration Value Register
 * - ADC_CLMS - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 */

#define ADC_INSTANCE_COUNT (2U) /*!< Number of instances of the ADC module. */
#define ADC0_IDX (0U) /*!< Instance number for ADC0. */
#define ADC1_IDX (1U) /*!< Instance number for ADC1. */

/*******************************************************************************
 * ADC_SC1 - ADC Status and Control Registers 1
 ******************************************************************************/

/*!
 * @brief ADC_SC1 - ADC Status and Control Registers 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * SC1A is used for both software and hardware trigger modes of operation. To
 * allow sequential conversions of the ADC to be triggered by internal peripherals,
 * the ADC can have more than one status and control register: one for each
 * conversion. The SC1B-SC1n registers indicate potentially multiple SC1 registers
 * for use only in hardware trigger mode. See the chip configuration information
 * about the number of SC1n registers specific to this device. The SC1n registers
 * have identical fields, and are used in a "ping-pong" approach to control ADC
 * operation. At any one point in time, only one of the SC1n registers is actively
 * controlling ADC conversions. Updating SC1A while SC1n is actively controlling
 * a conversion is allowed, and vice-versa for any of the SC1n registers specific
 * to this MCU. Writing SC1A while SC1A is actively controlling a conversion
 * aborts the current conversion. In Software Trigger mode, when SC2[ADTRG]=0,
 * writes to SC1A subsequently initiate a new conversion, if SC1[ADCH] contains a
 * value other than all 1s. Writing any of the SC1n registers while that specific
 * SC1n register is actively controlling a conversion aborts the current conversion.
 * None of the SC1B-SC1n registers are used for software trigger operation and
 * therefore writes to the SC1B-SC1n registers do not initiate a new conversion.
 */
/*!
 * @name Constants and macros for entire ADC_SC1 register
 */
/*@{*/
#define ADC_RD_SC1(base, index)  (ADC_SC1_REG(base, index))
#define ADC_WR_SC1(base, index, value) (ADC_SC1_REG(base, index) = (value))
#define ADC_RMW_SC1(base, index, mask, value) (ADC_WR_SC1(base, index, (ADC_RD_SC1(base, index) & ~(mask)) | (value)))
#define ADC_SET_SC1(base, index, value) (BME_OR32(&ADC_SC1_REG(base, index), (uint32_t)(value)))
#define ADC_CLR_SC1(base, index, value) (BME_AND32(&ADC_SC1_REG(base, index), (uint32_t)(~(value))))
#define ADC_TOG_SC1(base, index, value) (BME_XOR32(&ADC_SC1_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC1 bitfields
 */

/*!
 * @name Register ADC_SC1, field ADCH[4:0] (RW)
 *
 * Selects one of the input channels. The input channel decode depends on the
 * value of DIFF. DAD0-DAD3 are associated with the input pin pairs DADPx and
 * DADMx. Some of the input channel options in the bitfield-setting descriptions might
 * not be available for your device. For the actual ADC channel assignments for
 * your device, see the Chip Configuration details. The successive approximation
 * converter subsystem is turned off when the channel select bits are all set,
 * that is, ADCH = 11111. This feature allows explicit disabling of the ADC and
 * isolation of the input channel from all sources. Terminating continuous
 * conversions this way prevents an additional single conversion from being performed. It
 * is not necessary to set ADCH to all 1s to place the ADC in a low-power state
 * when continuous conversions are not enabled because the module automatically
 * enters a low-power state when a conversion completes.
 *
 * Values:
 * - 00000 - When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is
 *     selected as input.
 * - 00001 - When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is
 *     selected as input.
 * - 00010 - When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is
 *     selected as input.
 * - 00011 - When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is
 *     selected as input.
 * - 00100 - When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
 * - 00101 - When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
 * - 00110 - When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
 * - 00111 - When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
 * - 01000 - When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
 * - 01001 - When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
 * - 01010 - When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
 * - 01011 - When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
 * - 01100 - When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
 * - 01101 - When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
 * - 01110 - When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
 * - 01111 - When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
 * - 10000 - When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
 * - 10001 - When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
 * - 10010 - When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
 * - 10011 - When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
 * - 10100 - When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
 * - 10101 - When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
 * - 10110 - When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
 * - 10111 - When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
 * - 11000 - Reserved.
 * - 11001 - Reserved.
 * - 11010 - When DIFF=0, Temp Sensor (single-ended) is selected as input; when
 *     DIFF=1, Temp Sensor (differential) is selected as input.
 * - 11011 - When DIFF=0, Bandgap (single-ended) is selected as input; when
 *     DIFF=1, Bandgap (differential) is selected as input.
 * - 11100 - Reserved.
 * - 11101 - When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH
 *     (differential) is selected as input. Voltage reference selected is determined
 *     by SC2[REFSEL].
 * - 11110 - When DIFF=0,VREFSL is selected as input; when DIFF=1, it is
 *     reserved. Voltage reference selected is determined by SC2[REFSEL].
 * - 11111 - Module is disabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_ADCH field. */
#define ADC_RD_SC1_ADCH(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_ADCH_MASK) >> ADC_SC1_ADCH_SHIFT)
#define ADC_BRD_SC1_ADCH(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_ADCH_SHIFT, ADC_SC1_ADCH_WIDTH))

/*! @brief Set the ADCH field to a new value. */
#define ADC_WR_SC1_ADCH(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_ADCH_MASK, ADC_SC1_ADCH(value)))
#define ADC_BWR_SC1_ADCH(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_ADCH_SHIFT), ADC_SC1_ADCH_SHIFT, ADC_SC1_ADCH_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field DIFF[5] (RW)
 *
 * Configures the ADC to operate in differential mode. When enabled, this mode
 * automatically selects from the differential channels, and changes the
 * conversion algorithm and the number of cycles to complete a conversion.
 *
 * Values:
 * - 0 - Single-ended conversions and input channels are selected.
 * - 1 - Differential conversions and input channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_DIFF field. */
#define ADC_RD_SC1_DIFF(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_DIFF_MASK) >> ADC_SC1_DIFF_SHIFT)
#define ADC_BRD_SC1_DIFF(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_DIFF_SHIFT, ADC_SC1_DIFF_WIDTH))

/*! @brief Set the DIFF field to a new value. */
#define ADC_WR_SC1_DIFF(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_DIFF_MASK, ADC_SC1_DIFF(value)))
#define ADC_BWR_SC1_DIFF(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_DIFF_SHIFT), ADC_SC1_DIFF_SHIFT, ADC_SC1_DIFF_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field AIEN[6] (RW)
 *
 * Enables conversion complete interrupts. When COCO becomes set while the
 * respective AIEN is high, an interrupt is asserted.
 *
 * Values:
 * - 0 - Conversion complete interrupt is disabled.
 * - 1 - Conversion complete interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_AIEN field. */
#define ADC_RD_SC1_AIEN(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_AIEN_MASK) >> ADC_SC1_AIEN_SHIFT)
#define ADC_BRD_SC1_AIEN(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_AIEN_SHIFT, ADC_SC1_AIEN_WIDTH))

/*! @brief Set the AIEN field to a new value. */
#define ADC_WR_SC1_AIEN(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_AIEN_MASK, ADC_SC1_AIEN(value)))
#define ADC_BWR_SC1_AIEN(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_AIEN_SHIFT), ADC_SC1_AIEN_SHIFT, ADC_SC1_AIEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field COCO[7] (RO)
 *
 * This is a read-only field that is set each time a conversion is completed
 * when the compare function is disabled, or SC2[ACFE]=0 and the hardware average
 * function is disabled, or SC3[AVGE]=0. When the compare function is enabled, or
 * SC2[ACFE]=1, COCO is set upon completion of a conversion only if the compare
 * result is true. When the hardware average function is enabled, or SC3[AVGE]=1,
 * COCO is set upon completion of the selected number of conversions (determined
 * by AVGS). COCO in SC1A is also set at the completion of a calibration sequence.
 * COCO is cleared when the respective SC1n register is written or when the
 * respective Rn register is read.
 *
 * Values:
 * - 0 - Conversion is not completed.
 * - 1 - Conversion is completed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_COCO field. */
#define ADC_RD_SC1_COCO(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_COCO_MASK) >> ADC_SC1_COCO_SHIFT)
#define ADC_BRD_SC1_COCO(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_COCO_SHIFT, ADC_SC1_COCO_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CFG1 - ADC Configuration Register 1
 ******************************************************************************/

/*!
 * @brief ADC_CFG1 - ADC Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The configuration Register 1 (CFG1) selects the mode of operation, clock
 * source, clock divide, and configuration for low power or long sample time.
 */
/*!
 * @name Constants and macros for entire ADC_CFG1 register
 */
/*@{*/
#define ADC_RD_CFG1(base)        (ADC_CFG1_REG(base))
#define ADC_WR_CFG1(base, value) (ADC_CFG1_REG(base) = (value))
#define ADC_RMW_CFG1(base, mask, value) (ADC_WR_CFG1(base, (ADC_RD_CFG1(base) & ~(mask)) | (value)))
#define ADC_SET_CFG1(base, value) (BME_OR32(&ADC_CFG1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CFG1(base, value) (BME_AND32(&ADC_CFG1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CFG1(base, value) (BME_XOR32(&ADC_CFG1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG1 bitfields
 */

/*!
 * @name Register ADC_CFG1, field ADICLK[1:0] (RW)
 *
 * Selects the input clock source to generate the internal clock, ADCK. Note
 * that when the ADACK clock source is selected, it is not required to be active
 * prior to conversion start. When it is selected and it is not active prior to a
 * conversion start, when CFG2[ADACKEN]=0, the asynchronous clock is activated at
 * the start of a conversion and deactivated when conversions are terminated. In
 * this case, there is an associated clock startup delay each time the clock
 * source is re-activated.
 *
 * Values:
 * - 00 - Bus clock
 * - 01 - Bus clock divided by 2(BUSCLK/DIV2)
 * - 10 - Alternate clock (ALTCLK)
 * - 11 - Asynchronous clock (ADACK)
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADICLK field. */
#define ADC_RD_CFG1_ADICLK(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADICLK_MASK) >> ADC_CFG1_ADICLK_SHIFT)
#define ADC_BRD_CFG1_ADICLK(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADICLK_SHIFT, ADC_CFG1_ADICLK_WIDTH))

/*! @brief Set the ADICLK field to a new value. */
#define ADC_WR_CFG1_ADICLK(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADICLK_MASK, ADC_CFG1_ADICLK(value)))
#define ADC_BWR_CFG1_ADICLK(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADICLK_SHIFT), ADC_CFG1_ADICLK_SHIFT, ADC_CFG1_ADICLK_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field MODE[3:2] (RW)
 *
 * Selects the ADC resolution mode.
 *
 * Values:
 * - 00 - When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is
 *     differential 9-bit conversion with 2's complement output.
 * - 01 - When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it is
 *     differential 13-bit conversion with 2's complement output.
 * - 10 - When DIFF=0:It is single-ended 10-bit conversion. ; when DIFF=1, it is
 *     differential 11-bit conversion with 2's complement output
 * - 11 - When DIFF=0:It is single-ended 16-bit conversion..; when DIFF=1, it is
 *     differential 16-bit conversion with 2's complement output
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_MODE field. */
#define ADC_RD_CFG1_MODE(base) ((ADC_CFG1_REG(base) & ADC_CFG1_MODE_MASK) >> ADC_CFG1_MODE_SHIFT)
#define ADC_BRD_CFG1_MODE(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_MODE_SHIFT, ADC_CFG1_MODE_WIDTH))

/*! @brief Set the MODE field to a new value. */
#define ADC_WR_CFG1_MODE(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_MODE_MASK, ADC_CFG1_MODE(value)))
#define ADC_BWR_CFG1_MODE(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_MODE_SHIFT), ADC_CFG1_MODE_SHIFT, ADC_CFG1_MODE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLSMP[4] (RW)
 *
 * Selects between different sample times based on the conversion mode selected.
 * This field adjusts the sample period to allow higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption if
 * continuous conversions are enabled and high conversion rates are not required.
 * When ADLSMP=1, the long sample time select bits, (ADLSTS[1:0]), can select the
 * extent of the long sample time.
 *
 * Values:
 * - 0 - Short sample time.
 * - 1 - Long sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLSMP field. */
#define ADC_RD_CFG1_ADLSMP(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLSMP_MASK) >> ADC_CFG1_ADLSMP_SHIFT)
#define ADC_BRD_CFG1_ADLSMP(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADLSMP_SHIFT, ADC_CFG1_ADLSMP_WIDTH))

/*! @brief Set the ADLSMP field to a new value. */
#define ADC_WR_CFG1_ADLSMP(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLSMP_MASK, ADC_CFG1_ADLSMP(value)))
#define ADC_BWR_CFG1_ADLSMP(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADLSMP_SHIFT), ADC_CFG1_ADLSMP_SHIFT, ADC_CFG1_ADLSMP_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADIV[6:5] (RW)
 *
 * Selects the divide ratio used by the ADC to generate the internal clock ADCK.
 *
 * Values:
 * - 00 - The divide ratio is 1 and the clock rate is input clock.
 * - 01 - The divide ratio is 2 and the clock rate is (input clock)/2.
 * - 10 - The divide ratio is 4 and the clock rate is (input clock)/4.
 * - 11 - The divide ratio is 8 and the clock rate is (input clock)/8.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADIV field. */
#define ADC_RD_CFG1_ADIV(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADIV_MASK) >> ADC_CFG1_ADIV_SHIFT)
#define ADC_BRD_CFG1_ADIV(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADIV_SHIFT, ADC_CFG1_ADIV_WIDTH))

/*! @brief Set the ADIV field to a new value. */
#define ADC_WR_CFG1_ADIV(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADIV_MASK, ADC_CFG1_ADIV(value)))
#define ADC_BWR_CFG1_ADIV(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADIV_SHIFT), ADC_CFG1_ADIV_SHIFT, ADC_CFG1_ADIV_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLPC[7] (RW)
 *
 * Controls the power configuration of the successive approximation converter.
 * This optimizes power consumption when higher sample rates are not required.
 *
 * Values:
 * - 0 - Normal power configuration.
 * - 1 - Low-power configuration. The power is reduced at the expense of maximum
 *     clock speed.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLPC field. */
#define ADC_RD_CFG1_ADLPC(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLPC_MASK) >> ADC_CFG1_ADLPC_SHIFT)
#define ADC_BRD_CFG1_ADLPC(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADLPC_SHIFT, ADC_CFG1_ADLPC_WIDTH))

/*! @brief Set the ADLPC field to a new value. */
#define ADC_WR_CFG1_ADLPC(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLPC_MASK, ADC_CFG1_ADLPC(value)))
#define ADC_BWR_CFG1_ADLPC(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADLPC_SHIFT), ADC_CFG1_ADLPC_SHIFT, ADC_CFG1_ADLPC_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CFG2 - ADC Configuration Register 2
 ******************************************************************************/

/*!
 * @brief ADC_CFG2 - ADC Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Configuration Register 2 (CFG2) selects the special high-speed configuration
 * for very high speed conversions and selects the long sample time duration
 * during long sample mode.
 */
/*!
 * @name Constants and macros for entire ADC_CFG2 register
 */
/*@{*/
#define ADC_RD_CFG2(base)        (ADC_CFG2_REG(base))
#define ADC_WR_CFG2(base, value) (ADC_CFG2_REG(base) = (value))
#define ADC_RMW_CFG2(base, mask, value) (ADC_WR_CFG2(base, (ADC_RD_CFG2(base) & ~(mask)) | (value)))
#define ADC_SET_CFG2(base, value) (BME_OR32(&ADC_CFG2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CFG2(base, value) (BME_AND32(&ADC_CFG2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CFG2(base, value) (BME_XOR32(&ADC_CFG2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG2 bitfields
 */

/*!
 * @name Register ADC_CFG2, field ADLSTS[1:0] (RW)
 *
 * Selects between the extended sample times when long sample time is selected,
 * that is, when CFG1[ADLSMP]=1. This allows higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption when
 * continuous conversions are enabled if high conversion rates are not required.
 *
 * Values:
 * - 00 - Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles
 *     total.
 * - 01 - 12 extra ADCK cycles; 16 ADCK cycles total sample time.
 * - 10 - 6 extra ADCK cycles; 10 ADCK cycles total sample time.
 * - 11 - 2 extra ADCK cycles; 6 ADCK cycles total sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADLSTS field. */
#define ADC_RD_CFG2_ADLSTS(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADLSTS_MASK) >> ADC_CFG2_ADLSTS_SHIFT)
#define ADC_BRD_CFG2_ADLSTS(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADLSTS_SHIFT, ADC_CFG2_ADLSTS_WIDTH))

/*! @brief Set the ADLSTS field to a new value. */
#define ADC_WR_CFG2_ADLSTS(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADLSTS_MASK, ADC_CFG2_ADLSTS(value)))
#define ADC_BWR_CFG2_ADLSTS(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADLSTS_SHIFT), ADC_CFG2_ADLSTS_SHIFT, ADC_CFG2_ADLSTS_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADHSC[2] (RW)
 *
 * Configures the ADC for very high-speed operation. The conversion sequence is
 * altered with 2 ADCK cycles added to the conversion time to allow higher speed
 * conversion clocks.
 *
 * Values:
 * - 0 - Normal conversion sequence selected.
 * - 1 - High-speed conversion sequence selected with 2 additional ADCK cycles
 *     to total conversion time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADHSC field. */
#define ADC_RD_CFG2_ADHSC(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADHSC_MASK) >> ADC_CFG2_ADHSC_SHIFT)
#define ADC_BRD_CFG2_ADHSC(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADHSC_SHIFT, ADC_CFG2_ADHSC_WIDTH))

/*! @brief Set the ADHSC field to a new value. */
#define ADC_WR_CFG2_ADHSC(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADHSC_MASK, ADC_CFG2_ADHSC(value)))
#define ADC_BWR_CFG2_ADHSC(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADHSC_SHIFT), ADC_CFG2_ADHSC_SHIFT, ADC_CFG2_ADHSC_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADACKEN[3] (RW)
 *
 * Enables the asynchronous clock source and the clock source output regardless
 * of the conversion and status of CFG1[ADICLK]. Based on MCU configuration, the
 * asynchronous clock may be used by other modules. See chip configuration
 * information. Setting this field allows the clock to be used even while the ADC is
 * idle or operating from a different clock source. Also, latency of initiating a
 * single or first-continuous conversion with the asynchronous clock selected is
 * reduced because the ADACK clock is already operational.
 *
 * Values:
 * - 0 - Asynchronous clock output disabled; Asynchronous clock is enabled only
 *     if selected by ADICLK and a conversion is active.
 * - 1 - Asynchronous clock and clock output is enabled regardless of the state
 *     of the ADC.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADACKEN field. */
#define ADC_RD_CFG2_ADACKEN(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADACKEN_MASK) >> ADC_CFG2_ADACKEN_SHIFT)
#define ADC_BRD_CFG2_ADACKEN(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADACKEN_SHIFT, ADC_CFG2_ADACKEN_WIDTH))

/*! @brief Set the ADACKEN field to a new value. */
#define ADC_WR_CFG2_ADACKEN(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADACKEN_MASK, ADC_CFG2_ADACKEN(value)))
#define ADC_BWR_CFG2_ADACKEN(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADACKEN_SHIFT), ADC_CFG2_ADACKEN_SHIFT, ADC_CFG2_ADACKEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field MUXSEL[4] (RW)
 *
 * Changes the ADC mux setting to select between alternate sets of ADC channels.
 *
 * Values:
 * - 0 - ADxxa channels are selected.
 * - 1 - ADxxb channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_MUXSEL field. */
#define ADC_RD_CFG2_MUXSEL(base) ((ADC_CFG2_REG(base) & ADC_CFG2_MUXSEL_MASK) >> ADC_CFG2_MUXSEL_SHIFT)
#define ADC_BRD_CFG2_MUXSEL(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_MUXSEL_SHIFT, ADC_CFG2_MUXSEL_WIDTH))

/*! @brief Set the MUXSEL field to a new value. */
#define ADC_WR_CFG2_MUXSEL(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_MUXSEL_MASK, ADC_CFG2_MUXSEL(value)))
#define ADC_BWR_CFG2_MUXSEL(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_MUXSEL_SHIFT), ADC_CFG2_MUXSEL_SHIFT, ADC_CFG2_MUXSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_R - ADC Data Result Register
 ******************************************************************************/

/*!
 * @brief ADC_R - ADC Data Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The data result registers (Rn) contain the result of an ADC conversion of the
 * channel selected by the corresponding status and channel control register
 * (SC1A:SC1n). For every status and channel control register, there is a
 * corresponding data result register. Unused bits in R n are cleared in unsigned
 * right-aligned modes and carry the sign bit (MSB) in sign-extended 2's complement modes.
 * For example, when configured for 10-bit single-ended mode, D[15:10] are
 * cleared. When configured for 11-bit differential mode, D[15:10] carry the sign bit,
 * that is, bit 10 extended through bit 15. The following table describes the
 * behavior of the data result registers in the different modes of operation. Data
 * result register description Conversion mode D15 D14 D13 D12 D11 D10 D9 D8 D7
 * D6 D5 D4 D3 D2 D1 D0 Format 16-bit differential S D D D D D D D D D D D D D D D
 * Signed 2's complement 16-bit single-ended D D D D D D D D D D D D D D D D
 * Unsigned right justified 13-bit differential S S S S D D D D D D D D D D D D
 * Sign-extended 2's complement 12-bit single-ended 0 0 0 0 D D D D D D D D D D D D
 * Unsigned right-justified 11-bit differential S S S S S S D D D D D D D D D D
 * Sign-extended 2's complement 10-bit single-ended 0 0 0 0 0 0 D D D D D D D D D D
 * Unsigned right-justified 9-bit differential S S S S S S S S D D D D D D D D
 * Sign-extended 2's complement 8-bit single-ended 0 0 0 0 0 0 0 0 D D D D D D D D
 * Unsigned right-justified S: Sign bit or sign bit extension; D: Data, which is
 * 2's complement data if indicated
 */
/*!
 * @name Constants and macros for entire ADC_R register
 */
/*@{*/
#define ADC_RD_R(base, index)    (ADC_R_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual ADC_R bitfields
 */

/*!
 * @name Register ADC_R, field D[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ADC_R_D field. */
#define ADC_RD_R_D(base, index) ((ADC_R_REG(base, index) & ADC_R_D_MASK) >> ADC_R_D_SHIFT)
#define ADC_BRD_R_D(base, index) (BME_UBFX32(&ADC_R_REG(base, index), ADC_R_D_SHIFT, ADC_R_D_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CV1 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV1 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV1 register
 */
/*@{*/
#define ADC_RD_CV1(base)         (ADC_CV1_REG(base))
#define ADC_WR_CV1(base, value)  (ADC_CV1_REG(base) = (value))
#define ADC_RMW_CV1(base, mask, value) (ADC_WR_CV1(base, (ADC_RD_CV1(base) & ~(mask)) | (value)))
#define ADC_SET_CV1(base, value) (BME_OR32(&ADC_CV1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CV1(base, value) (BME_AND32(&ADC_CV1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CV1(base, value) (BME_XOR32(&ADC_CV1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV1 bitfields
 */

/*!
 * @name Register ADC_CV1, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV1_CV field. */
#define ADC_RD_CV1_CV(base)  ((ADC_CV1_REG(base) & ADC_CV1_CV_MASK) >> ADC_CV1_CV_SHIFT)
#define ADC_BRD_CV1_CV(base) (BME_UBFX32(&ADC_CV1_REG(base), ADC_CV1_CV_SHIFT, ADC_CV1_CV_WIDTH))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV1_CV(base, value) (ADC_RMW_CV1(base, ADC_CV1_CV_MASK, ADC_CV1_CV(value)))
#define ADC_BWR_CV1_CV(base, value) (BME_BFI32(&ADC_CV1_REG(base), ((uint32_t)(value) << ADC_CV1_CV_SHIFT), ADC_CV1_CV_SHIFT, ADC_CV1_CV_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CV2 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV2 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV2 register
 */
/*@{*/
#define ADC_RD_CV2(base)         (ADC_CV2_REG(base))
#define ADC_WR_CV2(base, value)  (ADC_CV2_REG(base) = (value))
#define ADC_RMW_CV2(base, mask, value) (ADC_WR_CV2(base, (ADC_RD_CV2(base) & ~(mask)) | (value)))
#define ADC_SET_CV2(base, value) (BME_OR32(&ADC_CV2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CV2(base, value) (BME_AND32(&ADC_CV2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CV2(base, value) (BME_XOR32(&ADC_CV2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV2 bitfields
 */

/*!
 * @name Register ADC_CV2, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV2_CV field. */
#define ADC_RD_CV2_CV(base)  ((ADC_CV2_REG(base) & ADC_CV2_CV_MASK) >> ADC_CV2_CV_SHIFT)
#define ADC_BRD_CV2_CV(base) (BME_UBFX32(&ADC_CV2_REG(base), ADC_CV2_CV_SHIFT, ADC_CV2_CV_WIDTH))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV2_CV(base, value) (ADC_RMW_CV2(base, ADC_CV2_CV_MASK, ADC_CV2_CV(value)))
#define ADC_BWR_CV2_CV(base, value) (BME_BFI32(&ADC_CV2_REG(base), ((uint32_t)(value) << ADC_CV2_CV_SHIFT), ADC_CV2_CV_SHIFT, ADC_CV2_CV_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_SC2 - Status and Control Register 2
 ******************************************************************************/

/*!
 * @brief ADC_SC2 - Status and Control Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The status and control register 2 (SC2) contains the conversion active,
 * hardware/software trigger select, compare function, and voltage reference select of
 * the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC2 register
 */
/*@{*/
#define ADC_RD_SC2(base)         (ADC_SC2_REG(base))
#define ADC_WR_SC2(base, value)  (ADC_SC2_REG(base) = (value))
#define ADC_RMW_SC2(base, mask, value) (ADC_WR_SC2(base, (ADC_RD_SC2(base) & ~(mask)) | (value)))
#define ADC_SET_SC2(base, value) (BME_OR32(&ADC_SC2_REG(base), (uint32_t)(value)))
#define ADC_CLR_SC2(base, value) (BME_AND32(&ADC_SC2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_SC2(base, value) (BME_XOR32(&ADC_SC2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC2 bitfields
 */

/*!
 * @name Register ADC_SC2, field REFSEL[1:0] (RW)
 *
 * Selects the voltage reference source used for conversions.
 *
 * Values:
 * - 00 - Default voltage reference pin pair, that is, external pins VREFH and
 *     VREFL
 * - 01 - Alternate reference pair, that is, VALTH and VALTL . This pair may be
 *     additional external pins or internal sources depending on the MCU
 *     configuration. See the chip configuration information for details specific to this
 *     MCU
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_REFSEL field. */
#define ADC_RD_SC2_REFSEL(base) ((ADC_SC2_REG(base) & ADC_SC2_REFSEL_MASK) >> ADC_SC2_REFSEL_SHIFT)
#define ADC_BRD_SC2_REFSEL(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_REFSEL_SHIFT, ADC_SC2_REFSEL_WIDTH))

/*! @brief Set the REFSEL field to a new value. */
#define ADC_WR_SC2_REFSEL(base, value) (ADC_RMW_SC2(base, ADC_SC2_REFSEL_MASK, ADC_SC2_REFSEL(value)))
#define ADC_BWR_SC2_REFSEL(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_REFSEL_SHIFT), ADC_SC2_REFSEL_SHIFT, ADC_SC2_REFSEL_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field DMAEN[2] (RW)
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled and will assert the ADC DMA request during an ADC
 *     conversion complete event noted when any of the SC1n[COCO] flags is asserted.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_DMAEN field. */
#define ADC_RD_SC2_DMAEN(base) ((ADC_SC2_REG(base) & ADC_SC2_DMAEN_MASK) >> ADC_SC2_DMAEN_SHIFT)
#define ADC_BRD_SC2_DMAEN(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_DMAEN_SHIFT, ADC_SC2_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define ADC_WR_SC2_DMAEN(base, value) (ADC_RMW_SC2(base, ADC_SC2_DMAEN_MASK, ADC_SC2_DMAEN(value)))
#define ADC_BWR_SC2_DMAEN(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_DMAEN_SHIFT), ADC_SC2_DMAEN_SHIFT, ADC_SC2_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACREN[3] (RW)
 *
 * Configures the compare function to check if the conversion result of the
 * input being monitored is either between or outside the range formed by CV1 and CV2
 * determined by the value of ACFGT. ACFE must be set for ACFGT to have any
 * effect.
 *
 * Values:
 * - 0 - Range function disabled. Only CV1 is compared.
 * - 1 - Range function enabled. Both CV1 and CV2 are compared.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACREN field. */
#define ADC_RD_SC2_ACREN(base) ((ADC_SC2_REG(base) & ADC_SC2_ACREN_MASK) >> ADC_SC2_ACREN_SHIFT)
#define ADC_BRD_SC2_ACREN(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACREN_SHIFT, ADC_SC2_ACREN_WIDTH))

/*! @brief Set the ACREN field to a new value. */
#define ADC_WR_SC2_ACREN(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACREN_MASK, ADC_SC2_ACREN(value)))
#define ADC_BWR_SC2_ACREN(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACREN_SHIFT), ADC_SC2_ACREN_SHIFT, ADC_SC2_ACREN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFGT[4] (RW)
 *
 * Configures the compare function to check the conversion result relative to
 * the CV1 and CV2 based upon the value of ACREN. ACFE must be set for ACFGT to
 * have any effect.
 *
 * Values:
 * - 0 - Configures less than threshold, outside range not inclusive and inside
 *     range not inclusive; functionality based on the values placed in CV1 and
 *     CV2.
 * - 1 - Configures greater than or equal to threshold, outside and inside
 *     ranges inclusive; functionality based on the values placed in CV1 and CV2.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFGT field. */
#define ADC_RD_SC2_ACFGT(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFGT_MASK) >> ADC_SC2_ACFGT_SHIFT)
#define ADC_BRD_SC2_ACFGT(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACFGT_SHIFT, ADC_SC2_ACFGT_WIDTH))

/*! @brief Set the ACFGT field to a new value. */
#define ADC_WR_SC2_ACFGT(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFGT_MASK, ADC_SC2_ACFGT(value)))
#define ADC_BWR_SC2_ACFGT(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACFGT_SHIFT), ADC_SC2_ACFGT_SHIFT, ADC_SC2_ACFGT_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFE[5] (RW)
 *
 * Enables the compare function.
 *
 * Values:
 * - 0 - Compare function disabled.
 * - 1 - Compare function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFE field. */
#define ADC_RD_SC2_ACFE(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFE_MASK) >> ADC_SC2_ACFE_SHIFT)
#define ADC_BRD_SC2_ACFE(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACFE_SHIFT, ADC_SC2_ACFE_WIDTH))

/*! @brief Set the ACFE field to a new value. */
#define ADC_WR_SC2_ACFE(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFE_MASK, ADC_SC2_ACFE(value)))
#define ADC_BWR_SC2_ACFE(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACFE_SHIFT), ADC_SC2_ACFE_SHIFT, ADC_SC2_ACFE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADTRG[6] (RW)
 *
 * Selects the type of trigger used for initiating a conversion. Two types of
 * trigger are selectable: Software trigger: When software trigger is selected, a
 * conversion is initiated following a write to SC1A. Hardware trigger: When
 * hardware trigger is selected, a conversion is initiated following the assertion of
 * the ADHWT input after a pulse of the ADHWTSn input.
 *
 * Values:
 * - 0 - Software trigger selected.
 * - 1 - Hardware trigger selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADTRG field. */
#define ADC_RD_SC2_ADTRG(base) ((ADC_SC2_REG(base) & ADC_SC2_ADTRG_MASK) >> ADC_SC2_ADTRG_SHIFT)
#define ADC_BRD_SC2_ADTRG(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ADTRG_SHIFT, ADC_SC2_ADTRG_WIDTH))

/*! @brief Set the ADTRG field to a new value. */
#define ADC_WR_SC2_ADTRG(base, value) (ADC_RMW_SC2(base, ADC_SC2_ADTRG_MASK, ADC_SC2_ADTRG(value)))
#define ADC_BWR_SC2_ADTRG(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ADTRG_SHIFT), ADC_SC2_ADTRG_SHIFT, ADC_SC2_ADTRG_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADACT[7] (RO)
 *
 * Indicates that a conversion or hardware averaging is in progress. ADACT is
 * set when a conversion is initiated and cleared when a conversion is completed or
 * aborted.
 *
 * Values:
 * - 0 - Conversion not in progress.
 * - 1 - Conversion in progress.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADACT field. */
#define ADC_RD_SC2_ADACT(base) ((ADC_SC2_REG(base) & ADC_SC2_ADACT_MASK) >> ADC_SC2_ADACT_SHIFT)
#define ADC_BRD_SC2_ADACT(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ADACT_SHIFT, ADC_SC2_ADACT_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_SC3 - Status and Control Register 3
 ******************************************************************************/

/*!
 * @brief ADC_SC3 - Status and Control Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Status and Control Register 3 (SC3) controls the calibration, continuous
 * convert, and hardware averaging functions of the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC3 register
 */
/*@{*/
#define ADC_RD_SC3(base)         (ADC_SC3_REG(base))
#define ADC_WR_SC3(base, value)  (ADC_SC3_REG(base) = (value))
#define ADC_RMW_SC3(base, mask, value) (ADC_WR_SC3(base, (ADC_RD_SC3(base) & ~(mask)) | (value)))
#define ADC_SET_SC3(base, value) (BME_OR32(&ADC_SC3_REG(base), (uint32_t)(value)))
#define ADC_CLR_SC3(base, value) (BME_AND32(&ADC_SC3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_SC3(base, value) (BME_XOR32(&ADC_SC3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC3 bitfields
 */

/*!
 * @name Register ADC_SC3, field AVGS[1:0] (RW)
 *
 * Determines how many ADC conversions will be averaged to create the ADC
 * average result.
 *
 * Values:
 * - 00 - 4 samples averaged.
 * - 01 - 8 samples averaged.
 * - 10 - 16 samples averaged.
 * - 11 - 32 samples averaged.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGS field. */
#define ADC_RD_SC3_AVGS(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGS_MASK) >> ADC_SC3_AVGS_SHIFT)
#define ADC_BRD_SC3_AVGS(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_AVGS_SHIFT, ADC_SC3_AVGS_WIDTH))

/*! @brief Set the AVGS field to a new value. */
#define ADC_WR_SC3_AVGS(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGS_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGS(value)))
#define ADC_BWR_SC3_AVGS(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_AVGS_SHIFT), ADC_SC3_AVGS_SHIFT, ADC_SC3_AVGS_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field AVGE[2] (RW)
 *
 * Enables the hardware average function of the ADC.
 *
 * Values:
 * - 0 - Hardware average function disabled.
 * - 1 - Hardware average function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGE field. */
#define ADC_RD_SC3_AVGE(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGE_MASK) >> ADC_SC3_AVGE_SHIFT)
#define ADC_BRD_SC3_AVGE(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_AVGE_SHIFT, ADC_SC3_AVGE_WIDTH))

/*! @brief Set the AVGE field to a new value. */
#define ADC_WR_SC3_AVGE(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGE_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGE(value)))
#define ADC_BWR_SC3_AVGE(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_AVGE_SHIFT), ADC_SC3_AVGE_SHIFT, ADC_SC3_AVGE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field ADCO[3] (RW)
 *
 * Enables continuous conversions.
 *
 * Values:
 * - 0 - One conversion or one set of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 * - 1 - Continuous conversions or sets of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_ADCO field. */
#define ADC_RD_SC3_ADCO(base) ((ADC_SC3_REG(base) & ADC_SC3_ADCO_MASK) >> ADC_SC3_ADCO_SHIFT)
#define ADC_BRD_SC3_ADCO(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_ADCO_SHIFT, ADC_SC3_ADCO_WIDTH))

/*! @brief Set the ADCO field to a new value. */
#define ADC_WR_SC3_ADCO(base, value) (ADC_RMW_SC3(base, (ADC_SC3_ADCO_MASK | ADC_SC3_CALF_MASK), ADC_SC3_ADCO(value)))
#define ADC_BWR_SC3_ADCO(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_ADCO_SHIFT), ADC_SC3_ADCO_SHIFT, ADC_SC3_ADCO_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field CALF[6] (W1C)
 *
 * Displays the result of the calibration sequence. The calibration sequence
 * will fail if SC2[ADTRG] = 1, any ADC register is written, or any stop mode is
 * entered before the calibration sequence completes. Writing 1 to CALF clears it.
 *
 * Values:
 * - 0 - Calibration completed normally.
 * - 1 - Calibration failed. ADC accuracy specifications are not guaranteed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CALF field. */
#define ADC_RD_SC3_CALF(base) ((ADC_SC3_REG(base) & ADC_SC3_CALF_MASK) >> ADC_SC3_CALF_SHIFT)
#define ADC_BRD_SC3_CALF(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_CALF_SHIFT, ADC_SC3_CALF_WIDTH))

/*! @brief Set the CALF field to a new value. */
#define ADC_WR_SC3_CALF(base, value) (ADC_RMW_SC3(base, ADC_SC3_CALF_MASK, ADC_SC3_CALF(value)))
#define ADC_BWR_SC3_CALF(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_CALF_SHIFT), ADC_SC3_CALF_SHIFT, ADC_SC3_CALF_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field CAL[7] (RW)
 *
 * Begins the calibration sequence when set. This field stays set while the
 * calibration is in progress and is cleared when the calibration sequence is
 * completed. CALF must be checked to determine the result of the calibration sequence.
 * Once started, the calibration routine cannot be interrupted by writes to the
 * ADC registers or the results will be invalid and CALF will set. Setting CAL
 * will abort any current conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CAL field. */
#define ADC_RD_SC3_CAL(base) ((ADC_SC3_REG(base) & ADC_SC3_CAL_MASK) >> ADC_SC3_CAL_SHIFT)
#define ADC_BRD_SC3_CAL(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_CAL_SHIFT, ADC_SC3_CAL_WIDTH))

/*! @brief Set the CAL field to a new value. */
#define ADC_WR_SC3_CAL(base, value) (ADC_RMW_SC3(base, (ADC_SC3_CAL_MASK | ADC_SC3_CALF_MASK), ADC_SC3_CAL(value)))
#define ADC_BWR_SC3_CAL(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_CAL_SHIFT), ADC_SC3_CAL_SHIFT, ADC_SC3_CAL_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_OFS - ADC Offset Correction Register
 ******************************************************************************/

/*!
 * @brief ADC_OFS - ADC Offset Correction Register (RW)
 *
 * Reset value: 0x00000004U
 *
 * The ADC Offset Correction Register (OFS) contains the user-selected or
 * calibration-generated offset error correction value. This register is a 2's
 * complement, left-justified, 16-bit value . The value in OFS is subtracted from the
 * conversion and the result is transferred into the result registers, Rn. If the
 * result is greater than the maximum or less than the minimum result value, it is
 * forced to the appropriate limit for the current mode of operation.
 */
/*!
 * @name Constants and macros for entire ADC_OFS register
 */
/*@{*/
#define ADC_RD_OFS(base)         (ADC_OFS_REG(base))
#define ADC_WR_OFS(base, value)  (ADC_OFS_REG(base) = (value))
#define ADC_RMW_OFS(base, mask, value) (ADC_WR_OFS(base, (ADC_RD_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_OFS(base, value) (BME_OR32(&ADC_OFS_REG(base), (uint32_t)(value)))
#define ADC_CLR_OFS(base, value) (BME_AND32(&ADC_OFS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_OFS(base, value) (BME_XOR32(&ADC_OFS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_OFS bitfields
 */

/*!
 * @name Register ADC_OFS, field OFS[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_OFS_OFS field. */
#define ADC_RD_OFS_OFS(base) ((ADC_OFS_REG(base) & ADC_OFS_OFS_MASK) >> ADC_OFS_OFS_SHIFT)
#define ADC_BRD_OFS_OFS(base) (BME_UBFX32(&ADC_OFS_REG(base), ADC_OFS_OFS_SHIFT, ADC_OFS_OFS_WIDTH))

/*! @brief Set the OFS field to a new value. */
#define ADC_WR_OFS_OFS(base, value) (ADC_RMW_OFS(base, ADC_OFS_OFS_MASK, ADC_OFS_OFS(value)))
#define ADC_BWR_OFS_OFS(base, value) (BME_BFI32(&ADC_OFS_REG(base), ((uint32_t)(value) << ADC_OFS_OFS_SHIFT), ADC_OFS_OFS_SHIFT, ADC_OFS_OFS_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_PG - ADC Plus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_PG - ADC Plus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Plus-Side Gain Register (PG) contains the gain error correction for the
 * plus-side input in differential mode or the overall conversion in single-ended
 * mode. PG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between PG[15] and PG[14]. This register must be
 * written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met.
 */
/*!
 * @name Constants and macros for entire ADC_PG register
 */
/*@{*/
#define ADC_RD_PG(base)          (ADC_PG_REG(base))
#define ADC_WR_PG(base, value)   (ADC_PG_REG(base) = (value))
#define ADC_RMW_PG(base, mask, value) (ADC_WR_PG(base, (ADC_RD_PG(base) & ~(mask)) | (value)))
#define ADC_SET_PG(base, value)  (BME_OR32(&ADC_PG_REG(base), (uint32_t)(value)))
#define ADC_CLR_PG(base, value)  (BME_AND32(&ADC_PG_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_PG(base, value)  (BME_XOR32(&ADC_PG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_PG bitfields
 */

/*!
 * @name Register ADC_PG, field PG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_PG_PG field. */
#define ADC_RD_PG_PG(base)   ((ADC_PG_REG(base) & ADC_PG_PG_MASK) >> ADC_PG_PG_SHIFT)
#define ADC_BRD_PG_PG(base)  (BME_UBFX32(&ADC_PG_REG(base), ADC_PG_PG_SHIFT, ADC_PG_PG_WIDTH))

/*! @brief Set the PG field to a new value. */
#define ADC_WR_PG_PG(base, value) (ADC_RMW_PG(base, ADC_PG_PG_MASK, ADC_PG_PG(value)))
#define ADC_BWR_PG_PG(base, value) (BME_BFI32(&ADC_PG_REG(base), ((uint32_t)(value) << ADC_PG_PG_SHIFT), ADC_PG_PG_SHIFT, ADC_PG_PG_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_MG - ADC Minus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_MG - ADC Minus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Minus-Side Gain Register (MG) contains the gain error correction for the
 * minus-side input in differential mode. This register is ignored in
 * single-ended mode. MG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between MG[15] and MG[14]. This register must
 * be written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met.
 */
/*!
 * @name Constants and macros for entire ADC_MG register
 */
/*@{*/
#define ADC_RD_MG(base)          (ADC_MG_REG(base))
#define ADC_WR_MG(base, value)   (ADC_MG_REG(base) = (value))
#define ADC_RMW_MG(base, mask, value) (ADC_WR_MG(base, (ADC_RD_MG(base) & ~(mask)) | (value)))
#define ADC_SET_MG(base, value)  (BME_OR32(&ADC_MG_REG(base), (uint32_t)(value)))
#define ADC_CLR_MG(base, value)  (BME_AND32(&ADC_MG_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_MG(base, value)  (BME_XOR32(&ADC_MG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_MG bitfields
 */

/*!
 * @name Register ADC_MG, field MG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_MG_MG field. */
#define ADC_RD_MG_MG(base)   ((ADC_MG_REG(base) & ADC_MG_MG_MASK) >> ADC_MG_MG_SHIFT)
#define ADC_BRD_MG_MG(base)  (BME_UBFX32(&ADC_MG_REG(base), ADC_MG_MG_SHIFT, ADC_MG_MG_WIDTH))

/*! @brief Set the MG field to a new value. */
#define ADC_WR_MG_MG(base, value) (ADC_RMW_MG(base, ADC_MG_MG_MASK, ADC_MG_MG(value)))
#define ADC_BWR_MG_MG(base, value) (BME_BFI32(&ADC_MG_REG(base), ((uint32_t)(value) << ADC_MG_MG_SHIFT), ADC_MG_MG_SHIFT, ADC_MG_MG_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLPD - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPD - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Plus-Side General Calibration Value Registers (CLPx) contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLP0[5:0], CLP1[6:0],
 * CLP2[7:0], CLP3[8:0], CLP4[9:0], CLPS[5:0], and CLPD[5:0]. CLPx are automatically set
 * when the self-calibration sequence is done, that is, CAL is cleared. If these
 * registers are written by the user after calibration, the linearity error
 * specifications may not be met.
 */
/*!
 * @name Constants and macros for entire ADC_CLPD register
 */
/*@{*/
#define ADC_RD_CLPD(base)        (ADC_CLPD_REG(base))
#define ADC_WR_CLPD(base, value) (ADC_CLPD_REG(base) = (value))
#define ADC_RMW_CLPD(base, mask, value) (ADC_WR_CLPD(base, (ADC_RD_CLPD(base) & ~(mask)) | (value)))
#define ADC_SET_CLPD(base, value) (BME_OR32(&ADC_CLPD_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLPD(base, value) (BME_AND32(&ADC_CLPD_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLPD(base, value) (BME_XOR32(&ADC_CLPD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPD bitfields
 */

/*!
 * @name Register ADC_CLPD, field CLPD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPD_CLPD field. */
#define ADC_RD_CLPD_CLPD(base) ((ADC_CLPD_REG(base) & ADC_CLPD_CLPD_MASK) >> ADC_CLPD_CLPD_SHIFT)
#define ADC_BRD_CLPD_CLPD(base) (BME_UBFX32(&ADC_CLPD_REG(base), ADC_CLPD_CLPD_SHIFT, ADC_CLPD_CLPD_WIDTH))

/*! @brief Set the CLPD field to a new value. */
#define ADC_WR_CLPD_CLPD(base, value) (ADC_RMW_CLPD(base, ADC_CLPD_CLPD_MASK, ADC_CLPD_CLPD(value)))
#define ADC_BWR_CLPD_CLPD(base, value) (BME_BFI32(&ADC_CLPD_REG(base), ((uint32_t)(value) << ADC_CLPD_CLPD_SHIFT), ADC_CLPD_CLPD_SHIFT, ADC_CLPD_CLPD_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLPS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLPS register
 */
/*@{*/
#define ADC_RD_CLPS(base)        (ADC_CLPS_REG(base))
#define ADC_WR_CLPS(base, value) (ADC_CLPS_REG(base) = (value))
#define ADC_RMW_CLPS(base, mask, value) (ADC_WR_CLPS(base, (ADC_RD_CLPS(base) & ~(mask)) | (value)))
#define ADC_SET_CLPS(base, value) (BME_OR32(&ADC_CLPS_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLPS(base, value) (BME_AND32(&ADC_CLPS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLPS(base, value) (BME_XOR32(&ADC_CLPS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPS bitfields
 */

/*!
 * @name Register ADC_CLPS, field CLPS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPS_CLPS field. */
#define ADC_RD_CLPS_CLPS(base) ((ADC_CLPS_REG(base) & ADC_CLPS_CLPS_MASK) >> ADC_CLPS_CLPS_SHIFT)
#define ADC_BRD_CLPS_CLPS(base) (BME_UBFX32(&ADC_CLPS_REG(base), ADC_CLPS_CLPS_SHIFT, ADC_CLPS_CLPS_WIDTH))

/*! @brief Set the CLPS field to a new value. */
#define ADC_WR_CLPS_CLPS(base, value) (ADC_RMW_CLPS(base, ADC_CLPS_CLPS_MASK, ADC_CLPS_CLPS(value)))
#define ADC_BWR_CLPS_CLPS(base, value) (BME_BFI32(&ADC_CLPS_REG(base), ((uint32_t)(value) << ADC_CLPS_CLPS_SHIFT), ADC_CLPS_CLPS_SHIFT, ADC_CLPS_CLPS_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP4 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP4 register
 */
/*@{*/
#define ADC_RD_CLP4(base)        (ADC_CLP4_REG(base))
#define ADC_WR_CLP4(base, value) (ADC_CLP4_REG(base) = (value))
#define ADC_RMW_CLP4(base, mask, value) (ADC_WR_CLP4(base, (ADC_RD_CLP4(base) & ~(mask)) | (value)))
#define ADC_SET_CLP4(base, value) (BME_OR32(&ADC_CLP4_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP4(base, value) (BME_AND32(&ADC_CLP4_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP4(base, value) (BME_XOR32(&ADC_CLP4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP4 bitfields
 */

/*!
 * @name Register ADC_CLP4, field CLP4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP4_CLP4 field. */
#define ADC_RD_CLP4_CLP4(base) ((ADC_CLP4_REG(base) & ADC_CLP4_CLP4_MASK) >> ADC_CLP4_CLP4_SHIFT)
#define ADC_BRD_CLP4_CLP4(base) (BME_UBFX32(&ADC_CLP4_REG(base), ADC_CLP4_CLP4_SHIFT, ADC_CLP4_CLP4_WIDTH))

/*! @brief Set the CLP4 field to a new value. */
#define ADC_WR_CLP4_CLP4(base, value) (ADC_RMW_CLP4(base, ADC_CLP4_CLP4_MASK, ADC_CLP4_CLP4(value)))
#define ADC_BWR_CLP4_CLP4(base, value) (BME_BFI32(&ADC_CLP4_REG(base), ((uint32_t)(value) << ADC_CLP4_CLP4_SHIFT), ADC_CLP4_CLP4_SHIFT, ADC_CLP4_CLP4_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP3 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP3 register
 */
/*@{*/
#define ADC_RD_CLP3(base)        (ADC_CLP3_REG(base))
#define ADC_WR_CLP3(base, value) (ADC_CLP3_REG(base) = (value))
#define ADC_RMW_CLP3(base, mask, value) (ADC_WR_CLP3(base, (ADC_RD_CLP3(base) & ~(mask)) | (value)))
#define ADC_SET_CLP3(base, value) (BME_OR32(&ADC_CLP3_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP3(base, value) (BME_AND32(&ADC_CLP3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP3(base, value) (BME_XOR32(&ADC_CLP3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP3 bitfields
 */

/*!
 * @name Register ADC_CLP3, field CLP3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP3_CLP3 field. */
#define ADC_RD_CLP3_CLP3(base) ((ADC_CLP3_REG(base) & ADC_CLP3_CLP3_MASK) >> ADC_CLP3_CLP3_SHIFT)
#define ADC_BRD_CLP3_CLP3(base) (BME_UBFX32(&ADC_CLP3_REG(base), ADC_CLP3_CLP3_SHIFT, ADC_CLP3_CLP3_WIDTH))

/*! @brief Set the CLP3 field to a new value. */
#define ADC_WR_CLP3_CLP3(base, value) (ADC_RMW_CLP3(base, ADC_CLP3_CLP3_MASK, ADC_CLP3_CLP3(value)))
#define ADC_BWR_CLP3_CLP3(base, value) (BME_BFI32(&ADC_CLP3_REG(base), ((uint32_t)(value) << ADC_CLP3_CLP3_SHIFT), ADC_CLP3_CLP3_SHIFT, ADC_CLP3_CLP3_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP2 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP2 register
 */
/*@{*/
#define ADC_RD_CLP2(base)        (ADC_CLP2_REG(base))
#define ADC_WR_CLP2(base, value) (ADC_CLP2_REG(base) = (value))
#define ADC_RMW_CLP2(base, mask, value) (ADC_WR_CLP2(base, (ADC_RD_CLP2(base) & ~(mask)) | (value)))
#define ADC_SET_CLP2(base, value) (BME_OR32(&ADC_CLP2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP2(base, value) (BME_AND32(&ADC_CLP2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP2(base, value) (BME_XOR32(&ADC_CLP2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP2 bitfields
 */

/*!
 * @name Register ADC_CLP2, field CLP2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP2_CLP2 field. */
#define ADC_RD_CLP2_CLP2(base) ((ADC_CLP2_REG(base) & ADC_CLP2_CLP2_MASK) >> ADC_CLP2_CLP2_SHIFT)
#define ADC_BRD_CLP2_CLP2(base) (BME_UBFX32(&ADC_CLP2_REG(base), ADC_CLP2_CLP2_SHIFT, ADC_CLP2_CLP2_WIDTH))

/*! @brief Set the CLP2 field to a new value. */
#define ADC_WR_CLP2_CLP2(base, value) (ADC_RMW_CLP2(base, ADC_CLP2_CLP2_MASK, ADC_CLP2_CLP2(value)))
#define ADC_BWR_CLP2_CLP2(base, value) (BME_BFI32(&ADC_CLP2_REG(base), ((uint32_t)(value) << ADC_CLP2_CLP2_SHIFT), ADC_CLP2_CLP2_SHIFT, ADC_CLP2_CLP2_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP1 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP1 register
 */
/*@{*/
#define ADC_RD_CLP1(base)        (ADC_CLP1_REG(base))
#define ADC_WR_CLP1(base, value) (ADC_CLP1_REG(base) = (value))
#define ADC_RMW_CLP1(base, mask, value) (ADC_WR_CLP1(base, (ADC_RD_CLP1(base) & ~(mask)) | (value)))
#define ADC_SET_CLP1(base, value) (BME_OR32(&ADC_CLP1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP1(base, value) (BME_AND32(&ADC_CLP1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP1(base, value) (BME_XOR32(&ADC_CLP1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP1 bitfields
 */

/*!
 * @name Register ADC_CLP1, field CLP1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP1_CLP1 field. */
#define ADC_RD_CLP1_CLP1(base) ((ADC_CLP1_REG(base) & ADC_CLP1_CLP1_MASK) >> ADC_CLP1_CLP1_SHIFT)
#define ADC_BRD_CLP1_CLP1(base) (BME_UBFX32(&ADC_CLP1_REG(base), ADC_CLP1_CLP1_SHIFT, ADC_CLP1_CLP1_WIDTH))

/*! @brief Set the CLP1 field to a new value. */
#define ADC_WR_CLP1_CLP1(base, value) (ADC_RMW_CLP1(base, ADC_CLP1_CLP1_MASK, ADC_CLP1_CLP1(value)))
#define ADC_BWR_CLP1_CLP1(base, value) (BME_BFI32(&ADC_CLP1_REG(base), ((uint32_t)(value) << ADC_CLP1_CLP1_SHIFT), ADC_CLP1_CLP1_SHIFT, ADC_CLP1_CLP1_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP0 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP0 register
 */
/*@{*/
#define ADC_RD_CLP0(base)        (ADC_CLP0_REG(base))
#define ADC_WR_CLP0(base, value) (ADC_CLP0_REG(base) = (value))
#define ADC_RMW_CLP0(base, mask, value) (ADC_WR_CLP0(base, (ADC_RD_CLP0(base) & ~(mask)) | (value)))
#define ADC_SET_CLP0(base, value) (BME_OR32(&ADC_CLP0_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP0(base, value) (BME_AND32(&ADC_CLP0_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP0(base, value) (BME_XOR32(&ADC_CLP0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP0 bitfields
 */

/*!
 * @name Register ADC_CLP0, field CLP0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP0_CLP0 field. */
#define ADC_RD_CLP0_CLP0(base) ((ADC_CLP0_REG(base) & ADC_CLP0_CLP0_MASK) >> ADC_CLP0_CLP0_SHIFT)
#define ADC_BRD_CLP0_CLP0(base) (BME_UBFX32(&ADC_CLP0_REG(base), ADC_CLP0_CLP0_SHIFT, ADC_CLP0_CLP0_WIDTH))

/*! @brief Set the CLP0 field to a new value. */
#define ADC_WR_CLP0_CLP0(base, value) (ADC_RMW_CLP0(base, ADC_CLP0_CLP0_MASK, ADC_CLP0_CLP0(value)))
#define ADC_BWR_CLP0_CLP0(base, value) (BME_BFI32(&ADC_CLP0_REG(base), ((uint32_t)(value) << ADC_CLP0_CLP0_SHIFT), ADC_CLP0_CLP0_SHIFT, ADC_CLP0_CLP0_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLMD - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLMD - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Minus-Side General Calibration Value (CLMx) registers contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLM0[5:0], CLM1[6:0],
 * CLM2[7:0], CLM3[8:0], CLM4[9:0], CLMS[5:0], and CLMD[5:0]. CLMx are automatically
 * set when the self-calibration sequence is done, that is, CAL is cleared. If
 * these registers are written by the user after calibration, the linearity error
 * specifications may not be met.
 */
/*!
 * @name Constants and macros for entire ADC_CLMD register
 */
/*@{*/
#define ADC_RD_CLMD(base)        (ADC_CLMD_REG(base))
#define ADC_WR_CLMD(base, value) (ADC_CLMD_REG(base) = (value))
#define ADC_RMW_CLMD(base, mask, value) (ADC_WR_CLMD(base, (ADC_RD_CLMD(base) & ~(mask)) | (value)))
#define ADC_SET_CLMD(base, value) (BME_OR32(&ADC_CLMD_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLMD(base, value) (BME_AND32(&ADC_CLMD_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLMD(base, value) (BME_XOR32(&ADC_CLMD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMD bitfields
 */

/*!
 * @name Register ADC_CLMD, field CLMD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLMD_CLMD field. */
#define ADC_RD_CLMD_CLMD(base) ((ADC_CLMD_REG(base) & ADC_CLMD_CLMD_MASK) >> ADC_CLMD_CLMD_SHIFT)
#define ADC_BRD_CLMD_CLMD(base) (BME_UBFX32(&ADC_CLMD_REG(base), ADC_CLMD_CLMD_SHIFT, ADC_CLMD_CLMD_WIDTH))

/*! @brief Set the CLMD field to a new value. */
#define ADC_WR_CLMD_CLMD(base, value) (ADC_RMW_CLMD(base, ADC_CLMD_CLMD_MASK, ADC_CLMD_CLMD(value)))
#define ADC_BWR_CLMD_CLMD(base, value) (BME_BFI32(&ADC_CLMD_REG(base), ((uint32_t)(value) << ADC_CLMD_CLMD_SHIFT), ADC_CLMD_CLMD_SHIFT, ADC_CLMD_CLMD_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLMS - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLMS - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLMS register
 */
/*@{*/
#define ADC_RD_CLMS(base)        (ADC_CLMS_REG(base))
#define ADC_WR_CLMS(base, value) (ADC_CLMS_REG(base) = (value))
#define ADC_RMW_CLMS(base, mask, value) (ADC_WR_CLMS(base, (ADC_RD_CLMS(base) & ~(mask)) | (value)))
#define ADC_SET_CLMS(base, value) (BME_OR32(&ADC_CLMS_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLMS(base, value) (BME_AND32(&ADC_CLMS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLMS(base, value) (BME_XOR32(&ADC_CLMS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMS bitfields
 */

/*!
 * @name Register ADC_CLMS, field CLMS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLMS_CLMS field. */
#define ADC_RD_CLMS_CLMS(base) ((ADC_CLMS_REG(base) & ADC_CLMS_CLMS_MASK) >> ADC_CLMS_CLMS_SHIFT)
#define ADC_BRD_CLMS_CLMS(base) (BME_UBFX32(&ADC_CLMS_REG(base), ADC_CLMS_CLMS_SHIFT, ADC_CLMS_CLMS_WIDTH))

/*! @brief Set the CLMS field to a new value. */
#define ADC_WR_CLMS_CLMS(base, value) (ADC_RMW_CLMS(base, ADC_CLMS_CLMS_MASK, ADC_CLMS_CLMS(value)))
#define ADC_BWR_CLMS_CLMS(base, value) (BME_BFI32(&ADC_CLMS_REG(base), ((uint32_t)(value) << ADC_CLMS_CLMS_SHIFT), ADC_CLMS_CLMS_SHIFT, ADC_CLMS_CLMS_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM4 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM4 register
 */
/*@{*/
#define ADC_RD_CLM4(base)        (ADC_CLM4_REG(base))
#define ADC_WR_CLM4(base, value) (ADC_CLM4_REG(base) = (value))
#define ADC_RMW_CLM4(base, mask, value) (ADC_WR_CLM4(base, (ADC_RD_CLM4(base) & ~(mask)) | (value)))
#define ADC_SET_CLM4(base, value) (BME_OR32(&ADC_CLM4_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM4(base, value) (BME_AND32(&ADC_CLM4_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM4(base, value) (BME_XOR32(&ADC_CLM4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM4 bitfields
 */

/*!
 * @name Register ADC_CLM4, field CLM4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM4_CLM4 field. */
#define ADC_RD_CLM4_CLM4(base) ((ADC_CLM4_REG(base) & ADC_CLM4_CLM4_MASK) >> ADC_CLM4_CLM4_SHIFT)
#define ADC_BRD_CLM4_CLM4(base) (BME_UBFX32(&ADC_CLM4_REG(base), ADC_CLM4_CLM4_SHIFT, ADC_CLM4_CLM4_WIDTH))

/*! @brief Set the CLM4 field to a new value. */
#define ADC_WR_CLM4_CLM4(base, value) (ADC_RMW_CLM4(base, ADC_CLM4_CLM4_MASK, ADC_CLM4_CLM4(value)))
#define ADC_BWR_CLM4_CLM4(base, value) (BME_BFI32(&ADC_CLM4_REG(base), ((uint32_t)(value) << ADC_CLM4_CLM4_SHIFT), ADC_CLM4_CLM4_SHIFT, ADC_CLM4_CLM4_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM3 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM3 register
 */
/*@{*/
#define ADC_RD_CLM3(base)        (ADC_CLM3_REG(base))
#define ADC_WR_CLM3(base, value) (ADC_CLM3_REG(base) = (value))
#define ADC_RMW_CLM3(base, mask, value) (ADC_WR_CLM3(base, (ADC_RD_CLM3(base) & ~(mask)) | (value)))
#define ADC_SET_CLM3(base, value) (BME_OR32(&ADC_CLM3_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM3(base, value) (BME_AND32(&ADC_CLM3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM3(base, value) (BME_XOR32(&ADC_CLM3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM3 bitfields
 */

/*!
 * @name Register ADC_CLM3, field CLM3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM3_CLM3 field. */
#define ADC_RD_CLM3_CLM3(base) ((ADC_CLM3_REG(base) & ADC_CLM3_CLM3_MASK) >> ADC_CLM3_CLM3_SHIFT)
#define ADC_BRD_CLM3_CLM3(base) (BME_UBFX32(&ADC_CLM3_REG(base), ADC_CLM3_CLM3_SHIFT, ADC_CLM3_CLM3_WIDTH))

/*! @brief Set the CLM3 field to a new value. */
#define ADC_WR_CLM3_CLM3(base, value) (ADC_RMW_CLM3(base, ADC_CLM3_CLM3_MASK, ADC_CLM3_CLM3(value)))
#define ADC_BWR_CLM3_CLM3(base, value) (BME_BFI32(&ADC_CLM3_REG(base), ((uint32_t)(value) << ADC_CLM3_CLM3_SHIFT), ADC_CLM3_CLM3_SHIFT, ADC_CLM3_CLM3_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM2 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM2 register
 */
/*@{*/
#define ADC_RD_CLM2(base)        (ADC_CLM2_REG(base))
#define ADC_WR_CLM2(base, value) (ADC_CLM2_REG(base) = (value))
#define ADC_RMW_CLM2(base, mask, value) (ADC_WR_CLM2(base, (ADC_RD_CLM2(base) & ~(mask)) | (value)))
#define ADC_SET_CLM2(base, value) (BME_OR32(&ADC_CLM2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM2(base, value) (BME_AND32(&ADC_CLM2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM2(base, value) (BME_XOR32(&ADC_CLM2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM2 bitfields
 */

/*!
 * @name Register ADC_CLM2, field CLM2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM2_CLM2 field. */
#define ADC_RD_CLM2_CLM2(base) ((ADC_CLM2_REG(base) & ADC_CLM2_CLM2_MASK) >> ADC_CLM2_CLM2_SHIFT)
#define ADC_BRD_CLM2_CLM2(base) (BME_UBFX32(&ADC_CLM2_REG(base), ADC_CLM2_CLM2_SHIFT, ADC_CLM2_CLM2_WIDTH))

/*! @brief Set the CLM2 field to a new value. */
#define ADC_WR_CLM2_CLM2(base, value) (ADC_RMW_CLM2(base, ADC_CLM2_CLM2_MASK, ADC_CLM2_CLM2(value)))
#define ADC_BWR_CLM2_CLM2(base, value) (BME_BFI32(&ADC_CLM2_REG(base), ((uint32_t)(value) << ADC_CLM2_CLM2_SHIFT), ADC_CLM2_CLM2_SHIFT, ADC_CLM2_CLM2_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM1 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM1 register
 */
/*@{*/
#define ADC_RD_CLM1(base)        (ADC_CLM1_REG(base))
#define ADC_WR_CLM1(base, value) (ADC_CLM1_REG(base) = (value))
#define ADC_RMW_CLM1(base, mask, value) (ADC_WR_CLM1(base, (ADC_RD_CLM1(base) & ~(mask)) | (value)))
#define ADC_SET_CLM1(base, value) (BME_OR32(&ADC_CLM1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM1(base, value) (BME_AND32(&ADC_CLM1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM1(base, value) (BME_XOR32(&ADC_CLM1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM1 bitfields
 */

/*!
 * @name Register ADC_CLM1, field CLM1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM1_CLM1 field. */
#define ADC_RD_CLM1_CLM1(base) ((ADC_CLM1_REG(base) & ADC_CLM1_CLM1_MASK) >> ADC_CLM1_CLM1_SHIFT)
#define ADC_BRD_CLM1_CLM1(base) (BME_UBFX32(&ADC_CLM1_REG(base), ADC_CLM1_CLM1_SHIFT, ADC_CLM1_CLM1_WIDTH))

/*! @brief Set the CLM1 field to a new value. */
#define ADC_WR_CLM1_CLM1(base, value) (ADC_RMW_CLM1(base, ADC_CLM1_CLM1_MASK, ADC_CLM1_CLM1(value)))
#define ADC_BWR_CLM1_CLM1(base, value) (BME_BFI32(&ADC_CLM1_REG(base), ((uint32_t)(value) << ADC_CLM1_CLM1_SHIFT), ADC_CLM1_CLM1_SHIFT, ADC_CLM1_CLM1_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM0 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM0 register
 */
/*@{*/
#define ADC_RD_CLM0(base)        (ADC_CLM0_REG(base))
#define ADC_WR_CLM0(base, value) (ADC_CLM0_REG(base) = (value))
#define ADC_RMW_CLM0(base, mask, value) (ADC_WR_CLM0(base, (ADC_RD_CLM0(base) & ~(mask)) | (value)))
#define ADC_SET_CLM0(base, value) (BME_OR32(&ADC_CLM0_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM0(base, value) (BME_AND32(&ADC_CLM0_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM0(base, value) (BME_XOR32(&ADC_CLM0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM0 bitfields
 */

/*!
 * @name Register ADC_CLM0, field CLM0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM0_CLM0 field. */
#define ADC_RD_CLM0_CLM0(base) ((ADC_CLM0_REG(base) & ADC_CLM0_CLM0_MASK) >> ADC_CLM0_CLM0_SHIFT)
#define ADC_BRD_CLM0_CLM0(base) (BME_UBFX32(&ADC_CLM0_REG(base), ADC_CLM0_CLM0_SHIFT, ADC_CLM0_CLM0_WIDTH))

/*! @brief Set the CLM0 field to a new value. */
#define ADC_WR_CLM0_CLM0(base, value) (ADC_RMW_CLM0(base, ADC_CLM0_CLM0_MASK, ADC_CLM0_CLM0(value)))
#define ADC_BWR_CLM0_CLM0(base, value) (BME_BFI32(&ADC_CLM0_REG(base), ((uint32_t)(value) << ADC_CLM0_CLM0_SHIFT), ADC_CLM0_CLM0_SHIFT, ADC_CLM0_CLM0_WIDTH))
/*@}*/

/*
 * MKV10Z7 CMP
 *
 * High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
 *
 * Registers defined in this header file:
 * - CMP_CR0 - CMP Control Register 0
 * - CMP_CR1 - CMP Control Register 1
 * - CMP_FPR - CMP Filter Period Register
 * - CMP_SCR - CMP Status and Control Register
 * - CMP_DACCR - DAC Control Register
 * - CMP_MUXCR - MUX Control Register
 */

#define CMP_INSTANCE_COUNT (2U) /*!< Number of instances of the CMP module. */
#define CMP0_IDX (0U) /*!< Instance number for CMP0. */
#define CMP1_IDX (1U) /*!< Instance number for CMP1. */

/*******************************************************************************
 * CMP_CR0 - CMP Control Register 0
 ******************************************************************************/

/*!
 * @brief CMP_CR0 - CMP Control Register 0 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR0 register
 */
/*@{*/
#define CMP_RD_CR0(base)         (CMP_CR0_REG(base))
#define CMP_WR_CR0(base, value)  (CMP_CR0_REG(base) = (value))
#define CMP_RMW_CR0(base, mask, value) (CMP_WR_CR0(base, (CMP_RD_CR0(base) & ~(mask)) | (value)))
#define CMP_SET_CR0(base, value) (BME_OR8(&CMP_CR0_REG(base), (uint8_t)(value)))
#define CMP_CLR_CR0(base, value) (BME_AND8(&CMP_CR0_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_CR0(base, value) (BME_XOR8(&CMP_CR0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR0 bitfields
 */

/*!
 * @name Register CMP_CR0, field HYSTCTR[1:0] (RW)
 *
 * Defines the programmable hysteresis level. The hysteresis values associated
 * with each level are device-specific. See the Data Sheet of the device for the
 * exact values.
 *
 * Values:
 * - 00 - Level 0
 * - 01 - Level 1
 * - 10 - Level 2
 * - 11 - Level 3
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_HYSTCTR field. */
#define CMP_RD_CR0_HYSTCTR(base) ((CMP_CR0_REG(base) & CMP_CR0_HYSTCTR_MASK) >> CMP_CR0_HYSTCTR_SHIFT)
#define CMP_BRD_CR0_HYSTCTR(base) (BME_UBFX8(&CMP_CR0_REG(base), CMP_CR0_HYSTCTR_SHIFT, CMP_CR0_HYSTCTR_WIDTH))

/*! @brief Set the HYSTCTR field to a new value. */
#define CMP_WR_CR0_HYSTCTR(base, value) (CMP_RMW_CR0(base, CMP_CR0_HYSTCTR_MASK, CMP_CR0_HYSTCTR(value)))
#define CMP_BWR_CR0_HYSTCTR(base, value) (BME_BFI8(&CMP_CR0_REG(base), ((uint8_t)(value) << CMP_CR0_HYSTCTR_SHIFT), CMP_CR0_HYSTCTR_SHIFT, CMP_CR0_HYSTCTR_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR0, field FILTER_CNT[6:4] (RW)
 *
 * Represents the number of consecutive samples that must agree prior to the
 * comparator ouput filter accepting a new output state. For information regarding
 * filter programming and latency, see the Functional descriptionThe CMP module
 * can be used to compare two analog input voltages applied to INP and INM. .
 *
 * Values:
 * - 000 - Filter is disabled. If SE = 1, then COUT is a logic 0. This is not a
 *     legal state, and is not recommended. If SE = 0, COUT = COUTA.
 * - 001 - One sample must agree. The comparator output is simply sampled.
 * - 010 - 2 consecutive samples must agree.
 * - 011 - 3 consecutive samples must agree.
 * - 100 - 4 consecutive samples must agree.
 * - 101 - 5 consecutive samples must agree.
 * - 110 - 6 consecutive samples must agree.
 * - 111 - 7 consecutive samples must agree.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_FILTER_CNT field. */
#define CMP_RD_CR0_FILTER_CNT(base) ((CMP_CR0_REG(base) & CMP_CR0_FILTER_CNT_MASK) >> CMP_CR0_FILTER_CNT_SHIFT)
#define CMP_BRD_CR0_FILTER_CNT(base) (BME_UBFX8(&CMP_CR0_REG(base), CMP_CR0_FILTER_CNT_SHIFT, CMP_CR0_FILTER_CNT_WIDTH))

/*! @brief Set the FILTER_CNT field to a new value. */
#define CMP_WR_CR0_FILTER_CNT(base, value) (CMP_RMW_CR0(base, CMP_CR0_FILTER_CNT_MASK, CMP_CR0_FILTER_CNT(value)))
#define CMP_BWR_CR0_FILTER_CNT(base, value) (BME_BFI8(&CMP_CR0_REG(base), ((uint8_t)(value) << CMP_CR0_FILTER_CNT_SHIFT), CMP_CR0_FILTER_CNT_SHIFT, CMP_CR0_FILTER_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_CR1 - CMP Control Register 1
 ******************************************************************************/

/*!
 * @brief CMP_CR1 - CMP Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR1 register
 */
/*@{*/
#define CMP_RD_CR1(base)         (CMP_CR1_REG(base))
#define CMP_WR_CR1(base, value)  (CMP_CR1_REG(base) = (value))
#define CMP_RMW_CR1(base, mask, value) (CMP_WR_CR1(base, (CMP_RD_CR1(base) & ~(mask)) | (value)))
#define CMP_SET_CR1(base, value) (BME_OR8(&CMP_CR1_REG(base), (uint8_t)(value)))
#define CMP_CLR_CR1(base, value) (BME_AND8(&CMP_CR1_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_CR1(base, value) (BME_XOR8(&CMP_CR1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR1 bitfields
 */

/*!
 * @name Register CMP_CR1, field EN[0] (RW)
 *
 * Enables the Analog Comparator module. When the module is not enabled, it
 * remains in the off state, and consumes no power. When the user selects the same
 * input from analog mux to the positive and negative port, the comparator is
 * disabled automatically.
 *
 * Values:
 * - 0 - Analog Comparator is disabled.
 * - 1 - Analog Comparator is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_EN field. */
#define CMP_RD_CR1_EN(base)  ((CMP_CR1_REG(base) & CMP_CR1_EN_MASK) >> CMP_CR1_EN_SHIFT)
#define CMP_BRD_CR1_EN(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_EN_SHIFT, CMP_CR1_EN_WIDTH))

/*! @brief Set the EN field to a new value. */
#define CMP_WR_CR1_EN(base, value) (CMP_RMW_CR1(base, CMP_CR1_EN_MASK, CMP_CR1_EN(value)))
#define CMP_BWR_CR1_EN(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_EN_SHIFT), CMP_CR1_EN_SHIFT, CMP_CR1_EN_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field OPE[1] (RW)
 *
 * Values:
 * - 0 - CMPO is not available on the associated CMPO output pin. If the
 *     comparator does not own the pin, this field has no effect.
 * - 1 - CMPO is available on the associated CMPO output pin. The comparator
 *     output (CMPO) is driven out on the associated CMPO output pin if the
 *     comparator owns the pin. If the comparator does not own the field, this bit has no
 *     effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_OPE field. */
#define CMP_RD_CR1_OPE(base) ((CMP_CR1_REG(base) & CMP_CR1_OPE_MASK) >> CMP_CR1_OPE_SHIFT)
#define CMP_BRD_CR1_OPE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_OPE_SHIFT, CMP_CR1_OPE_WIDTH))

/*! @brief Set the OPE field to a new value. */
#define CMP_WR_CR1_OPE(base, value) (CMP_RMW_CR1(base, CMP_CR1_OPE_MASK, CMP_CR1_OPE(value)))
#define CMP_BWR_CR1_OPE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_OPE_SHIFT), CMP_CR1_OPE_SHIFT, CMP_CR1_OPE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field COS[2] (RW)
 *
 * Values:
 * - 0 - Set the filtered comparator output (CMPO) to equal COUT.
 * - 1 - Set the unfiltered comparator output (CMPO) to equal COUTA.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_COS field. */
#define CMP_RD_CR1_COS(base) ((CMP_CR1_REG(base) & CMP_CR1_COS_MASK) >> CMP_CR1_COS_SHIFT)
#define CMP_BRD_CR1_COS(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_COS_SHIFT, CMP_CR1_COS_WIDTH))

/*! @brief Set the COS field to a new value. */
#define CMP_WR_CR1_COS(base, value) (CMP_RMW_CR1(base, CMP_CR1_COS_MASK, CMP_CR1_COS(value)))
#define CMP_BWR_CR1_COS(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_COS_SHIFT), CMP_CR1_COS_SHIFT, CMP_CR1_COS_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field INV[3] (RW)
 *
 * Allows selection of the polarity of the analog comparator function. It is
 * also driven to the COUT output, on both the device pin and as SCR[COUT], when
 * OPE=0.
 *
 * Values:
 * - 0 - Does not invert the comparator output.
 * - 1 - Inverts the comparator output.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_INV field. */
#define CMP_RD_CR1_INV(base) ((CMP_CR1_REG(base) & CMP_CR1_INV_MASK) >> CMP_CR1_INV_SHIFT)
#define CMP_BRD_CR1_INV(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_INV_SHIFT, CMP_CR1_INV_WIDTH))

/*! @brief Set the INV field to a new value. */
#define CMP_WR_CR1_INV(base, value) (CMP_RMW_CR1(base, CMP_CR1_INV_MASK, CMP_CR1_INV(value)))
#define CMP_BWR_CR1_INV(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_INV_SHIFT), CMP_CR1_INV_SHIFT, CMP_CR1_INV_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field PMODE[4] (RW)
 *
 * See the electrical specifications table in the device Data Sheet for details.
 *
 * Values:
 * - 0 - Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower
 *     output propagation delay and lower current consumption.
 * - 1 - High-Speed (HS) Comparison mode selected. In this mode, CMP has faster
 *     output propagation delay and higher current consumption.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_PMODE field. */
#define CMP_RD_CR1_PMODE(base) ((CMP_CR1_REG(base) & CMP_CR1_PMODE_MASK) >> CMP_CR1_PMODE_SHIFT)
#define CMP_BRD_CR1_PMODE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_PMODE_SHIFT, CMP_CR1_PMODE_WIDTH))

/*! @brief Set the PMODE field to a new value. */
#define CMP_WR_CR1_PMODE(base, value) (CMP_RMW_CR1(base, CMP_CR1_PMODE_MASK, CMP_CR1_PMODE(value)))
#define CMP_BWR_CR1_PMODE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_PMODE_SHIFT), CMP_CR1_PMODE_SHIFT, CMP_CR1_PMODE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field TRIGM[5] (RW)
 *
 * CMP and DAC are configured to CMP Trigger mode when CMP_CR1[TRIGM] is set to
 * 1. In addition, the CMP should be enabled. If the DAC is to be used as a
 * reference to the CMP, it should also be enabled. CMP Trigger mode depends on an
 * external timer resource to periodically enable the CMP and 6-bit DAC in order to
 * generate a triggered compare. Upon setting TRIGM, the CMP and DAC are placed
 * in a standby state until an external timer resource trigger is received. See
 * the chip configuration for details about the external timer resource.
 *
 * Values:
 * - 0 - Trigger mode is disabled.
 * - 1 - Trigger mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_TRIGM field. */
#define CMP_RD_CR1_TRIGM(base) ((CMP_CR1_REG(base) & CMP_CR1_TRIGM_MASK) >> CMP_CR1_TRIGM_SHIFT)
#define CMP_BRD_CR1_TRIGM(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_TRIGM_SHIFT, CMP_CR1_TRIGM_WIDTH))

/*! @brief Set the TRIGM field to a new value. */
#define CMP_WR_CR1_TRIGM(base, value) (CMP_RMW_CR1(base, CMP_CR1_TRIGM_MASK, CMP_CR1_TRIGM(value)))
#define CMP_BWR_CR1_TRIGM(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_TRIGM_SHIFT), CMP_CR1_TRIGM_SHIFT, CMP_CR1_TRIGM_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field WE[6] (RW)
 *
 * At any given time, either SE or WE can be set. It is mandatory request to not
 * set SE and WE both at a given time.
 *
 * Values:
 * - 0 - Windowing mode is not selected.
 * - 1 - Windowing mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_WE field. */
#define CMP_RD_CR1_WE(base)  ((CMP_CR1_REG(base) & CMP_CR1_WE_MASK) >> CMP_CR1_WE_SHIFT)
#define CMP_BRD_CR1_WE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_WE_SHIFT, CMP_CR1_WE_WIDTH))

/*! @brief Set the WE field to a new value. */
#define CMP_WR_CR1_WE(base, value) (CMP_RMW_CR1(base, CMP_CR1_WE_MASK, CMP_CR1_WE(value)))
#define CMP_BWR_CR1_WE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_WE_SHIFT), CMP_CR1_WE_SHIFT, CMP_CR1_WE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field SE[7] (RW)
 *
 * At any given time, either SE or WE can be set. It is mandatory request to not
 * set SE and WE both at a given time.
 *
 * Values:
 * - 0 - Sampling mode is not selected.
 * - 1 - Sampling mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_SE field. */
#define CMP_RD_CR1_SE(base)  ((CMP_CR1_REG(base) & CMP_CR1_SE_MASK) >> CMP_CR1_SE_SHIFT)
#define CMP_BRD_CR1_SE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_SE_SHIFT, CMP_CR1_SE_WIDTH))

/*! @brief Set the SE field to a new value. */
#define CMP_WR_CR1_SE(base, value) (CMP_RMW_CR1(base, CMP_CR1_SE_MASK, CMP_CR1_SE(value)))
#define CMP_BWR_CR1_SE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_SE_SHIFT), CMP_CR1_SE_SHIFT, CMP_CR1_SE_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_FPR - CMP Filter Period Register
 ******************************************************************************/

/*!
 * @brief CMP_FPR - CMP Filter Period Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_FPR register
 */
/*@{*/
#define CMP_RD_FPR(base)         (CMP_FPR_REG(base))
#define CMP_WR_FPR(base, value)  (CMP_FPR_REG(base) = (value))
#define CMP_RMW_FPR(base, mask, value) (CMP_WR_FPR(base, (CMP_RD_FPR(base) & ~(mask)) | (value)))
#define CMP_SET_FPR(base, value) (BME_OR8(&CMP_FPR_REG(base), (uint8_t)(value)))
#define CMP_CLR_FPR(base, value) (BME_AND8(&CMP_FPR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_FPR(base, value) (BME_XOR8(&CMP_FPR_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMP_SCR - CMP Status and Control Register
 ******************************************************************************/

/*!
 * @brief CMP_SCR - CMP Status and Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_SCR register
 */
/*@{*/
#define CMP_RD_SCR(base)         (CMP_SCR_REG(base))
#define CMP_WR_SCR(base, value)  (CMP_SCR_REG(base) = (value))
#define CMP_RMW_SCR(base, mask, value) (CMP_WR_SCR(base, (CMP_RD_SCR(base) & ~(mask)) | (value)))
#define CMP_SET_SCR(base, value) (BME_OR8(&CMP_SCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_SCR(base, value) (BME_AND8(&CMP_SCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_SCR(base, value) (BME_XOR8(&CMP_SCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_SCR bitfields
 */

/*!
 * @name Register CMP_SCR, field COUT[0] (RO)
 *
 * Returns the current value of the Analog Comparator output, when read. The
 * field is reset to 0 and will read as CR1[INV] when the Analog Comparator module
 * is disabled, that is, when CR1[EN] = 0. Writes to this field are ignored.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_COUT field. */
#define CMP_RD_SCR_COUT(base) ((CMP_SCR_REG(base) & CMP_SCR_COUT_MASK) >> CMP_SCR_COUT_SHIFT)
#define CMP_BRD_SCR_COUT(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_COUT_SHIFT, CMP_SCR_COUT_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFF[1] (W1C)
 *
 * Detects a falling-edge on COUT, when set, during normal operation. CFF is
 * cleared by writing 1 to it. During Stop modes, CFF is edge sensitive .
 *
 * Values:
 * - 0 - Falling-edge on COUT has not been detected.
 * - 1 - Falling-edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFF field. */
#define CMP_RD_SCR_CFF(base) ((CMP_SCR_REG(base) & CMP_SCR_CFF_MASK) >> CMP_SCR_CFF_SHIFT)
#define CMP_BRD_SCR_CFF(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_CFF_SHIFT, CMP_SCR_CFF_WIDTH))

/*! @brief Set the CFF field to a new value. */
#define CMP_WR_SCR_CFF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_CFF(value)))
#define CMP_BWR_SCR_CFF(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_CFF_SHIFT), CMP_SCR_CFF_SHIFT, CMP_SCR_CFF_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFR[2] (W1C)
 *
 * Detects a rising-edge on COUT, when set, during normal operation. CFR is
 * cleared by writing 1 to it. During Stop modes, CFR is edge sensitive .
 *
 * Values:
 * - 0 - Rising-edge on COUT has not been detected.
 * - 1 - Rising-edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFR field. */
#define CMP_RD_SCR_CFR(base) ((CMP_SCR_REG(base) & CMP_SCR_CFR_MASK) >> CMP_SCR_CFR_SHIFT)
#define CMP_BRD_SCR_CFR(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_CFR_SHIFT, CMP_SCR_CFR_WIDTH))

/*! @brief Set the CFR field to a new value. */
#define CMP_WR_SCR_CFR(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFR_MASK | CMP_SCR_CFF_MASK), CMP_SCR_CFR(value)))
#define CMP_BWR_SCR_CFR(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_CFR_SHIFT), CMP_SCR_CFR_SHIFT, CMP_SCR_CFR_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field IEF[3] (RW)
 *
 * Enables the CFF interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFF is set.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IEF field. */
#define CMP_RD_SCR_IEF(base) ((CMP_SCR_REG(base) & CMP_SCR_IEF_MASK) >> CMP_SCR_IEF_SHIFT)
#define CMP_BRD_SCR_IEF(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_IEF_SHIFT, CMP_SCR_IEF_WIDTH))

/*! @brief Set the IEF field to a new value. */
#define CMP_WR_SCR_IEF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IEF_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IEF(value)))
#define CMP_BWR_SCR_IEF(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_IEF_SHIFT), CMP_SCR_IEF_SHIFT, CMP_SCR_IEF_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field IER[4] (RW)
 *
 * Enables the CFR interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFR is set.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IER field. */
#define CMP_RD_SCR_IER(base) ((CMP_SCR_REG(base) & CMP_SCR_IER_MASK) >> CMP_SCR_IER_SHIFT)
#define CMP_BRD_SCR_IER(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_IER_SHIFT, CMP_SCR_IER_WIDTH))

/*! @brief Set the IER field to a new value. */
#define CMP_WR_SCR_IER(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IER_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IER(value)))
#define CMP_BWR_SCR_IER(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_IER_SHIFT), CMP_SCR_IER_SHIFT, CMP_SCR_IER_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field DMAEN[6] (RW)
 *
 * Enables the DMA transfer triggered from the CMP module. When this field is
 * set, a DMA request is asserted when CFR or CFF is set.
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_DMAEN field. */
#define CMP_RD_SCR_DMAEN(base) ((CMP_SCR_REG(base) & CMP_SCR_DMAEN_MASK) >> CMP_SCR_DMAEN_SHIFT)
#define CMP_BRD_SCR_DMAEN(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_DMAEN_SHIFT, CMP_SCR_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define CMP_WR_SCR_DMAEN(base, value) (CMP_RMW_SCR(base, (CMP_SCR_DMAEN_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_DMAEN(value)))
#define CMP_BWR_SCR_DMAEN(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_DMAEN_SHIFT), CMP_SCR_DMAEN_SHIFT, CMP_SCR_DMAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_DACCR - DAC Control Register
 ******************************************************************************/

/*!
 * @brief CMP_DACCR - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_DACCR register
 */
/*@{*/
#define CMP_RD_DACCR(base)       (CMP_DACCR_REG(base))
#define CMP_WR_DACCR(base, value) (CMP_DACCR_REG(base) = (value))
#define CMP_RMW_DACCR(base, mask, value) (CMP_WR_DACCR(base, (CMP_RD_DACCR(base) & ~(mask)) | (value)))
#define CMP_SET_DACCR(base, value) (BME_OR8(&CMP_DACCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_DACCR(base, value) (BME_AND8(&CMP_DACCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_DACCR(base, value) (BME_XOR8(&CMP_DACCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_DACCR bitfields
 */

/*!
 * @name Register CMP_DACCR, field VOSEL[5:0] (RW)
 *
 * Selects an output voltage from one of 64 distinct levels. DACO = (V in /64) *
 * (VOSEL[5:0] + 1) , so the DACO range is from V in /64 to V in .
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VOSEL field. */
#define CMP_RD_DACCR_VOSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VOSEL_MASK) >> CMP_DACCR_VOSEL_SHIFT)
#define CMP_BRD_DACCR_VOSEL(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_VOSEL_SHIFT, CMP_DACCR_VOSEL_WIDTH))

/*! @brief Set the VOSEL field to a new value. */
#define CMP_WR_DACCR_VOSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VOSEL_MASK, CMP_DACCR_VOSEL(value)))
#define CMP_BWR_DACCR_VOSEL(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_VOSEL_SHIFT), CMP_DACCR_VOSEL_SHIFT, CMP_DACCR_VOSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_DACCR, field VRSEL[6] (RW)
 *
 * Values:
 * - 0 - Vin1 is selected as resistor ladder network supply reference.
 * - 1 - Vin2 is selected as resistor ladder network supply reference.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VRSEL field. */
#define CMP_RD_DACCR_VRSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VRSEL_MASK) >> CMP_DACCR_VRSEL_SHIFT)
#define CMP_BRD_DACCR_VRSEL(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_VRSEL_SHIFT, CMP_DACCR_VRSEL_WIDTH))

/*! @brief Set the VRSEL field to a new value. */
#define CMP_WR_DACCR_VRSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VRSEL_MASK, CMP_DACCR_VRSEL(value)))
#define CMP_BWR_DACCR_VRSEL(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_VRSEL_SHIFT), CMP_DACCR_VRSEL_SHIFT, CMP_DACCR_VRSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_DACCR, field DACEN[7] (RW)
 *
 * Enables the DAC. When the DAC is disabled, it is powered down to conserve
 * power.
 *
 * Values:
 * - 0 - DAC is disabled.
 * - 1 - DAC is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_DACEN field. */
#define CMP_RD_DACCR_DACEN(base) ((CMP_DACCR_REG(base) & CMP_DACCR_DACEN_MASK) >> CMP_DACCR_DACEN_SHIFT)
#define CMP_BRD_DACCR_DACEN(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_DACEN_SHIFT, CMP_DACCR_DACEN_WIDTH))

/*! @brief Set the DACEN field to a new value. */
#define CMP_WR_DACCR_DACEN(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_DACEN_MASK, CMP_DACCR_DACEN(value)))
#define CMP_BWR_DACCR_DACEN(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_DACEN_SHIFT), CMP_DACCR_DACEN_SHIFT, CMP_DACCR_DACEN_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_MUXCR - MUX Control Register
 ******************************************************************************/

/*!
 * @brief CMP_MUXCR - MUX Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_MUXCR register
 */
/*@{*/
#define CMP_RD_MUXCR(base)       (CMP_MUXCR_REG(base))
#define CMP_WR_MUXCR(base, value) (CMP_MUXCR_REG(base) = (value))
#define CMP_RMW_MUXCR(base, mask, value) (CMP_WR_MUXCR(base, (CMP_RD_MUXCR(base) & ~(mask)) | (value)))
#define CMP_SET_MUXCR(base, value) (BME_OR8(&CMP_MUXCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_MUXCR(base, value) (BME_AND8(&CMP_MUXCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_MUXCR(base, value) (BME_XOR8(&CMP_MUXCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_MUXCR bitfields
 */

/*!
 * @name Register CMP_MUXCR, field MSEL[2:0] (RW)
 *
 * Determines which input is selected for the minus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 000 - IN0
 * - 001 - IN1
 * - 010 - IN2
 * - 011 - IN3
 * - 100 - IN4
 * - 101 - IN5
 * - 110 - IN6
 * - 111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_MSEL field. */
#define CMP_RD_MUXCR_MSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_MSEL_MASK) >> CMP_MUXCR_MSEL_SHIFT)
#define CMP_BRD_MUXCR_MSEL(base) (BME_UBFX8(&CMP_MUXCR_REG(base), CMP_MUXCR_MSEL_SHIFT, CMP_MUXCR_MSEL_WIDTH))

/*! @brief Set the MSEL field to a new value. */
#define CMP_WR_MUXCR_MSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_MSEL_MASK, CMP_MUXCR_MSEL(value)))
#define CMP_BWR_MUXCR_MSEL(base, value) (BME_BFI8(&CMP_MUXCR_REG(base), ((uint8_t)(value) << CMP_MUXCR_MSEL_SHIFT), CMP_MUXCR_MSEL_SHIFT, CMP_MUXCR_MSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSEL[5:3] (RW)
 *
 * Determines which input is selected for the plus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 000 - IN0
 * - 001 - IN1
 * - 010 - IN2
 * - 011 - IN3
 * - 100 - IN4
 * - 101 - IN5
 * - 110 - IN6
 * - 111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_PSEL field. */
#define CMP_RD_MUXCR_PSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_PSEL_MASK) >> CMP_MUXCR_PSEL_SHIFT)
#define CMP_BRD_MUXCR_PSEL(base) (BME_UBFX8(&CMP_MUXCR_REG(base), CMP_MUXCR_PSEL_SHIFT, CMP_MUXCR_PSEL_WIDTH))

/*! @brief Set the PSEL field to a new value. */
#define CMP_WR_MUXCR_PSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_PSEL_MASK, CMP_MUXCR_PSEL(value)))
#define CMP_BWR_MUXCR_PSEL(base, value) (BME_BFI8(&CMP_MUXCR_REG(base), ((uint8_t)(value) << CMP_MUXCR_PSEL_SHIFT), CMP_MUXCR_PSEL_SHIFT, CMP_MUXCR_PSEL_WIDTH))
/*@}*/

/*
 * MKV10Z7 CRC
 *
 * Cyclic Redundancy Check
 *
 * Registers defined in this header file:
 * - CRC_DATAL - CRC_DATAL register.
 * - CRC_DATAH - CRC_DATAH register.
 * - CRC_DATALL - CRC_DATALL register.
 * - CRC_DATALU - CRC_DATALU register.
 * - CRC_DATAHL - CRC_DATAHL register.
 * - CRC_DATAHU - CRC_DATAHU register.
 * - CRC_DATA - CRC Data register
 * - CRC_GPOLY - CRC Polynomial register
 * - CRC_GPOLYL - CRC_GPOLYL register.
 * - CRC_GPOLYH - CRC_GPOLYH register.
 * - CRC_GPOLYLL - CRC_GPOLYLL register.
 * - CRC_GPOLYLU - CRC_GPOLYLU register.
 * - CRC_GPOLYHL - CRC_GPOLYHL register.
 * - CRC_GPOLYHU - CRC_GPOLYHU register.
 * - CRC_CTRL - CRC Control register
 * - CRC_CTRLHU - CRC_CTRLHU register.
 */

#define CRC_INSTANCE_COUNT (1U) /*!< Number of instances of the CRC module. */
#define CRC_IDX (0U) /*!< Instance number for CRC. */

/*******************************************************************************
 * CRC_DATALL - CRC_DATALL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATALL - CRC_DATALL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATALL register
 */
/*@{*/
#define CRC_RD_DATALL(base)      (CRC_DATALL_REG(base))
#define CRC_WR_DATALL(base, value) (CRC_DATALL_REG(base) = (value))
#define CRC_RMW_DATALL(base, mask, value) (CRC_WR_DATALL(base, (CRC_RD_DATALL(base) & ~(mask)) | (value)))
#define CRC_SET_DATALL(base, value) (BME_OR8(&CRC_DATALL_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATALL(base, value) (BME_AND8(&CRC_DATALL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATALL(base, value) (BME_XOR8(&CRC_DATALL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAL - CRC_DATAL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAL - CRC_DATAL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAL register
 */
/*@{*/
#define CRC_RD_DATAL(base)       (CRC_DATAL_REG(base))
#define CRC_WR_DATAL(base, value) (CRC_DATAL_REG(base) = (value))
#define CRC_RMW_DATAL(base, mask, value) (CRC_WR_DATAL(base, (CRC_RD_DATAL(base) & ~(mask)) | (value)))
#define CRC_SET_DATAL(base, value) (BME_OR16(&CRC_DATAL_REG(base), (uint16_t)(value)))
#define CRC_CLR_DATAL(base, value) (BME_AND16(&CRC_DATAL_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_DATAL(base, value) (BME_XOR16(&CRC_DATAL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATA - CRC Data register
 ******************************************************************************/

/*!
 * @brief CRC_DATA - CRC Data register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * The CRC Data register contains the value of the seed, data, and checksum.
 * When CTRL[WAS] is set, any write to the data register is regarded as the seed
 * value. When CTRL[WAS] is cleared, any write to the data register is regarded as
 * data for general CRC computation. In 16-bit CRC mode, the HU and HL fields are
 * not used for programming the seed value, and reads of these fields return an
 * indeterminate value. In 32-bit CRC mode, all fields are used for programming
 * the seed value. When programming data values, the values can be written 8 bits,
 * 16 bits, or 32 bits at a time, provided all bytes are contiguous; with MSB of
 * data value written first. After all data values are written, the CRC result
 * can be read from this data register. In 16-bit CRC mode, the CRC result is
 * available in the LU and LL fields. In 32-bit CRC mode, all fields contain the
 * result. Reads of this register at any time return the intermediate CRC value,
 * provided the CRC module is configured.
 */
/*!
 * @name Constants and macros for entire CRC_DATA register
 */
/*@{*/
#define CRC_RD_DATA(base)        (CRC_DATA_REG(base))
#define CRC_WR_DATA(base, value) (CRC_DATA_REG(base) = (value))
#define CRC_RMW_DATA(base, mask, value) (CRC_WR_DATA(base, (CRC_RD_DATA(base) & ~(mask)) | (value)))
#define CRC_SET_DATA(base, value) (BME_OR32(&CRC_DATA_REG(base), (uint32_t)(value)))
#define CRC_CLR_DATA(base, value) (BME_AND32(&CRC_DATA_REG(base), (uint32_t)(~(value))))
#define CRC_TOG_DATA(base, value) (BME_XOR32(&CRC_DATA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATA bitfields
 */

/*!
 * @name Register CRC_DATA, field LL[7:0] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_LL field. */
#define CRC_RD_DATA_LL(base) ((CRC_DATA_REG(base) & CRC_DATA_LL_MASK) >> CRC_DATA_LL_SHIFT)
#define CRC_BRD_DATA_LL(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_LL_SHIFT, CRC_DATA_LL_WIDTH))

/*! @brief Set the LL field to a new value. */
#define CRC_WR_DATA_LL(base, value) (CRC_RMW_DATA(base, CRC_DATA_LL_MASK, CRC_DATA_LL(value)))
#define CRC_BWR_DATA_LL(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_LL_SHIFT), CRC_DATA_LL_SHIFT, CRC_DATA_LL_WIDTH))
/*@}*/

/*!
 * @name Register CRC_DATA, field LU[15:8] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_LU field. */
#define CRC_RD_DATA_LU(base) ((CRC_DATA_REG(base) & CRC_DATA_LU_MASK) >> CRC_DATA_LU_SHIFT)
#define CRC_BRD_DATA_LU(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_LU_SHIFT, CRC_DATA_LU_WIDTH))

/*! @brief Set the LU field to a new value. */
#define CRC_WR_DATA_LU(base, value) (CRC_RMW_DATA(base, CRC_DATA_LU_MASK, CRC_DATA_LU(value)))
#define CRC_BWR_DATA_LU(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_LU_SHIFT), CRC_DATA_LU_SHIFT, CRC_DATA_LU_WIDTH))
/*@}*/

/*!
 * @name Register CRC_DATA, field HL[23:16] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_HL field. */
#define CRC_RD_DATA_HL(base) ((CRC_DATA_REG(base) & CRC_DATA_HL_MASK) >> CRC_DATA_HL_SHIFT)
#define CRC_BRD_DATA_HL(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_HL_SHIFT, CRC_DATA_HL_WIDTH))

/*! @brief Set the HL field to a new value. */
#define CRC_WR_DATA_HL(base, value) (CRC_RMW_DATA(base, CRC_DATA_HL_MASK, CRC_DATA_HL(value)))
#define CRC_BWR_DATA_HL(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_HL_SHIFT), CRC_DATA_HL_SHIFT, CRC_DATA_HL_WIDTH))
/*@}*/

/*!
 * @name Register CRC_DATA, field HU[31:24] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_HU field. */
#define CRC_RD_DATA_HU(base) ((CRC_DATA_REG(base) & CRC_DATA_HU_MASK) >> CRC_DATA_HU_SHIFT)
#define CRC_BRD_DATA_HU(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_HU_SHIFT, CRC_DATA_HU_WIDTH))

/*! @brief Set the HU field to a new value. */
#define CRC_WR_DATA_HU(base, value) (CRC_RMW_DATA(base, CRC_DATA_HU_MASK, CRC_DATA_HU(value)))
#define CRC_BWR_DATA_HU(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_HU_SHIFT), CRC_DATA_HU_SHIFT, CRC_DATA_HU_WIDTH))
/*@}*/

/*******************************************************************************
 * CRC_DATALU - CRC_DATALU register.
 ******************************************************************************/

/*!
 * @brief CRC_DATALU - CRC_DATALU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATALU register
 */
/*@{*/
#define CRC_RD_DATALU(base)      (CRC_DATALU_REG(base))
#define CRC_WR_DATALU(base, value) (CRC_DATALU_REG(base) = (value))
#define CRC_RMW_DATALU(base, mask, value) (CRC_WR_DATALU(base, (CRC_RD_DATALU(base) & ~(mask)) | (value)))
#define CRC_SET_DATALU(base, value) (BME_OR8(&CRC_DATALU_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATALU(base, value) (BME_AND8(&CRC_DATALU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATALU(base, value) (BME_XOR8(&CRC_DATALU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAHL - CRC_DATAHL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAHL - CRC_DATAHL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAHL register
 */
/*@{*/
#define CRC_RD_DATAHL(base)      (CRC_DATAHL_REG(base))
#define CRC_WR_DATAHL(base, value) (CRC_DATAHL_REG(base) = (value))
#define CRC_RMW_DATAHL(base, mask, value) (CRC_WR_DATAHL(base, (CRC_RD_DATAHL(base) & ~(mask)) | (value)))
#define CRC_SET_DATAHL(base, value) (BME_OR8(&CRC_DATAHL_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATAHL(base, value) (BME_AND8(&CRC_DATAHL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATAHL(base, value) (BME_XOR8(&CRC_DATAHL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAH - CRC_DATAH register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAH - CRC_DATAH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAH register
 */
/*@{*/
#define CRC_RD_DATAH(base)       (CRC_DATAH_REG(base))
#define CRC_WR_DATAH(base, value) (CRC_DATAH_REG(base) = (value))
#define CRC_RMW_DATAH(base, mask, value) (CRC_WR_DATAH(base, (CRC_RD_DATAH(base) & ~(mask)) | (value)))
#define CRC_SET_DATAH(base, value) (BME_OR16(&CRC_DATAH_REG(base), (uint16_t)(value)))
#define CRC_CLR_DATAH(base, value) (BME_AND16(&CRC_DATAH_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_DATAH(base, value) (BME_XOR16(&CRC_DATAH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAHU - CRC_DATAHU register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAHU - CRC_DATAHU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAHU register
 */
/*@{*/
#define CRC_RD_DATAHU(base)      (CRC_DATAHU_REG(base))
#define CRC_WR_DATAHU(base, value) (CRC_DATAHU_REG(base) = (value))
#define CRC_RMW_DATAHU(base, mask, value) (CRC_WR_DATAHU(base, (CRC_RD_DATAHU(base) & ~(mask)) | (value)))
#define CRC_SET_DATAHU(base, value) (BME_OR8(&CRC_DATAHU_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATAHU(base, value) (BME_AND8(&CRC_DATAHU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATAHU(base, value) (BME_XOR8(&CRC_DATAHU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYLL - CRC_GPOLYLL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYLL - CRC_GPOLYLL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYLL register
 */
/*@{*/
#define CRC_RD_GPOLYLL(base)     (CRC_GPOLYLL_REG(base))
#define CRC_WR_GPOLYLL(base, value) (CRC_GPOLYLL_REG(base) = (value))
#define CRC_RMW_GPOLYLL(base, mask, value) (CRC_WR_GPOLYLL(base, (CRC_RD_GPOLYLL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYLL(base, value) (BME_OR8(&CRC_GPOLYLL_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYLL(base, value) (BME_AND8(&CRC_GPOLYLL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYLL(base, value) (BME_XOR8(&CRC_GPOLYLL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLY - CRC Polynomial register
 ******************************************************************************/

/*!
 * @brief CRC_GPOLY - CRC Polynomial register (RW)
 *
 * Reset value: 0x00001021U
 *
 * This register contains the value of the polynomial for the CRC calculation.
 * The HIGH field contains the upper 16 bits of the CRC polynomial, which are used
 * only in 32-bit CRC mode. Writes to the HIGH field are ignored in 16-bit CRC
 * mode. The LOW field contains the lower 16 bits of the CRC polynomial, which are
 * used in both 16- and 32-bit CRC modes.
 */
/*!
 * @name Constants and macros for entire CRC_GPOLY register
 */
/*@{*/
#define CRC_RD_GPOLY(base)       (CRC_GPOLY_REG(base))
#define CRC_WR_GPOLY(base, value) (CRC_GPOLY_REG(base) = (value))
#define CRC_RMW_GPOLY(base, mask, value) (CRC_WR_GPOLY(base, (CRC_RD_GPOLY(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLY(base, value) (BME_OR32(&CRC_GPOLY_REG(base), (uint32_t)(value)))
#define CRC_CLR_GPOLY(base, value) (BME_AND32(&CRC_GPOLY_REG(base), (uint32_t)(~(value))))
#define CRC_TOG_GPOLY(base, value) (BME_XOR32(&CRC_GPOLY_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLY bitfields
 */

/*!
 * @name Register CRC_GPOLY, field LOW[15:0] (RW)
 *
 * Writable and readable in both 32-bit and 16-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_LOW field. */
#define CRC_RD_GPOLY_LOW(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_LOW_MASK) >> CRC_GPOLY_LOW_SHIFT)
#define CRC_BRD_GPOLY_LOW(base) (BME_UBFX32(&CRC_GPOLY_REG(base), CRC_GPOLY_LOW_SHIFT, CRC_GPOLY_LOW_WIDTH))

/*! @brief Set the LOW field to a new value. */
#define CRC_WR_GPOLY_LOW(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_LOW_MASK, CRC_GPOLY_LOW(value)))
#define CRC_BWR_GPOLY_LOW(base, value) (BME_BFI32(&CRC_GPOLY_REG(base), ((uint32_t)(value) << CRC_GPOLY_LOW_SHIFT), CRC_GPOLY_LOW_SHIFT, CRC_GPOLY_LOW_WIDTH))
/*@}*/

/*!
 * @name Register CRC_GPOLY, field HIGH[31:16] (RW)
 *
 * Writable and readable in 32-bit CRC mode (CTRL[TCRC] is 1). This field is not
 * writable in 16-bit CRC mode (CTRL[TCRC] is 0).
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_HIGH field. */
#define CRC_RD_GPOLY_HIGH(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_HIGH_MASK) >> CRC_GPOLY_HIGH_SHIFT)
#define CRC_BRD_GPOLY_HIGH(base) (BME_UBFX32(&CRC_GPOLY_REG(base), CRC_GPOLY_HIGH_SHIFT, CRC_GPOLY_HIGH_WIDTH))

/*! @brief Set the HIGH field to a new value. */
#define CRC_WR_GPOLY_HIGH(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_HIGH_MASK, CRC_GPOLY_HIGH(value)))
#define CRC_BWR_GPOLY_HIGH(base, value) (BME_BFI32(&CRC_GPOLY_REG(base), ((uint32_t)(value) << CRC_GPOLY_HIGH_SHIFT), CRC_GPOLY_HIGH_SHIFT, CRC_GPOLY_HIGH_WIDTH))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYL - CRC_GPOLYL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYL - CRC_GPOLYL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYL register
 */
/*@{*/
#define CRC_RD_GPOLYL(base)      (CRC_GPOLYL_REG(base))
#define CRC_WR_GPOLYL(base, value) (CRC_GPOLYL_REG(base) = (value))
#define CRC_RMW_GPOLYL(base, mask, value) (CRC_WR_GPOLYL(base, (CRC_RD_GPOLYL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYL(base, value) (BME_OR16(&CRC_GPOLYL_REG(base), (uint16_t)(value)))
#define CRC_CLR_GPOLYL(base, value) (BME_AND16(&CRC_GPOLYL_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_GPOLYL(base, value) (BME_XOR16(&CRC_GPOLYL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYLU - CRC_GPOLYLU register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYLU - CRC_GPOLYLU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYLU register
 */
/*@{*/
#define CRC_RD_GPOLYLU(base)     (CRC_GPOLYLU_REG(base))
#define CRC_WR_GPOLYLU(base, value) (CRC_GPOLYLU_REG(base) = (value))
#define CRC_RMW_GPOLYLU(base, mask, value) (CRC_WR_GPOLYLU(base, (CRC_RD_GPOLYLU(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYLU(base, value) (BME_OR8(&CRC_GPOLYLU_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYLU(base, value) (BME_AND8(&CRC_GPOLYLU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYLU(base, value) (BME_XOR8(&CRC_GPOLYLU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYH - CRC_GPOLYH register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYH - CRC_GPOLYH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYH register
 */
/*@{*/
#define CRC_RD_GPOLYH(base)      (CRC_GPOLYH_REG(base))
#define CRC_WR_GPOLYH(base, value) (CRC_GPOLYH_REG(base) = (value))
#define CRC_RMW_GPOLYH(base, mask, value) (CRC_WR_GPOLYH(base, (CRC_RD_GPOLYH(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYH(base, value) (BME_OR16(&CRC_GPOLYH_REG(base), (uint16_t)(value)))
#define CRC_CLR_GPOLYH(base, value) (BME_AND16(&CRC_GPOLYH_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_GPOLYH(base, value) (BME_XOR16(&CRC_GPOLYH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYHL - CRC_GPOLYHL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYHL - CRC_GPOLYHL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYHL register
 */
/*@{*/
#define CRC_RD_GPOLYHL(base)     (CRC_GPOLYHL_REG(base))
#define CRC_WR_GPOLYHL(base, value) (CRC_GPOLYHL_REG(base) = (value))
#define CRC_RMW_GPOLYHL(base, mask, value) (CRC_WR_GPOLYHL(base, (CRC_RD_GPOLYHL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYHL(base, value) (BME_OR8(&CRC_GPOLYHL_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYHL(base, value) (BME_AND8(&CRC_GPOLYHL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYHL(base, value) (BME_XOR8(&CRC_GPOLYHL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYHU - CRC_GPOLYHU register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYHU - CRC_GPOLYHU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYHU register
 */
/*@{*/
#define CRC_RD_GPOLYHU(base)     (CRC_GPOLYHU_REG(base))
#define CRC_WR_GPOLYHU(base, value) (CRC_GPOLYHU_REG(base) = (value))
#define CRC_RMW_GPOLYHU(base, mask, value) (CRC_WR_GPOLYHU(base, (CRC_RD_GPOLYHU(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYHU(base, value) (BME_OR8(&CRC_GPOLYHU_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYHU(base, value) (BME_AND8(&CRC_GPOLYHU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYHU(base, value) (BME_XOR8(&CRC_GPOLYHU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_CTRL - CRC Control register
 ******************************************************************************/

/*!
 * @brief CRC_CTRL - CRC Control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the configuration and working of the CRC module.
 * Appropriate bits must be set before starting a new CRC calculation. A new CRC
 * calculation is initialized by asserting CTRL[WAS] and then writing the seed into
 * the CRC data register.
 */
/*!
 * @name Constants and macros for entire CRC_CTRL register
 */
/*@{*/
#define CRC_RD_CTRL(base)        (CRC_CTRL_REG(base))
#define CRC_WR_CTRL(base, value) (CRC_CTRL_REG(base) = (value))
#define CRC_RMW_CTRL(base, mask, value) (CRC_WR_CTRL(base, (CRC_RD_CTRL(base) & ~(mask)) | (value)))
#define CRC_SET_CTRL(base, value) (BME_OR32(&CRC_CTRL_REG(base), (uint32_t)(value)))
#define CRC_CLR_CTRL(base, value) (BME_AND32(&CRC_CTRL_REG(base), (uint32_t)(~(value))))
#define CRC_TOG_CTRL(base, value) (BME_XOR32(&CRC_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRL bitfields
 */

/*!
 * @name Register CRC_CTRL, field TCRC[24] (RW)
 *
 * Width of CRC protocol.
 *
 * Values:
 * - 0 - 16-bit CRC protocol.
 * - 1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TCRC field. */
#define CRC_RD_CTRL_TCRC(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TCRC_MASK) >> CRC_CTRL_TCRC_SHIFT)
#define CRC_BRD_CTRL_TCRC(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_TCRC_SHIFT, CRC_CTRL_TCRC_WIDTH))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRL_TCRC(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TCRC_MASK, CRC_CTRL_TCRC(value)))
#define CRC_BWR_CTRL_TCRC(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_TCRC_SHIFT), CRC_CTRL_TCRC_SHIFT, CRC_CTRL_TCRC_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field WAS[25] (RW)
 *
 * When asserted, a value written to the CRC data register is considered a seed
 * value. When deasserted, a value written to the CRC data register is taken as
 * data for CRC computation.
 *
 * Values:
 * - 0 - Writes to the CRC data register are data values.
 * - 1 - Writes to the CRC data register are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_WAS field. */
#define CRC_RD_CTRL_WAS(base) ((CRC_CTRL_REG(base) & CRC_CTRL_WAS_MASK) >> CRC_CTRL_WAS_SHIFT)
#define CRC_BRD_CTRL_WAS(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_WAS_SHIFT, CRC_CTRL_WAS_WIDTH))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRL_WAS(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_WAS_MASK, CRC_CTRL_WAS(value)))
#define CRC_BWR_CTRL_WAS(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_WAS_SHIFT), CRC_CTRL_WAS_SHIFT, CRC_CTRL_WAS_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field FXOR[26] (RW)
 *
 * Some CRC protocols require the final checksum to be XORed with 0xFFFFFFFF or
 * 0xFFFF. Asserting this bit enables on the fly complementing of read data.
 *
 * Values:
 * - 0 - No XOR on reading.
 * - 1 - Invert or complement the read value of the CRC Data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_FXOR field. */
#define CRC_RD_CTRL_FXOR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_FXOR_MASK) >> CRC_CTRL_FXOR_SHIFT)
#define CRC_BRD_CTRL_FXOR(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_FXOR_SHIFT, CRC_CTRL_FXOR_WIDTH))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRL_FXOR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_FXOR_MASK, CRC_CTRL_FXOR(value)))
#define CRC_BWR_CTRL_FXOR(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_FXOR_SHIFT), CRC_CTRL_FXOR_SHIFT, CRC_CTRL_FXOR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOTR[29:28] (RW)
 *
 * Identifies the transpose configuration of the value read from the CRC Data
 * register. See the description of the transpose feature for the available
 * transpose options.
 *
 * Values:
 * - 00 - No transposition.
 * - 01 - Bits in bytes are transposed; bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOTR field. */
#define CRC_RD_CTRL_TOTR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOTR_MASK) >> CRC_CTRL_TOTR_SHIFT)
#define CRC_BRD_CTRL_TOTR(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_TOTR_SHIFT, CRC_CTRL_TOTR_WIDTH))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRL_TOTR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOTR_MASK, CRC_CTRL_TOTR(value)))
#define CRC_BWR_CTRL_TOTR(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_TOTR_SHIFT), CRC_CTRL_TOTR_SHIFT, CRC_CTRL_TOTR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOT[31:30] (RW)
 *
 * Defines the transpose configuration of the data written to the CRC data
 * register. See the description of the transpose feature for the available transpose
 * options.
 *
 * Values:
 * - 00 - No transposition.
 * - 01 - Bits in bytes are transposed; bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOT field. */
#define CRC_RD_CTRL_TOT(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOT_MASK) >> CRC_CTRL_TOT_SHIFT)
#define CRC_BRD_CTRL_TOT(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_TOT_SHIFT, CRC_CTRL_TOT_WIDTH))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRL_TOT(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOT_MASK, CRC_CTRL_TOT(value)))
#define CRC_BWR_CTRL_TOT(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_TOT_SHIFT), CRC_CTRL_TOT_SHIFT, CRC_CTRL_TOT_WIDTH))
/*@}*/

/*******************************************************************************
 * CRC_CTRLHU - CRC_CTRLHU register.
 ******************************************************************************/

/*!
 * @brief CRC_CTRLHU - CRC_CTRLHU register. (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CRC_CTRLHU register
 */
/*@{*/
#define CRC_RD_CTRLHU(base)      (CRC_CTRLHU_REG(base))
#define CRC_WR_CTRLHU(base, value) (CRC_CTRLHU_REG(base) = (value))
#define CRC_RMW_CTRLHU(base, mask, value) (CRC_WR_CTRLHU(base, (CRC_RD_CTRLHU(base) & ~(mask)) | (value)))
#define CRC_SET_CTRLHU(base, value) (BME_OR8(&CRC_CTRLHU_REG(base), (uint8_t)(value)))
#define CRC_CLR_CTRLHU(base, value) (BME_AND8(&CRC_CTRLHU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_CTRLHU(base, value) (BME_XOR8(&CRC_CTRLHU_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRLHU bitfields
 */

/*!
 * @name Register CRC_CTRLHU, field TCRC[0] (RW)
 *
 * Values:
 * - 0 - 16-bit CRC protocol.
 * - 1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TCRC field. */
#define CRC_RD_CTRLHU_TCRC(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TCRC_MASK) >> CRC_CTRLHU_TCRC_SHIFT)
#define CRC_BRD_CTRLHU_TCRC(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TCRC_SHIFT, CRC_CTRLHU_TCRC_WIDTH))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRLHU_TCRC(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TCRC_MASK, CRC_CTRLHU_TCRC(value)))
#define CRC_BWR_CTRLHU_TCRC(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_TCRC_SHIFT), CRC_CTRLHU_TCRC_SHIFT, CRC_CTRLHU_TCRC_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field WAS[1] (RW)
 *
 * Values:
 * - 0 - Writes to CRC data register are data values.
 * - 1 - Writes to CRC data reguster are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_WAS field. */
#define CRC_RD_CTRLHU_WAS(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_WAS_MASK) >> CRC_CTRLHU_WAS_SHIFT)
#define CRC_BRD_CTRLHU_WAS(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_WAS_SHIFT, CRC_CTRLHU_WAS_WIDTH))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRLHU_WAS(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_WAS_MASK, CRC_CTRLHU_WAS(value)))
#define CRC_BWR_CTRLHU_WAS(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_WAS_SHIFT), CRC_CTRLHU_WAS_SHIFT, CRC_CTRLHU_WAS_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field FXOR[2] (RW)
 *
 * Values:
 * - 0 - No XOR on reading.
 * - 1 - Invert or complement the read value of CRC data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_FXOR field. */
#define CRC_RD_CTRLHU_FXOR(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_FXOR_MASK) >> CRC_CTRLHU_FXOR_SHIFT)
#define CRC_BRD_CTRLHU_FXOR(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_FXOR_SHIFT, CRC_CTRLHU_FXOR_WIDTH))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRLHU_FXOR(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_FXOR_MASK, CRC_CTRLHU_FXOR(value)))
#define CRC_BWR_CTRLHU_FXOR(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_FXOR_SHIFT), CRC_CTRLHU_FXOR_SHIFT, CRC_CTRLHU_FXOR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOTR[5:4] (RW)
 *
 * Values:
 * - 00 - No Transposition.
 * - 01 - Bits in bytes are transposed, bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TOTR field. */
#define CRC_RD_CTRLHU_TOTR(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TOTR_MASK) >> CRC_CTRLHU_TOTR_SHIFT)
#define CRC_BRD_CTRLHU_TOTR(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TOTR_SHIFT, CRC_CTRLHU_TOTR_WIDTH))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRLHU_TOTR(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TOTR_MASK, CRC_CTRLHU_TOTR(value)))
#define CRC_BWR_CTRLHU_TOTR(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_TOTR_SHIFT), CRC_CTRLHU_TOTR_SHIFT, CRC_CTRLHU_TOTR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOT[7:6] (RW)
 *
 * Values:
 * - 00 - No Transposition.
 * - 01 - Bits in bytes are transposed, bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TOT field. */
#define CRC_RD_CTRLHU_TOT(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TOT_MASK) >> CRC_CTRLHU_TOT_SHIFT)
#define CRC_BRD_CTRLHU_TOT(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TOT_SHIFT, CRC_CTRLHU_TOT_WIDTH))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRLHU_TOT(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TOT_MASK, CRC_CTRLHU_TOT(value)))
#define CRC_BWR_CTRLHU_TOT(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_TOT_SHIFT), CRC_CTRLHU_TOT_SHIFT, CRC_CTRLHU_TOT_WIDTH))
/*@}*/

/*
 * MKV10Z7 DAC
 *
 * 12-Bit Digital-to-Analog Converter
 *
 * Registers defined in this header file:
 * - DAC_DATL - DAC Data Low Register
 * - DAC_DATH - DAC Data High Register
 * - DAC_SR - DAC Status Register
 * - DAC_C0 - DAC Control Register
 * - DAC_C1 - DAC Control Register 1
 * - DAC_C2 - DAC Control Register 2
 */

#define DAC_INSTANCE_COUNT (1U) /*!< Number of instances of the DAC module. */
#define DAC0_IDX (0U) /*!< Instance number for DAC0. */

/*******************************************************************************
 * DAC_DATL - DAC Data Low Register
 ******************************************************************************/

/*!
 * @brief DAC_DATL - DAC Data Low Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_DATL register
 */
/*@{*/
#define DAC_RD_DATL(base, index) (DAC_DATL_REG(base, index))
#define DAC_WR_DATL(base, index, value) (DAC_DATL_REG(base, index) = (value))
#define DAC_RMW_DATL(base, index, mask, value) (DAC_WR_DATL(base, index, (DAC_RD_DATL(base, index) & ~(mask)) | (value)))
#define DAC_SET_DATL(base, index, value) (BME_OR8(&DAC_DATL_REG(base, index), (uint8_t)(value)))
#define DAC_CLR_DATL(base, index, value) (BME_AND8(&DAC_DATL_REG(base, index), (uint8_t)(~(value))))
#define DAC_TOG_DATL(base, index, value) (BME_XOR8(&DAC_DATL_REG(base, index), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * DAC_DATH - DAC Data High Register
 ******************************************************************************/

/*!
 * @brief DAC_DATH - DAC Data High Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_DATH register
 */
/*@{*/
#define DAC_RD_DATH(base, index) (DAC_DATH_REG(base, index))
#define DAC_WR_DATH(base, index, value) (DAC_DATH_REG(base, index) = (value))
#define DAC_RMW_DATH(base, index, mask, value) (DAC_WR_DATH(base, index, (DAC_RD_DATH(base, index) & ~(mask)) | (value)))
#define DAC_SET_DATH(base, index, value) (BME_OR8(&DAC_DATH_REG(base, index), (uint8_t)(value)))
#define DAC_CLR_DATH(base, index, value) (BME_AND8(&DAC_DATH_REG(base, index), (uint8_t)(~(value))))
#define DAC_TOG_DATH(base, index, value) (BME_XOR8(&DAC_DATH_REG(base, index), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_DATH bitfields
 */

/*!
 * @name Register DAC_DATH, field DATA1[3:0] (RW)
 *
 * When the DAC Buffer is not enabled, DATA[11:0] controls the output voltage
 * based on the following formula. V out = V in * (1 + DACDAT0[11:0])/4096 When the
 * DAC buffer is enabled, DATA[11:0] is mapped to the 16-word buffer.
 */
/*@{*/
/*! @brief Read current value of the DAC_DATH_DATA1 field. */
#define DAC_RD_DATH_DATA1(base, index) ((DAC_DATH_REG(base, index) & DAC_DATH_DATA1_MASK) >> DAC_DATH_DATA1_SHIFT)
#define DAC_BRD_DATH_DATA1(base, index) (BME_UBFX8(&DAC_DATH_REG(base, index), DAC_DATH_DATA1_SHIFT, DAC_DATH_DATA1_WIDTH))

/*! @brief Set the DATA1 field to a new value. */
#define DAC_WR_DATH_DATA1(base, index, value) (DAC_RMW_DATH(base, index, DAC_DATH_DATA1_MASK, DAC_DATH_DATA1(value)))
#define DAC_BWR_DATH_DATA1(base, index, value) (BME_BFI8(&DAC_DATH_REG(base, index), ((uint8_t)(value) << DAC_DATH_DATA1_SHIFT), DAC_DATH_DATA1_SHIFT, DAC_DATH_DATA1_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_SR - DAC Status Register
 ******************************************************************************/

/*!
 * @brief DAC_SR - DAC Status Register (RW)
 *
 * Reset value: 0x06U
 *
 * If DMA is enabled, the flags can be cleared automatically by DMA when the DMA
 * request is done. Writing 0 to a field clears it whereas writing 1 has no
 * effect. After reset, DACBFRPTF is set and can be cleared by software, if needed.
 * The flags are set only when the data buffer status is changed. Do not use
 * 32/16-bit accesses to this register. A watermark interrupt is generated if
 * C0[DACBWIEN] is set after any write to DAC data register, since there is only 1 word
 * depth for the buffer watermark. It is recommended not to set C0[DACBWIEN] to
 * avoid repeated entry into the watermark interrupt.
 */
/*!
 * @name Constants and macros for entire DAC_SR register
 */
/*@{*/
#define DAC_RD_SR(base)          (DAC_SR_REG(base))
#define DAC_WR_SR(base, value)   (DAC_SR_REG(base) = (value))
#define DAC_RMW_SR(base, mask, value) (DAC_WR_SR(base, (DAC_RD_SR(base) & ~(mask)) | (value)))
#define DAC_SET_SR(base, value)  (BME_OR8(&DAC_SR_REG(base), (uint8_t)(value)))
#define DAC_CLR_SR(base, value)  (BME_AND8(&DAC_SR_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_SR(base, value)  (BME_XOR8(&DAC_SR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_SR bitfields
 */

/*!
 * @name Register DAC_SR, field DACBFRPBF[0] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer is not equal to C2[DACBFUP].
 * - 1 - The DAC buffer read pointer is equal to C2[DACBFUP].
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFRPBF field. */
#define DAC_RD_SR_DACBFRPBF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFRPBF_MASK) >> DAC_SR_DACBFRPBF_SHIFT)
#define DAC_BRD_SR_DACBFRPBF(base) (BME_UBFX8(&DAC_SR_REG(base), DAC_SR_DACBFRPBF_SHIFT, DAC_SR_DACBFRPBF_WIDTH))

/*! @brief Set the DACBFRPBF field to a new value. */
#define DAC_WR_SR_DACBFRPBF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFRPBF_MASK, DAC_SR_DACBFRPBF(value)))
#define DAC_BWR_SR_DACBFRPBF(base, value) (BME_BFI8(&DAC_SR_REG(base), ((uint8_t)(value) << DAC_SR_DACBFRPBF_SHIFT), DAC_SR_DACBFRPBF_SHIFT, DAC_SR_DACBFRPBF_WIDTH))
/*@}*/

/*!
 * @name Register DAC_SR, field DACBFRPTF[1] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer is not zero.
 * - 1 - The DAC buffer read pointer is zero.
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFRPTF field. */
#define DAC_RD_SR_DACBFRPTF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFRPTF_MASK) >> DAC_SR_DACBFRPTF_SHIFT)
#define DAC_BRD_SR_DACBFRPTF(base) (BME_UBFX8(&DAC_SR_REG(base), DAC_SR_DACBFRPTF_SHIFT, DAC_SR_DACBFRPTF_WIDTH))

/*! @brief Set the DACBFRPTF field to a new value. */
#define DAC_WR_SR_DACBFRPTF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFRPTF_MASK, DAC_SR_DACBFRPTF(value)))
#define DAC_BWR_SR_DACBFRPTF(base, value) (BME_BFI8(&DAC_SR_REG(base), ((uint8_t)(value) << DAC_SR_DACBFRPTF_SHIFT), DAC_SR_DACBFRPTF_SHIFT, DAC_SR_DACBFRPTF_WIDTH))
/*@}*/

/*!
 * @name Register DAC_SR, field DACBFWMF[2] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer has not reached the watermark level.
 * - 1 - The DAC buffer read pointer has reached the watermark level.
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFWMF field. */
#define DAC_RD_SR_DACBFWMF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFWMF_MASK) >> DAC_SR_DACBFWMF_SHIFT)
#define DAC_BRD_SR_DACBFWMF(base) (BME_UBFX8(&DAC_SR_REG(base), DAC_SR_DACBFWMF_SHIFT, DAC_SR_DACBFWMF_WIDTH))

/*! @brief Set the DACBFWMF field to a new value. */
#define DAC_WR_SR_DACBFWMF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFWMF_MASK, DAC_SR_DACBFWMF(value)))
#define DAC_BWR_SR_DACBFWMF(base, value) (BME_BFI8(&DAC_SR_REG(base), ((uint8_t)(value) << DAC_SR_DACBFWMF_SHIFT), DAC_SR_DACBFWMF_SHIFT, DAC_SR_DACBFWMF_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_C0 - DAC Control Register
 ******************************************************************************/

/*!
 * @brief DAC_C0 - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * Do not use 32- or 16-bit accesses to this register. A watermark interrupt is
 * generated if C0[DACBWIEN] is set after any write to DAC data register, since
 * there is only 1 word depth for the buffer watermark. It is recommended not to
 * set C0[DACBWIEN] to avoid repeated entry into the watermark interrupt.
 */
/*!
 * @name Constants and macros for entire DAC_C0 register
 */
/*@{*/
#define DAC_RD_C0(base)          (DAC_C0_REG(base))
#define DAC_WR_C0(base, value)   (DAC_C0_REG(base) = (value))
#define DAC_RMW_C0(base, mask, value) (DAC_WR_C0(base, (DAC_RD_C0(base) & ~(mask)) | (value)))
#define DAC_SET_C0(base, value)  (BME_OR8(&DAC_C0_REG(base), (uint8_t)(value)))
#define DAC_CLR_C0(base, value)  (BME_AND8(&DAC_C0_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_C0(base, value)  (BME_XOR8(&DAC_C0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C0 bitfields
 */

/*!
 * @name Register DAC_C0, field DACBBIEN[0] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer bottom flag interrupt is disabled.
 * - 1 - The DAC buffer read pointer bottom flag interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBBIEN field. */
#define DAC_RD_C0_DACBBIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBBIEN_MASK) >> DAC_C0_DACBBIEN_SHIFT)
#define DAC_BRD_C0_DACBBIEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACBBIEN_SHIFT, DAC_C0_DACBBIEN_WIDTH))

/*! @brief Set the DACBBIEN field to a new value. */
#define DAC_WR_C0_DACBBIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBBIEN_MASK, DAC_C0_DACBBIEN(value)))
#define DAC_BWR_C0_DACBBIEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACBBIEN_SHIFT), DAC_C0_DACBBIEN_SHIFT, DAC_C0_DACBBIEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACBTIEN[1] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer top flag interrupt is disabled.
 * - 1 - The DAC buffer read pointer top flag interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBTIEN field. */
#define DAC_RD_C0_DACBTIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBTIEN_MASK) >> DAC_C0_DACBTIEN_SHIFT)
#define DAC_BRD_C0_DACBTIEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACBTIEN_SHIFT, DAC_C0_DACBTIEN_WIDTH))

/*! @brief Set the DACBTIEN field to a new value. */
#define DAC_WR_C0_DACBTIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBTIEN_MASK, DAC_C0_DACBTIEN(value)))
#define DAC_BWR_C0_DACBTIEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACBTIEN_SHIFT), DAC_C0_DACBTIEN_SHIFT, DAC_C0_DACBTIEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACBWIEN[2] (RW)
 *
 * Values:
 * - 0 - The DAC buffer watermark interrupt is disabled.
 * - 1 - The DAC buffer watermark interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBWIEN field. */
#define DAC_RD_C0_DACBWIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBWIEN_MASK) >> DAC_C0_DACBWIEN_SHIFT)
#define DAC_BRD_C0_DACBWIEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACBWIEN_SHIFT, DAC_C0_DACBWIEN_WIDTH))

/*! @brief Set the DACBWIEN field to a new value. */
#define DAC_WR_C0_DACBWIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBWIEN_MASK, DAC_C0_DACBWIEN(value)))
#define DAC_BWR_C0_DACBWIEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACBWIEN_SHIFT), DAC_C0_DACBWIEN_SHIFT, DAC_C0_DACBWIEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field LPEN[3] (RW)
 *
 * See the 12-bit DAC electrical characteristics of the device data sheet for
 * details on the impact of the modes below.
 *
 * Values:
 * - 0 - High-Power mode
 * - 1 - Low-Power mode
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_LPEN field. */
#define DAC_RD_C0_LPEN(base) ((DAC_C0_REG(base) & DAC_C0_LPEN_MASK) >> DAC_C0_LPEN_SHIFT)
#define DAC_BRD_C0_LPEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_LPEN_SHIFT, DAC_C0_LPEN_WIDTH))

/*! @brief Set the LPEN field to a new value. */
#define DAC_WR_C0_LPEN(base, value) (DAC_RMW_C0(base, DAC_C0_LPEN_MASK, DAC_C0_LPEN(value)))
#define DAC_BWR_C0_LPEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_LPEN_SHIFT), DAC_C0_LPEN_SHIFT, DAC_C0_LPEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACSWTRG[4] (WORZ)
 *
 * Active high. This is a write-only field, which always reads 0. If DAC
 * software trigger is selected and buffer is enabled, writing 1 to this field will
 * advance the buffer read pointer once.
 *
 * Values:
 * - 0 - The DAC soft trigger is not valid.
 * - 1 - The DAC soft trigger is valid.
 */
/*@{*/
/*! @brief Set the DACSWTRG field to a new value. */
#define DAC_WR_C0_DACSWTRG(base, value) (DAC_RMW_C0(base, DAC_C0_DACSWTRG_MASK, DAC_C0_DACSWTRG(value)))
#define DAC_BWR_C0_DACSWTRG(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACSWTRG_SHIFT), DAC_C0_DACSWTRG_SHIFT, DAC_C0_DACSWTRG_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACTRGSEL[5] (RW)
 *
 * Values:
 * - 0 - The DAC hardware trigger is selected.
 * - 1 - The DAC software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACTRGSEL field. */
#define DAC_RD_C0_DACTRGSEL(base) ((DAC_C0_REG(base) & DAC_C0_DACTRGSEL_MASK) >> DAC_C0_DACTRGSEL_SHIFT)
#define DAC_BRD_C0_DACTRGSEL(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACTRGSEL_SHIFT, DAC_C0_DACTRGSEL_WIDTH))

/*! @brief Set the DACTRGSEL field to a new value. */
#define DAC_WR_C0_DACTRGSEL(base, value) (DAC_RMW_C0(base, DAC_C0_DACTRGSEL_MASK, DAC_C0_DACTRGSEL(value)))
#define DAC_BWR_C0_DACTRGSEL(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACTRGSEL_SHIFT), DAC_C0_DACTRGSEL_SHIFT, DAC_C0_DACTRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACRFS[6] (RW)
 *
 * Values:
 * - 0 - The DAC selects DACREF_1 as the reference voltage.
 * - 1 - The DAC selects DACREF_2 as the reference voltage.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACRFS field. */
#define DAC_RD_C0_DACRFS(base) ((DAC_C0_REG(base) & DAC_C0_DACRFS_MASK) >> DAC_C0_DACRFS_SHIFT)
#define DAC_BRD_C0_DACRFS(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACRFS_SHIFT, DAC_C0_DACRFS_WIDTH))

/*! @brief Set the DACRFS field to a new value. */
#define DAC_WR_C0_DACRFS(base, value) (DAC_RMW_C0(base, DAC_C0_DACRFS_MASK, DAC_C0_DACRFS(value)))
#define DAC_BWR_C0_DACRFS(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACRFS_SHIFT), DAC_C0_DACRFS_SHIFT, DAC_C0_DACRFS_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACEN[7] (RW)
 *
 * Starts the Programmable Reference Generator operation.
 *
 * Values:
 * - 0 - The DAC system is disabled.
 * - 1 - The DAC system is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACEN field. */
#define DAC_RD_C0_DACEN(base) ((DAC_C0_REG(base) & DAC_C0_DACEN_MASK) >> DAC_C0_DACEN_SHIFT)
#define DAC_BRD_C0_DACEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACEN_SHIFT, DAC_C0_DACEN_WIDTH))

/*! @brief Set the DACEN field to a new value. */
#define DAC_WR_C0_DACEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACEN_MASK, DAC_C0_DACEN(value)))
#define DAC_BWR_C0_DACEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACEN_SHIFT), DAC_C0_DACEN_SHIFT, DAC_C0_DACEN_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_C1 - DAC Control Register 1
 ******************************************************************************/

/*!
 * @brief DAC_C1 - DAC Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * Do not use 32- or 16-bit accesses to this register.
 */
/*!
 * @name Constants and macros for entire DAC_C1 register
 */
/*@{*/
#define DAC_RD_C1(base)          (DAC_C1_REG(base))
#define DAC_WR_C1(base, value)   (DAC_C1_REG(base) = (value))
#define DAC_RMW_C1(base, mask, value) (DAC_WR_C1(base, (DAC_RD_C1(base) & ~(mask)) | (value)))
#define DAC_SET_C1(base, value)  (BME_OR8(&DAC_C1_REG(base), (uint8_t)(value)))
#define DAC_CLR_C1(base, value)  (BME_AND8(&DAC_C1_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_C1(base, value)  (BME_XOR8(&DAC_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C1 bitfields
 */

/*!
 * @name Register DAC_C1, field DACBFEN[0] (RW)
 *
 * Values:
 * - 0 - Buffer read pointer is disabled. The converted data is always the first
 *     word of the buffer.
 * - 1 - Buffer read pointer is enabled. The converted data is the word that the
 *     read pointer points to. It means converted data can be from any word of
 *     the buffer.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFEN field. */
#define DAC_RD_C1_DACBFEN(base) ((DAC_C1_REG(base) & DAC_C1_DACBFEN_MASK) >> DAC_C1_DACBFEN_SHIFT)
#define DAC_BRD_C1_DACBFEN(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DACBFEN_SHIFT, DAC_C1_DACBFEN_WIDTH))

/*! @brief Set the DACBFEN field to a new value. */
#define DAC_WR_C1_DACBFEN(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFEN_MASK, DAC_C1_DACBFEN(value)))
#define DAC_BWR_C1_DACBFEN(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DACBFEN_SHIFT), DAC_C1_DACBFEN_SHIFT, DAC_C1_DACBFEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C1, field DACBFMD[2] (RW)
 *
 * Values:
 * - 0 - Normal mode
 * - 1 - One-Time Scan mode
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFMD field. */
#define DAC_RD_C1_DACBFMD(base) ((DAC_C1_REG(base) & DAC_C1_DACBFMD_MASK) >> DAC_C1_DACBFMD_SHIFT)
#define DAC_BRD_C1_DACBFMD(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DACBFMD_SHIFT, DAC_C1_DACBFMD_WIDTH))

/*! @brief Set the DACBFMD field to a new value. */
#define DAC_WR_C1_DACBFMD(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFMD_MASK, DAC_C1_DACBFMD(value)))
#define DAC_BWR_C1_DACBFMD(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DACBFMD_SHIFT), DAC_C1_DACBFMD_SHIFT, DAC_C1_DACBFMD_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C1, field DMAEN[7] (RW)
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled. When DMA is enabled, the DMA request will be generated
 *     by original interrupts. The interrupts will not be presented on this
 *     module at the same time.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DMAEN field. */
#define DAC_RD_C1_DMAEN(base) ((DAC_C1_REG(base) & DAC_C1_DMAEN_MASK) >> DAC_C1_DMAEN_SHIFT)
#define DAC_BRD_C1_DMAEN(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DMAEN_SHIFT, DAC_C1_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define DAC_WR_C1_DMAEN(base, value) (DAC_RMW_C1(base, DAC_C1_DMAEN_MASK, DAC_C1_DMAEN(value)))
#define DAC_BWR_C1_DMAEN(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DMAEN_SHIFT), DAC_C1_DMAEN_SHIFT, DAC_C1_DMAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_C2 - DAC Control Register 2
 ******************************************************************************/

/*!
 * @brief DAC_C2 - DAC Control Register 2 (RW)
 *
 * Reset value: 0x01U
 */
/*!
 * @name Constants and macros for entire DAC_C2 register
 */
/*@{*/
#define DAC_RD_C2(base)          (DAC_C2_REG(base))
#define DAC_WR_C2(base, value)   (DAC_C2_REG(base) = (value))
#define DAC_RMW_C2(base, mask, value) (DAC_WR_C2(base, (DAC_RD_C2(base) & ~(mask)) | (value)))
#define DAC_SET_C2(base, value)  (BME_OR8(&DAC_C2_REG(base), (uint8_t)(value)))
#define DAC_CLR_C2(base, value)  (BME_AND8(&DAC_C2_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_C2(base, value)  (BME_XOR8(&DAC_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C2 bitfields
 */

/*!
 * @name Register DAC_C2, field DACBFUP[0] (RW)
 *
 * Selects the upper limit of the DAC buffer. The buffer read pointer cannot
 * exceed it.
 */
/*@{*/
/*! @brief Read current value of the DAC_C2_DACBFUP field. */
#define DAC_RD_C2_DACBFUP(base) ((DAC_C2_REG(base) & DAC_C2_DACBFUP_MASK) >> DAC_C2_DACBFUP_SHIFT)
#define DAC_BRD_C2_DACBFUP(base) (BME_UBFX8(&DAC_C2_REG(base), DAC_C2_DACBFUP_SHIFT, DAC_C2_DACBFUP_WIDTH))

/*! @brief Set the DACBFUP field to a new value. */
#define DAC_WR_C2_DACBFUP(base, value) (DAC_RMW_C2(base, DAC_C2_DACBFUP_MASK, DAC_C2_DACBFUP(value)))
#define DAC_BWR_C2_DACBFUP(base, value) (BME_BFI8(&DAC_C2_REG(base), ((uint8_t)(value) << DAC_C2_DACBFUP_SHIFT), DAC_C2_DACBFUP_SHIFT, DAC_C2_DACBFUP_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C2, field DACBFRP[4] (RW)
 *
 * Keeps the current value of the buffer read pointer.
 */
/*@{*/
/*! @brief Read current value of the DAC_C2_DACBFRP field. */
#define DAC_RD_C2_DACBFRP(base) ((DAC_C2_REG(base) & DAC_C2_DACBFRP_MASK) >> DAC_C2_DACBFRP_SHIFT)
#define DAC_BRD_C2_DACBFRP(base) (BME_UBFX8(&DAC_C2_REG(base), DAC_C2_DACBFRP_SHIFT, DAC_C2_DACBFRP_WIDTH))

/*! @brief Set the DACBFRP field to a new value. */
#define DAC_WR_C2_DACBFRP(base, value) (DAC_RMW_C2(base, DAC_C2_DACBFRP_MASK, DAC_C2_DACBFRP(value)))
#define DAC_BWR_C2_DACBFRP(base, value) (BME_BFI8(&DAC_C2_REG(base), ((uint8_t)(value) << DAC_C2_DACBFRP_SHIFT), DAC_C2_DACBFRP_SHIFT, DAC_C2_DACBFRP_WIDTH))
/*@}*/

/*
 * MKV10Z7 DMA
 *
 * Enhanced direct memory access controller
 *
 * Registers defined in this header file:
 * - DMA_CR - Control Register
 * - DMA_ES - Error Status Register
 * - DMA_ERQ - Enable Request Register
 * - DMA_EEI - Enable Error Interrupt Register
 * - DMA_CEEI - Clear Enable Error Interrupt Register
 * - DMA_SEEI - Set Enable Error Interrupt Register
 * - DMA_CERQ - Clear Enable Request Register
 * - DMA_SERQ - Set Enable Request Register
 * - DMA_CDNE - Clear DONE Status Bit Register
 * - DMA_SSRT - Set START Bit Register
 * - DMA_CERR - Clear Error Register
 * - DMA_CINT - Clear Interrupt Request Register
 * - DMA_INT - Interrupt Request Register
 * - DMA_ERR - Error Register
 * - DMA_HRS - Hardware Request Status Register
 * - DMA_EARS - Enable Asynchronous Request in Stop Register
 * - DMA_DCHPRI3 - Channel n Priority Register
 * - DMA_DCHPRI2 - Channel n Priority Register
 * - DMA_DCHPRI1 - Channel n Priority Register
 * - DMA_DCHPRI0 - Channel n Priority Register
 * - DMA_SADDR - TCD Source Address
 * - DMA_SOFF - TCD Signed Source Address Offset
 * - DMA_ATTR - TCD Transfer Attributes
 * - DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - DMA_SLAST - TCD Last Source Address Adjustment
 * - DMA_DADDR - TCD Destination Address
 * - DMA_DOFF - TCD Signed Destination Address Offset
 * - DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_CSR - TCD Control and Status
 * - DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 */

#define DMA_INSTANCE_COUNT (1U) /*!< Number of instances of the DMA module. */
#define DMA_IDX (0U) /*!< Instance number for DMA. */

/*******************************************************************************
 * DMA_CR - Control Register
 ******************************************************************************/

/*!
 * @brief DMA_CR - Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CR defines the basic operating configuration of the DMA. Arbitration can
 * be configured to use either a fixed-priority or a round-robin scheme. For
 * fixed-priority arbitration, the highest priority channel requesting service is
 * selected to execute. The channel priority registers assign the priorities; see
 * the DCHPRIn registers. For round-robin arbitration, the channel priorities are
 * ignored and channels are cycled through (from high to low channel number)
 * without regard to priority. For correct operation, writes to the CR register must
 * be performed only when the DMA channels are inactive; that is, when
 * TCDn_CSR[ACTIVE] bits are cleared. Minor loop offsets are address offset values added to
 * the final source address (TCDn_SADDR) or destination address (TCDn_DADDR) upon
 * minor loop completion. When minor loop offsets are enabled, the minor loop
 * offset (MLOFF) is added to the final source address (TCDn_SADDR), to the final
 * destination address (TCDn_DADDR), or to both prior to the addresses being
 * written back into the TCD. If the major loop is complete, the minor loop offset is
 * ignored and the major loop address offsets (TCDn_SLAST and TCDn_DLAST_SGA) are
 * used to compute the next TCDn_SADDR and TCDn_DADDR values. When minor loop
 * mapping is enabled (EMLM is 1), TCDn word2 is redefined. A portion of TCDn word2
 * is used to specify multiple fields: a source enable bit (SMLOE) to specify
 * the minor loop offset should be applied to the source address (TCDn_SADDR) upon
 * minor loop completion, a destination enable bit (DMLOE) to specify the minor
 * loop offset should be applied to the destination address (TCDn_DADDR) upon
 * minor loop completion, and the sign extended minor loop offset value (MLOFF). The
 * same offset value (MLOFF) is used for both source and destination minor loop
 * offsets. When either minor loop offset is enabled (SMLOE set or DMLOE set), the
 * NBYTES field is reduced to 10 bits. When both minor loop offsets are disabled
 * (SMLOE cleared and DMLOE cleared), the NBYTES field is a 30-bit vector. When
 * minor loop mapping is disabled (EMLM is 0), all 32 bits of TCDn word2 are
 * assigned to the NBYTES field.
 */
/*!
 * @name Constants and macros for entire DMA_CR register
 */
/*@{*/
#define DMA_RD_CR(base)          (DMA_CR_REG(base))
#define DMA_WR_CR(base, value)   (DMA_CR_REG(base) = (value))
#define DMA_RMW_CR(base, mask, value) (DMA_WR_CR(base, (DMA_RD_CR(base) & ~(mask)) | (value)))
#define DMA_SET_CR(base, value)  (BME_OR32(&DMA_CR_REG(base), (uint32_t)(value)))
#define DMA_CLR_CR(base, value)  (BME_AND32(&DMA_CR_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_CR(base, value)  (BME_XOR32(&DMA_CR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CR bitfields
 */

/*!
 * @name Register DMA_CR, field EDBG[1] (RW)
 *
 * Values:
 * - 0 - When in debug mode, the DMA continues to operate.
 * - 1 - When in debug mode, the DMA stalls the start of a new channel.
 *     Executing channels are allowed to complete. Channel execution resumes when the
 *     system exits debug mode or the EDBG bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_EDBG field. */
#define DMA_RD_CR_EDBG(base) ((DMA_CR_REG(base) & DMA_CR_EDBG_MASK) >> DMA_CR_EDBG_SHIFT)
#define DMA_BRD_CR_EDBG(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_EDBG_SHIFT, DMA_CR_EDBG_WIDTH))

/*! @brief Set the EDBG field to a new value. */
#define DMA_WR_CR_EDBG(base, value) (DMA_RMW_CR(base, DMA_CR_EDBG_MASK, DMA_CR_EDBG(value)))
#define DMA_BWR_CR_EDBG(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_EDBG_SHIFT), DMA_CR_EDBG_SHIFT, DMA_CR_EDBG_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field ERCA[2] (RW)
 *
 * Values:
 * - 0 - Fixed priority arbitration is used for channel selection .
 * - 1 - Round robin arbitration is used for channel selection .
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ERCA field. */
#define DMA_RD_CR_ERCA(base) ((DMA_CR_REG(base) & DMA_CR_ERCA_MASK) >> DMA_CR_ERCA_SHIFT)
#define DMA_BRD_CR_ERCA(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_ERCA_SHIFT, DMA_CR_ERCA_WIDTH))

/*! @brief Set the ERCA field to a new value. */
#define DMA_WR_CR_ERCA(base, value) (DMA_RMW_CR(base, DMA_CR_ERCA_MASK, DMA_CR_ERCA(value)))
#define DMA_BWR_CR_ERCA(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_ERCA_SHIFT), DMA_CR_ERCA_SHIFT, DMA_CR_ERCA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field HOE[4] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Any error causes the HALT bit to set. Subsequently, all service
 *     requests are ignored until the HALT bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_HOE field. */
#define DMA_RD_CR_HOE(base)  ((DMA_CR_REG(base) & DMA_CR_HOE_MASK) >> DMA_CR_HOE_SHIFT)
#define DMA_BRD_CR_HOE(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_HOE_SHIFT, DMA_CR_HOE_WIDTH))

/*! @brief Set the HOE field to a new value. */
#define DMA_WR_CR_HOE(base, value) (DMA_RMW_CR(base, DMA_CR_HOE_MASK, DMA_CR_HOE(value)))
#define DMA_BWR_CR_HOE(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_HOE_SHIFT), DMA_CR_HOE_SHIFT, DMA_CR_HOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field HALT[5] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Stall the start of any new channels. Executing channels are allowed to
 *     complete. Channel execution resumes when this bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_HALT field. */
#define DMA_RD_CR_HALT(base) ((DMA_CR_REG(base) & DMA_CR_HALT_MASK) >> DMA_CR_HALT_SHIFT)
#define DMA_BRD_CR_HALT(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_HALT_SHIFT, DMA_CR_HALT_WIDTH))

/*! @brief Set the HALT field to a new value. */
#define DMA_WR_CR_HALT(base, value) (DMA_RMW_CR(base, DMA_CR_HALT_MASK, DMA_CR_HALT(value)))
#define DMA_BWR_CR_HALT(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_HALT_SHIFT), DMA_CR_HALT_SHIFT, DMA_CR_HALT_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field CLM[6] (RW)
 *
 * Values:
 * - 0 - A minor loop channel link made to itself goes through channel
 *     arbitration before being activated again.
 * - 1 - A minor loop channel link made to itself does not go through channel
 *     arbitration before being activated again. Upon minor loop completion, the
 *     channel activates again if that channel has a minor loop channel link
 *     enabled and the link channel is itself. This effectively applies the minor loop
 *     offsets and restarts the next minor loop.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_CLM field. */
#define DMA_RD_CR_CLM(base)  ((DMA_CR_REG(base) & DMA_CR_CLM_MASK) >> DMA_CR_CLM_SHIFT)
#define DMA_BRD_CR_CLM(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_CLM_SHIFT, DMA_CR_CLM_WIDTH))

/*! @brief Set the CLM field to a new value. */
#define DMA_WR_CR_CLM(base, value) (DMA_RMW_CR(base, DMA_CR_CLM_MASK, DMA_CR_CLM(value)))
#define DMA_BWR_CR_CLM(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_CLM_SHIFT), DMA_CR_CLM_SHIFT, DMA_CR_CLM_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field EMLM[7] (RW)
 *
 * Values:
 * - 0 - Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
 * - 1 - Enabled. TCDn.word2 is redefined to include individual enable fields,
 *     an offset field, and the NBYTES field. The individual enable fields allow
 *     the minor loop offset to be applied to the source address, the destination
 *     address, or both. The NBYTES field is reduced when either offset is
 *     enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_EMLM field. */
#define DMA_RD_CR_EMLM(base) ((DMA_CR_REG(base) & DMA_CR_EMLM_MASK) >> DMA_CR_EMLM_SHIFT)
#define DMA_BRD_CR_EMLM(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_EMLM_SHIFT, DMA_CR_EMLM_WIDTH))

/*! @brief Set the EMLM field to a new value. */
#define DMA_WR_CR_EMLM(base, value) (DMA_RMW_CR(base, DMA_CR_EMLM_MASK, DMA_CR_EMLM(value)))
#define DMA_BWR_CR_EMLM(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_EMLM_SHIFT), DMA_CR_EMLM_SHIFT, DMA_CR_EMLM_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field ECX[16] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Cancel the remaining data transfer in the same fashion as the CX bit.
 *     Stop the executing channel and force the minor loop to finish. The cancel
 *     takes effect after the last write of the current read/write sequence. The
 *     ECX bit clears itself after the cancel is honored. In addition to
 *     cancelling the transfer, ECX treats the cancel as an error condition, thus updating
 *     the Error Status register (DMAx_ES) and generating an optional error
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ECX field. */
#define DMA_RD_CR_ECX(base)  ((DMA_CR_REG(base) & DMA_CR_ECX_MASK) >> DMA_CR_ECX_SHIFT)
#define DMA_BRD_CR_ECX(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_ECX_SHIFT, DMA_CR_ECX_WIDTH))

/*! @brief Set the ECX field to a new value. */
#define DMA_WR_CR_ECX(base, value) (DMA_RMW_CR(base, DMA_CR_ECX_MASK, DMA_CR_ECX(value)))
#define DMA_BWR_CR_ECX(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_ECX_SHIFT), DMA_CR_ECX_SHIFT, DMA_CR_ECX_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field CX[17] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Cancel the remaining data transfer. Stop the executing channel and
 *     force the minor loop to finish. The cancel takes effect after the last write
 *     of the current read/write sequence. The CX bit clears itself after the
 *     cancel has been honored. This cancel retires the channel normally as if the
 *     minor loop was completed.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_CX field. */
#define DMA_RD_CR_CX(base)   ((DMA_CR_REG(base) & DMA_CR_CX_MASK) >> DMA_CR_CX_SHIFT)
#define DMA_BRD_CR_CX(base)  (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_CX_SHIFT, DMA_CR_CX_WIDTH))

/*! @brief Set the CX field to a new value. */
#define DMA_WR_CR_CX(base, value) (DMA_RMW_CR(base, DMA_CR_CX_MASK, DMA_CR_CX(value)))
#define DMA_BWR_CR_CX(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_CX_SHIFT), DMA_CR_CX_SHIFT, DMA_CR_CX_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_ES - Error Status Register
 ******************************************************************************/

/*!
 * @brief DMA_ES - Error Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The ES provides information concerning the last recorded channel error.
 * Channel errors can be caused by: A configuration error, that is: An illegal setting
 * in the transfer-control descriptor, or An illegal priority register setting
 * in fixed-arbitration An error termination to a bus master read or write cycle
 * See the Error Reporting and Handling section for more details.
 */
/*!
 * @name Constants and macros for entire DMA_ES register
 */
/*@{*/
#define DMA_RD_ES(base)          (DMA_ES_REG(base))
/*@}*/

/*
 * Constants & macros for individual DMA_ES bitfields
 */

/*!
 * @name Register DMA_ES, field DBE[0] (RO)
 *
 * Values:
 * - 0 - No destination bus error
 * - 1 - The last recorded error was a bus error on a destination write
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DBE field. */
#define DMA_RD_ES_DBE(base)  ((DMA_ES_REG(base) & DMA_ES_DBE_MASK) >> DMA_ES_DBE_SHIFT)
#define DMA_BRD_ES_DBE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_DBE_SHIFT, DMA_ES_DBE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field SBE[1] (RO)
 *
 * Values:
 * - 0 - No source bus error
 * - 1 - The last recorded error was a bus error on a source read
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SBE field. */
#define DMA_RD_ES_SBE(base)  ((DMA_ES_REG(base) & DMA_ES_SBE_MASK) >> DMA_ES_SBE_SHIFT)
#define DMA_BRD_ES_SBE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_SBE_SHIFT, DMA_ES_SBE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field SGE[2] (RO)
 *
 * Values:
 * - 0 - No scatter/gather configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather
 *     operation after major loop completion if TCDn_CSR[ESG] is enabled.
 *     TCDn_DLASTSGA is not on a 32 byte boundary.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SGE field. */
#define DMA_RD_ES_SGE(base)  ((DMA_ES_REG(base) & DMA_ES_SGE_MASK) >> DMA_ES_SGE_SHIFT)
#define DMA_BRD_ES_SGE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_SGE_SHIFT, DMA_ES_SGE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field NCE[3] (RO)
 *
 * Values:
 * - 0 - No NBYTES/CITER configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of
 *     TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or
 *     TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_NCE field. */
#define DMA_RD_ES_NCE(base)  ((DMA_ES_REG(base) & DMA_ES_NCE_MASK) >> DMA_ES_NCE_SHIFT)
#define DMA_BRD_ES_NCE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_NCE_SHIFT, DMA_ES_NCE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field DOE[4] (RO)
 *
 * Values:
 * - 0 - No destination offset configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DOE field. */
#define DMA_RD_ES_DOE(base)  ((DMA_ES_REG(base) & DMA_ES_DOE_MASK) >> DMA_ES_DOE_SHIFT)
#define DMA_BRD_ES_DOE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_DOE_SHIFT, DMA_ES_DOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field DAE[5] (RO)
 *
 * Values:
 * - 0 - No destination address configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DAE field. */
#define DMA_RD_ES_DAE(base)  ((DMA_ES_REG(base) & DMA_ES_DAE_MASK) >> DMA_ES_DAE_SHIFT)
#define DMA_BRD_ES_DAE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_DAE_SHIFT, DMA_ES_DAE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field SOE[6] (RO)
 *
 * Values:
 * - 0 - No source offset configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SOE field. */
#define DMA_RD_ES_SOE(base)  ((DMA_ES_REG(base) & DMA_ES_SOE_MASK) >> DMA_ES_SOE_SHIFT)
#define DMA_BRD_ES_SOE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_SOE_SHIFT, DMA_ES_SOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field SAE[7] (RO)
 *
 * Values:
 * - 0 - No source address configuration error.
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SAE field. */
#define DMA_RD_ES_SAE(base)  ((DMA_ES_REG(base) & DMA_ES_SAE_MASK) >> DMA_ES_SAE_SHIFT)
#define DMA_BRD_ES_SAE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_SAE_SHIFT, DMA_ES_SAE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field ERRCHN[9:8] (RO)
 *
 * The channel number of the last recorded error, excluding CPE errors, or last
 * recorded error canceled transfer.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_ERRCHN field. */
#define DMA_RD_ES_ERRCHN(base) ((DMA_ES_REG(base) & DMA_ES_ERRCHN_MASK) >> DMA_ES_ERRCHN_SHIFT)
#define DMA_BRD_ES_ERRCHN(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_ERRCHN_SHIFT, DMA_ES_ERRCHN_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field CPE[14] (RO)
 *
 * Values:
 * - 0 - No channel priority error
 * - 1 - The last recorded error was a configuration error in the channel
 *     priorities . Channel priorities are not unique.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_CPE field. */
#define DMA_RD_ES_CPE(base)  ((DMA_ES_REG(base) & DMA_ES_CPE_MASK) >> DMA_ES_CPE_SHIFT)
#define DMA_BRD_ES_CPE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_CPE_SHIFT, DMA_ES_CPE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field ECX[16] (RO)
 *
 * Values:
 * - 0 - No canceled transfers
 * - 1 - The last recorded entry was a canceled transfer by the error cancel
 *     transfer input
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_ECX field. */
#define DMA_RD_ES_ECX(base)  ((DMA_ES_REG(base) & DMA_ES_ECX_MASK) >> DMA_ES_ECX_SHIFT)
#define DMA_BRD_ES_ECX(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_ECX_SHIFT, DMA_ES_ECX_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field VLD[31] (RO)
 *
 * Logical OR of all ERR status bits
 *
 * Values:
 * - 0 - No ERR bits are set.
 * - 1 - At least one ERR bit is set indicating a valid error exists that has
 *     not been cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_VLD field. */
#define DMA_RD_ES_VLD(base)  ((DMA_ES_REG(base) & DMA_ES_VLD_MASK) >> DMA_ES_VLD_SHIFT)
#define DMA_BRD_ES_VLD(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_VLD_SHIFT, DMA_ES_VLD_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_ERQ - Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_ERQ - Enable Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERQ register provides a bit map for the 4 channels to enable the request
 * signal for each channel. The state of any given channel enable is directly
 * affected by writes to this register; it is also affected by writes to the SERQ
 * and CERQ registers. These registers are provided so the request enable for a
 * single channel can easily be modified without needing to perform a
 * read-modify-write sequence to the ERQ. DMA request input signals and this enable request
 * flag must be asserted before a channel's hardware service request is accepted.
 * The state of the DMA enable request flag does not affect a channel service
 * request made explicitly through software or a linked channel request.
 */
/*!
 * @name Constants and macros for entire DMA_ERQ register
 */
/*@{*/
#define DMA_RD_ERQ(base)         (DMA_ERQ_REG(base))
#define DMA_WR_ERQ(base, value)  (DMA_ERQ_REG(base) = (value))
#define DMA_RMW_ERQ(base, mask, value) (DMA_WR_ERQ(base, (DMA_RD_ERQ(base) & ~(mask)) | (value)))
#define DMA_SET_ERQ(base, value) (BME_OR32(&DMA_ERQ_REG(base), (uint32_t)(value)))
#define DMA_CLR_ERQ(base, value) (BME_AND32(&DMA_ERQ_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_ERQ(base, value) (BME_XOR32(&DMA_ERQ_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERQ bitfields
 */

/*!
 * @name Register DMA_ERQ, field ERQ0[0] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ0 field. */
#define DMA_RD_ERQ_ERQ0(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ0_MASK) >> DMA_ERQ_ERQ0_SHIFT)
#define DMA_BRD_ERQ_ERQ0(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ0_SHIFT, DMA_ERQ_ERQ0_WIDTH))

/*! @brief Set the ERQ0 field to a new value. */
#define DMA_WR_ERQ_ERQ0(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ0_MASK, DMA_ERQ_ERQ0(value)))
#define DMA_BWR_ERQ_ERQ0(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ0_SHIFT), DMA_ERQ_ERQ0_SHIFT, DMA_ERQ_ERQ0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ1[1] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ1 field. */
#define DMA_RD_ERQ_ERQ1(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ1_MASK) >> DMA_ERQ_ERQ1_SHIFT)
#define DMA_BRD_ERQ_ERQ1(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ1_SHIFT, DMA_ERQ_ERQ1_WIDTH))

/*! @brief Set the ERQ1 field to a new value. */
#define DMA_WR_ERQ_ERQ1(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ1_MASK, DMA_ERQ_ERQ1(value)))
#define DMA_BWR_ERQ_ERQ1(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ1_SHIFT), DMA_ERQ_ERQ1_SHIFT, DMA_ERQ_ERQ1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ2[2] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ2 field. */
#define DMA_RD_ERQ_ERQ2(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ2_MASK) >> DMA_ERQ_ERQ2_SHIFT)
#define DMA_BRD_ERQ_ERQ2(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ2_SHIFT, DMA_ERQ_ERQ2_WIDTH))

/*! @brief Set the ERQ2 field to a new value. */
#define DMA_WR_ERQ_ERQ2(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ2_MASK, DMA_ERQ_ERQ2(value)))
#define DMA_BWR_ERQ_ERQ2(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ2_SHIFT), DMA_ERQ_ERQ2_SHIFT, DMA_ERQ_ERQ2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ3[3] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ3 field. */
#define DMA_RD_ERQ_ERQ3(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ3_MASK) >> DMA_ERQ_ERQ3_SHIFT)
#define DMA_BRD_ERQ_ERQ3(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ3_SHIFT, DMA_ERQ_ERQ3_WIDTH))

/*! @brief Set the ERQ3 field to a new value. */
#define DMA_WR_ERQ_ERQ3(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ3_MASK, DMA_ERQ_ERQ3(value)))
#define DMA_BWR_ERQ_ERQ3(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ3_SHIFT), DMA_ERQ_ERQ3_SHIFT, DMA_ERQ_ERQ3_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_EEI - Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_EEI - Enable Error Interrupt Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The EEI register provides a bit map for the 4 channels to enable the error
 * interrupt signal for each channel. The state of any given channel's error
 * interrupt enable is directly affected by writes to this register; it is also
 * affected by writes to the SEEI and CEEI. These registers are provided so that the
 * error interrupt enable for a single channel can easily be modified without the
 * need to perform a read-modify-write sequence to the EEI register. The DMA error
 * indicator and the error interrupt enable flag must be asserted before an error
 * interrupt request for a given channel is asserted to the interrupt controller.
 */
/*!
 * @name Constants and macros for entire DMA_EEI register
 */
/*@{*/
#define DMA_RD_EEI(base)         (DMA_EEI_REG(base))
#define DMA_WR_EEI(base, value)  (DMA_EEI_REG(base) = (value))
#define DMA_RMW_EEI(base, mask, value) (DMA_WR_EEI(base, (DMA_RD_EEI(base) & ~(mask)) | (value)))
#define DMA_SET_EEI(base, value) (BME_OR32(&DMA_EEI_REG(base), (uint32_t)(value)))
#define DMA_CLR_EEI(base, value) (BME_AND32(&DMA_EEI_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_EEI(base, value) (BME_XOR32(&DMA_EEI_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_EEI bitfields
 */

/*!
 * @name Register DMA_EEI, field EEI0[0] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI0 field. */
#define DMA_RD_EEI_EEI0(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI0_MASK) >> DMA_EEI_EEI0_SHIFT)
#define DMA_BRD_EEI_EEI0(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI0_SHIFT, DMA_EEI_EEI0_WIDTH))

/*! @brief Set the EEI0 field to a new value. */
#define DMA_WR_EEI_EEI0(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI0_MASK, DMA_EEI_EEI0(value)))
#define DMA_BWR_EEI_EEI0(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI0_SHIFT), DMA_EEI_EEI0_SHIFT, DMA_EEI_EEI0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI1[1] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI1 field. */
#define DMA_RD_EEI_EEI1(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI1_MASK) >> DMA_EEI_EEI1_SHIFT)
#define DMA_BRD_EEI_EEI1(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI1_SHIFT, DMA_EEI_EEI1_WIDTH))

/*! @brief Set the EEI1 field to a new value. */
#define DMA_WR_EEI_EEI1(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI1_MASK, DMA_EEI_EEI1(value)))
#define DMA_BWR_EEI_EEI1(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI1_SHIFT), DMA_EEI_EEI1_SHIFT, DMA_EEI_EEI1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI2[2] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI2 field. */
#define DMA_RD_EEI_EEI2(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI2_MASK) >> DMA_EEI_EEI2_SHIFT)
#define DMA_BRD_EEI_EEI2(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI2_SHIFT, DMA_EEI_EEI2_WIDTH))

/*! @brief Set the EEI2 field to a new value. */
#define DMA_WR_EEI_EEI2(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI2_MASK, DMA_EEI_EEI2(value)))
#define DMA_BWR_EEI_EEI2(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI2_SHIFT), DMA_EEI_EEI2_SHIFT, DMA_EEI_EEI2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI3[3] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI3 field. */
#define DMA_RD_EEI_EEI3(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI3_MASK) >> DMA_EEI_EEI3_SHIFT)
#define DMA_BRD_EEI_EEI3(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI3_SHIFT, DMA_EEI_EEI3_WIDTH))

/*! @brief Set the EEI3 field to a new value. */
#define DMA_WR_EEI_EEI3(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI3_MASK, DMA_EEI_EEI3(value)))
#define DMA_BWR_EEI_EEI3(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI3_SHIFT), DMA_EEI_EEI3_SHIFT, DMA_EEI_EEI3_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CEEI - Clear Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_CEEI - Clear Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CEEI provides a simple memory-mapped mechanism to clear a given bit in
 * the EEI to disable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be cleared. Setting
 * the CAEE bit provides a global clear function, forcing the EEI contents to be
 * cleared, disabling all DMA request inputs. If the NOP bit is set, the command
 * is ignored. This allows you to write multiple-byte registers as a 32-bit word.
 * Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CEEI register
 */
/*@{*/
#define DMA_RD_CEEI(base)        (DMA_CEEI_REG(base))
#define DMA_WR_CEEI(base, value) (DMA_CEEI_REG(base) = (value))
#define DMA_RMW_CEEI(base, mask, value) (DMA_WR_CEEI(base, (DMA_RD_CEEI(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CEEI bitfields
 */

/*!
 * @name Register DMA_CEEI, field CEEI[1:0] (WORZ)
 *
 * Clears the corresponding bit in EEI
 */
/*@{*/
/*! @brief Set the CEEI field to a new value. */
#define DMA_WR_CEEI_CEEI(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_CEEI_MASK, DMA_CEEI_CEEI(value)))
#define DMA_BWR_CEEI_CEEI(base, value) (BME_BFI8(&DMA_CEEI_REG(base), ((uint8_t)(value) << DMA_CEEI_CEEI_SHIFT), DMA_CEEI_CEEI_SHIFT, DMA_CEEI_CEEI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CEEI, field CAEE[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the EEI bit specified in the CEEI field
 * - 1 - Clear all bits in EEI
 */
/*@{*/
/*! @brief Set the CAEE field to a new value. */
#define DMA_WR_CEEI_CAEE(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_CAEE_MASK, DMA_CEEI_CAEE(value)))
#define DMA_BWR_CEEI_CAEE(base, value) (BME_BFI8(&DMA_CEEI_REG(base), ((uint8_t)(value) << DMA_CEEI_CAEE_SHIFT), DMA_CEEI_CAEE_SHIFT, DMA_CEEI_CAEE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CEEI_NOP(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_NOP_MASK, DMA_CEEI_NOP(value)))
#define DMA_BWR_CEEI_NOP(base, value) (BME_BFI8(&DMA_CEEI_REG(base), ((uint8_t)(value) << DMA_CEEI_NOP_SHIFT), DMA_CEEI_NOP_SHIFT, DMA_CEEI_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SEEI - Set Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_SEEI - Set Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SEEI provides a simple memory-mapped mechanism to set a given bit in the
 * EEI to enable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be set. Setting the
 * SAEE bit provides a global set function, forcing the entire EEI contents to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SEEI register
 */
/*@{*/
#define DMA_RD_SEEI(base)        (DMA_SEEI_REG(base))
#define DMA_WR_SEEI(base, value) (DMA_SEEI_REG(base) = (value))
#define DMA_RMW_SEEI(base, mask, value) (DMA_WR_SEEI(base, (DMA_RD_SEEI(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SEEI bitfields
 */

/*!
 * @name Register DMA_SEEI, field SEEI[1:0] (WORZ)
 *
 * Sets the corresponding bit in EEI
 */
/*@{*/
/*! @brief Set the SEEI field to a new value. */
#define DMA_WR_SEEI_SEEI(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_SEEI_MASK, DMA_SEEI_SEEI(value)))
#define DMA_BWR_SEEI_SEEI(base, value) (BME_BFI8(&DMA_SEEI_REG(base), ((uint8_t)(value) << DMA_SEEI_SEEI_SHIFT), DMA_SEEI_SEEI_SHIFT, DMA_SEEI_SEEI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SEEI, field SAEE[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the EEI bit specified in the SEEI field.
 * - 1 - Sets all bits in EEI
 */
/*@{*/
/*! @brief Set the SAEE field to a new value. */
#define DMA_WR_SEEI_SAEE(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_SAEE_MASK, DMA_SEEI_SAEE(value)))
#define DMA_BWR_SEEI_SAEE(base, value) (BME_BFI8(&DMA_SEEI_REG(base), ((uint8_t)(value) << DMA_SEEI_SAEE_SHIFT), DMA_SEEI_SAEE_SHIFT, DMA_SEEI_SAEE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SEEI_NOP(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_NOP_MASK, DMA_SEEI_NOP(value)))
#define DMA_BWR_SEEI_NOP(base, value) (BME_BFI8(&DMA_SEEI_REG(base), ((uint8_t)(value) << DMA_SEEI_NOP_SHIFT), DMA_SEEI_NOP_SHIFT, DMA_SEEI_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CERQ - Clear Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_CERQ - Clear Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERQ provides a simple memory-mapped mechanism to clear a given bit in
 * the ERQ to disable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be cleared. Setting the
 * CAER bit provides a global clear function, forcing the entire contents of the
 * ERQ to be cleared, disabling all DMA request inputs. If NOP is set, the
 * command is ignored. This allows you to write multiple-byte registers as a 32-bit
 * word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CERQ register
 */
/*@{*/
#define DMA_RD_CERQ(base)        (DMA_CERQ_REG(base))
#define DMA_WR_CERQ(base, value) (DMA_CERQ_REG(base) = (value))
#define DMA_RMW_CERQ(base, mask, value) (DMA_WR_CERQ(base, (DMA_RD_CERQ(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CERQ bitfields
 */

/*!
 * @name Register DMA_CERQ, field CERQ[1:0] (WORZ)
 *
 * Clears the corresponding bit in ERQ.
 */
/*@{*/
/*! @brief Set the CERQ field to a new value. */
#define DMA_WR_CERQ_CERQ(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_CERQ_MASK, DMA_CERQ_CERQ(value)))
#define DMA_BWR_CERQ_CERQ(base, value) (BME_BFI8(&DMA_CERQ_REG(base), ((uint8_t)(value) << DMA_CERQ_CERQ_SHIFT), DMA_CERQ_CERQ_SHIFT, DMA_CERQ_CERQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CERQ, field CAER[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the ERQ bit specified in the CERQ field
 * - 1 - Clear all bits in ERQ
 */
/*@{*/
/*! @brief Set the CAER field to a new value. */
#define DMA_WR_CERQ_CAER(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_CAER_MASK, DMA_CERQ_CAER(value)))
#define DMA_BWR_CERQ_CAER(base, value) (BME_BFI8(&DMA_CERQ_REG(base), ((uint8_t)(value) << DMA_CERQ_CAER_SHIFT), DMA_CERQ_CAER_SHIFT, DMA_CERQ_CAER_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CERQ_NOP(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_NOP_MASK, DMA_CERQ_NOP(value)))
#define DMA_BWR_CERQ_NOP(base, value) (BME_BFI8(&DMA_CERQ_REG(base), ((uint8_t)(value) << DMA_CERQ_NOP_SHIFT), DMA_CERQ_NOP_SHIFT, DMA_CERQ_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SERQ - Set Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_SERQ - Set Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SERQ provides a simple memory-mapped mechanism to set a given bit in the
 * ERQ to enable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be set. Setting the SAER
 * bit provides a global set function, forcing the entire contents of ERQ to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SERQ register
 */
/*@{*/
#define DMA_RD_SERQ(base)        (DMA_SERQ_REG(base))
#define DMA_WR_SERQ(base, value) (DMA_SERQ_REG(base) = (value))
#define DMA_RMW_SERQ(base, mask, value) (DMA_WR_SERQ(base, (DMA_RD_SERQ(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SERQ bitfields
 */

/*!
 * @name Register DMA_SERQ, field SERQ[1:0] (WORZ)
 *
 * Sets the corresponding bit in ERQ.
 */
/*@{*/
/*! @brief Set the SERQ field to a new value. */
#define DMA_WR_SERQ_SERQ(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_SERQ_MASK, DMA_SERQ_SERQ(value)))
#define DMA_BWR_SERQ_SERQ(base, value) (BME_BFI8(&DMA_SERQ_REG(base), ((uint8_t)(value) << DMA_SERQ_SERQ_SHIFT), DMA_SERQ_SERQ_SHIFT, DMA_SERQ_SERQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SERQ, field SAER[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the ERQ bit specified in the SERQ field
 * - 1 - Set all bits in ERQ
 */
/*@{*/
/*! @brief Set the SAER field to a new value. */
#define DMA_WR_SERQ_SAER(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_SAER_MASK, DMA_SERQ_SAER(value)))
#define DMA_BWR_SERQ_SAER(base, value) (BME_BFI8(&DMA_SERQ_REG(base), ((uint8_t)(value) << DMA_SERQ_SAER_SHIFT), DMA_SERQ_SAER_SHIFT, DMA_SERQ_SAER_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SERQ_NOP(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_NOP_MASK, DMA_SERQ_NOP(value)))
#define DMA_BWR_SERQ_NOP(base, value) (BME_BFI8(&DMA_SERQ_REG(base), ((uint8_t)(value) << DMA_SERQ_NOP_SHIFT), DMA_SERQ_NOP_SHIFT, DMA_SERQ_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CDNE - Clear DONE Status Bit Register
 ******************************************************************************/

/*!
 * @brief DMA_CDNE - Clear DONE Status Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CDNE provides a simple memory-mapped mechanism to clear the DONE bit in
 * the TCD of the given channel. The data value on a register write causes the
 * DONE bit in the corresponding transfer control descriptor to be cleared. Setting
 * the CADN bit provides a global clear function, forcing all DONE bits to be
 * cleared. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CDNE register
 */
/*@{*/
#define DMA_RD_CDNE(base)        (DMA_CDNE_REG(base))
#define DMA_WR_CDNE(base, value) (DMA_CDNE_REG(base) = (value))
#define DMA_RMW_CDNE(base, mask, value) (DMA_WR_CDNE(base, (DMA_RD_CDNE(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CDNE bitfields
 */

/*!
 * @name Register DMA_CDNE, field CDNE[1:0] (WORZ)
 *
 * Clears the corresponding bit in TCDn_CSR[DONE]
 */
/*@{*/
/*! @brief Set the CDNE field to a new value. */
#define DMA_WR_CDNE_CDNE(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_CDNE_MASK, DMA_CDNE_CDNE(value)))
#define DMA_BWR_CDNE_CDNE(base, value) (BME_BFI8(&DMA_CDNE_REG(base), ((uint8_t)(value) << DMA_CDNE_CDNE_SHIFT), DMA_CDNE_CDNE_SHIFT, DMA_CDNE_CDNE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CDNE, field CADN[6] (WORZ)
 *
 * Values:
 * - 0 - Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
 * - 1 - Clears all bits in TCDn_CSR[DONE]
 */
/*@{*/
/*! @brief Set the CADN field to a new value. */
#define DMA_WR_CDNE_CADN(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_CADN_MASK, DMA_CDNE_CADN(value)))
#define DMA_BWR_CDNE_CADN(base, value) (BME_BFI8(&DMA_CDNE_REG(base), ((uint8_t)(value) << DMA_CDNE_CADN_SHIFT), DMA_CDNE_CADN_SHIFT, DMA_CDNE_CADN_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CDNE, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CDNE_NOP(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_NOP_MASK, DMA_CDNE_NOP(value)))
#define DMA_BWR_CDNE_NOP(base, value) (BME_BFI8(&DMA_CDNE_REG(base), ((uint8_t)(value) << DMA_CDNE_NOP_SHIFT), DMA_CDNE_NOP_SHIFT, DMA_CDNE_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SSRT - Set START Bit Register
 ******************************************************************************/

/*!
 * @brief DMA_SSRT - Set START Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SSRT provides a simple memory-mapped mechanism to set the START bit in
 * the TCD of the given channel. The data value on a register write causes the
 * START bit in the corresponding transfer control descriptor to be set. Setting the
 * SAST bit provides a global set function, forcing all START bits to be set. If
 * the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SSRT register
 */
/*@{*/
#define DMA_RD_SSRT(base)        (DMA_SSRT_REG(base))
#define DMA_WR_SSRT(base, value) (DMA_SSRT_REG(base) = (value))
#define DMA_RMW_SSRT(base, mask, value) (DMA_WR_SSRT(base, (DMA_RD_SSRT(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SSRT bitfields
 */

/*!
 * @name Register DMA_SSRT, field SSRT[1:0] (WORZ)
 *
 * Sets the corresponding bit in TCDn_CSR[START]
 */
/*@{*/
/*! @brief Set the SSRT field to a new value. */
#define DMA_WR_SSRT_SSRT(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_SSRT_MASK, DMA_SSRT_SSRT(value)))
#define DMA_BWR_SSRT_SSRT(base, value) (BME_BFI8(&DMA_SSRT_REG(base), ((uint8_t)(value) << DMA_SSRT_SSRT_SHIFT), DMA_SSRT_SSRT_SHIFT, DMA_SSRT_SSRT_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SSRT, field SAST[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the TCDn_CSR[START] bit specified in the SSRT field
 * - 1 - Set all bits in TCDn_CSR[START]
 */
/*@{*/
/*! @brief Set the SAST field to a new value. */
#define DMA_WR_SSRT_SAST(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_SAST_MASK, DMA_SSRT_SAST(value)))
#define DMA_BWR_SSRT_SAST(base, value) (BME_BFI8(&DMA_SSRT_REG(base), ((uint8_t)(value) << DMA_SSRT_SAST_SHIFT), DMA_SSRT_SAST_SHIFT, DMA_SSRT_SAST_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SSRT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SSRT_NOP(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_NOP_MASK, DMA_SSRT_NOP(value)))
#define DMA_BWR_SSRT_NOP(base, value) (BME_BFI8(&DMA_SSRT_REG(base), ((uint8_t)(value) << DMA_SSRT_NOP_SHIFT), DMA_SSRT_NOP_SHIFT, DMA_SSRT_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CERR - Clear Error Register
 ******************************************************************************/

/*!
 * @brief DMA_CERR - Clear Error Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERR provides a simple memory-mapped mechanism to clear a given bit in
 * the ERR to disable the error condition flag for a given channel. The given value
 * on a register write causes the corresponding bit in the ERR to be cleared.
 * Setting the CAEI bit provides a global clear function, forcing the ERR contents
 * to be cleared, clearing all channel error indicators. If the NOP bit is set,
 * the command is ignored. This allows you to write multiple-byte registers as a
 * 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CERR register
 */
/*@{*/
#define DMA_RD_CERR(base)        (DMA_CERR_REG(base))
#define DMA_WR_CERR(base, value) (DMA_CERR_REG(base) = (value))
#define DMA_RMW_CERR(base, mask, value) (DMA_WR_CERR(base, (DMA_RD_CERR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CERR bitfields
 */

/*!
 * @name Register DMA_CERR, field CERR[1:0] (WORZ)
 *
 * Clears the corresponding bit in ERR
 */
/*@{*/
/*! @brief Set the CERR field to a new value. */
#define DMA_WR_CERR_CERR(base, value) (DMA_RMW_CERR(base, DMA_CERR_CERR_MASK, DMA_CERR_CERR(value)))
#define DMA_BWR_CERR_CERR(base, value) (BME_BFI8(&DMA_CERR_REG(base), ((uint8_t)(value) << DMA_CERR_CERR_SHIFT), DMA_CERR_CERR_SHIFT, DMA_CERR_CERR_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CERR, field CAEI[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the ERR bit specified in the CERR field
 * - 1 - Clear all bits in ERR
 */
/*@{*/
/*! @brief Set the CAEI field to a new value. */
#define DMA_WR_CERR_CAEI(base, value) (DMA_RMW_CERR(base, DMA_CERR_CAEI_MASK, DMA_CERR_CAEI(value)))
#define DMA_BWR_CERR_CAEI(base, value) (BME_BFI8(&DMA_CERR_REG(base), ((uint8_t)(value) << DMA_CERR_CAEI_SHIFT), DMA_CERR_CAEI_SHIFT, DMA_CERR_CAEI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CERR, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CERR_NOP(base, value) (DMA_RMW_CERR(base, DMA_CERR_NOP_MASK, DMA_CERR_NOP(value)))
#define DMA_BWR_CERR_NOP(base, value) (BME_BFI8(&DMA_CERR_REG(base), ((uint8_t)(value) << DMA_CERR_NOP_SHIFT), DMA_CERR_NOP_SHIFT, DMA_CERR_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CINT - Clear Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief DMA_CINT - Clear Interrupt Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CINT provides a simple, memory-mapped mechanism to clear a given bit in
 * the INT to disable the interrupt request for a given channel. The given value
 * on a register write causes the corresponding bit in the INT to be cleared.
 * Setting the CAIR bit provides a global clear function, forcing the entire contents
 * of the INT to be cleared, disabling all DMA interrupt requests. If the NOP
 * bit is set, the command is ignored. This allows you to write multiple-byte
 * registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CINT register
 */
/*@{*/
#define DMA_RD_CINT(base)        (DMA_CINT_REG(base))
#define DMA_WR_CINT(base, value) (DMA_CINT_REG(base) = (value))
#define DMA_RMW_CINT(base, mask, value) (DMA_WR_CINT(base, (DMA_RD_CINT(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CINT bitfields
 */

/*!
 * @name Register DMA_CINT, field CINT[1:0] (WORZ)
 *
 * Clears the corresponding bit in INT
 */
/*@{*/
/*! @brief Set the CINT field to a new value. */
#define DMA_WR_CINT_CINT(base, value) (DMA_RMW_CINT(base, DMA_CINT_CINT_MASK, DMA_CINT_CINT(value)))
#define DMA_BWR_CINT_CINT(base, value) (BME_BFI8(&DMA_CINT_REG(base), ((uint8_t)(value) << DMA_CINT_CINT_SHIFT), DMA_CINT_CINT_SHIFT, DMA_CINT_CINT_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CINT, field CAIR[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the INT bit specified in the CINT field
 * - 1 - Clear all bits in INT
 */
/*@{*/
/*! @brief Set the CAIR field to a new value. */
#define DMA_WR_CINT_CAIR(base, value) (DMA_RMW_CINT(base, DMA_CINT_CAIR_MASK, DMA_CINT_CAIR(value)))
#define DMA_BWR_CINT_CAIR(base, value) (BME_BFI8(&DMA_CINT_REG(base), ((uint8_t)(value) << DMA_CINT_CAIR_SHIFT), DMA_CINT_CAIR_SHIFT, DMA_CINT_CAIR_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CINT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CINT_NOP(base, value) (DMA_RMW_CINT(base, DMA_CINT_NOP_MASK, DMA_CINT_NOP(value)))
#define DMA_BWR_CINT_NOP(base, value) (BME_BFI8(&DMA_CINT_REG(base), ((uint8_t)(value) << DMA_CINT_NOP_SHIFT), DMA_CINT_NOP_SHIFT, DMA_CINT_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_INT - Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief DMA_INT - Interrupt Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The INT register provides a bit map for the 4 channels signaling the presence
 * of an interrupt request for each channel. Depending on the appropriate bit
 * setting in the transfer-control descriptors, the eDMA engine generates an
 * interrupt on data transfer completion. The outputs of this register are directly
 * routed to the interrupt controller (INTC). During the interrupt-service routine
 * associated with any given channel, it is the software's responsibility to clear
 * the appropriate bit, negating the interrupt request. Typically, a write to
 * the CINT register in the interrupt service routine is used for this purpose. The
 * state of any given channel's interrupt request is directly affected by writes
 * to this register; it is also affected by writes to the CINT register. On
 * writes to INT, a 1 in any bit position clears the corresponding channel's
 * interrupt request. A zero in any bit position has no affect on the corresponding
 * channel's current interrupt status. The CINT register is provided so the interrupt
 * request for a single channel can easily be cleared without the need to perform
 * a read-modify-write sequence to the INT register.
 */
/*!
 * @name Constants and macros for entire DMA_INT register
 */
/*@{*/
#define DMA_RD_INT(base)         (DMA_INT_REG(base))
#define DMA_WR_INT(base, value)  (DMA_INT_REG(base) = (value))
#define DMA_RMW_INT(base, mask, value) (DMA_WR_INT(base, (DMA_RD_INT(base) & ~(mask)) | (value)))
#define DMA_SET_INT(base, value) (BME_OR32(&DMA_INT_REG(base), (uint32_t)(value)))
#define DMA_CLR_INT(base, value) (BME_AND32(&DMA_INT_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_INT(base, value) (BME_XOR32(&DMA_INT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_INT bitfields
 */

/*!
 * @name Register DMA_INT, field INT0[0] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT0 field. */
#define DMA_RD_INT_INT0(base) ((DMA_INT_REG(base) & DMA_INT_INT0_MASK) >> DMA_INT_INT0_SHIFT)
#define DMA_BRD_INT_INT0(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT0_SHIFT, DMA_INT_INT0_WIDTH))

/*! @brief Set the INT0 field to a new value. */
#define DMA_WR_INT_INT0(base, value) (DMA_RMW_INT(base, (DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK), DMA_INT_INT0(value)))
#define DMA_BWR_INT_INT0(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT0_SHIFT), DMA_INT_INT0_SHIFT, DMA_INT_INT0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT1[1] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT1 field. */
#define DMA_RD_INT_INT1(base) ((DMA_INT_REG(base) & DMA_INT_INT1_MASK) >> DMA_INT_INT1_SHIFT)
#define DMA_BRD_INT_INT1(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT1_SHIFT, DMA_INT_INT1_WIDTH))

/*! @brief Set the INT1 field to a new value. */
#define DMA_WR_INT_INT1(base, value) (DMA_RMW_INT(base, (DMA_INT_INT1_MASK | DMA_INT_INT0_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK), DMA_INT_INT1(value)))
#define DMA_BWR_INT_INT1(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT1_SHIFT), DMA_INT_INT1_SHIFT, DMA_INT_INT1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT2[2] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT2 field. */
#define DMA_RD_INT_INT2(base) ((DMA_INT_REG(base) & DMA_INT_INT2_MASK) >> DMA_INT_INT2_SHIFT)
#define DMA_BRD_INT_INT2(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT2_SHIFT, DMA_INT_INT2_WIDTH))

/*! @brief Set the INT2 field to a new value. */
#define DMA_WR_INT_INT2(base, value) (DMA_RMW_INT(base, (DMA_INT_INT2_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT3_MASK), DMA_INT_INT2(value)))
#define DMA_BWR_INT_INT2(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT2_SHIFT), DMA_INT_INT2_SHIFT, DMA_INT_INT2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT3[3] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT3 field. */
#define DMA_RD_INT_INT3(base) ((DMA_INT_REG(base) & DMA_INT_INT3_MASK) >> DMA_INT_INT3_SHIFT)
#define DMA_BRD_INT_INT3(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT3_SHIFT, DMA_INT_INT3_WIDTH))

/*! @brief Set the INT3 field to a new value. */
#define DMA_WR_INT_INT3(base, value) (DMA_RMW_INT(base, (DMA_INT_INT3_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK), DMA_INT_INT3(value)))
#define DMA_BWR_INT_INT3(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT3_SHIFT), DMA_INT_INT3_SHIFT, DMA_INT_INT3_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_ERR - Error Register
 ******************************************************************************/

/*!
 * @brief DMA_ERR - Error Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERR provides a bit map for the 4 channels, signaling the presence of an
 * error for each channel. The eDMA engine signals the occurrence of an error
 * condition by setting the appropriate bit in this register. The outputs of this
 * register are enabled by the contents of the EEI, and then routed to the interrupt
 * controller. During the execution of the interrupt-service routine associated
 * with any DMA errors, it is software's responsibility to clear the appropriate
 * bit, negating the error-interrupt request. Typically, a write to the CERR in
 * the interrupt-service routine is used for this purpose. The normal DMA channel
 * completion indicators (setting the transfer control descriptor DONE flag and
 * the possible assertion of an interrupt request) are not affected when an error
 * is detected. The contents of this register can also be polled because a
 * non-zero value indicates the presence of a channel error regardless of the state of
 * the EEI. The state of any given channel's error indicators is affected by
 * writes to this register; it is also affected by writes to the CERR. On writes to
 * the ERR, a one in any bit position clears the corresponding channel's error
 * status. A zero in any bit position has no affect on the corresponding channel's
 * current error status. The CERR is provided so the error indicator for a single
 * channel can easily be cleared.
 */
/*!
 * @name Constants and macros for entire DMA_ERR register
 */
/*@{*/
#define DMA_RD_ERR(base)         (DMA_ERR_REG(base))
#define DMA_WR_ERR(base, value)  (DMA_ERR_REG(base) = (value))
#define DMA_RMW_ERR(base, mask, value) (DMA_WR_ERR(base, (DMA_RD_ERR(base) & ~(mask)) | (value)))
#define DMA_SET_ERR(base, value) (BME_OR32(&DMA_ERR_REG(base), (uint32_t)(value)))
#define DMA_CLR_ERR(base, value) (BME_AND32(&DMA_ERR_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_ERR(base, value) (BME_XOR32(&DMA_ERR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERR bitfields
 */

/*!
 * @name Register DMA_ERR, field ERR0[0] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR0 field. */
#define DMA_RD_ERR_ERR0(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR0_MASK) >> DMA_ERR_ERR0_SHIFT)
#define DMA_BRD_ERR_ERR0(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR0_SHIFT, DMA_ERR_ERR0_WIDTH))

/*! @brief Set the ERR0 field to a new value. */
#define DMA_WR_ERR_ERR0(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK), DMA_ERR_ERR0(value)))
#define DMA_BWR_ERR_ERR0(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR0_SHIFT), DMA_ERR_ERR0_SHIFT, DMA_ERR_ERR0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR1[1] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR1 field. */
#define DMA_RD_ERR_ERR1(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR1_MASK) >> DMA_ERR_ERR1_SHIFT)
#define DMA_BRD_ERR_ERR1(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR1_SHIFT, DMA_ERR_ERR1_WIDTH))

/*! @brief Set the ERR1 field to a new value. */
#define DMA_WR_ERR_ERR1(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR1_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK), DMA_ERR_ERR1(value)))
#define DMA_BWR_ERR_ERR1(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR1_SHIFT), DMA_ERR_ERR1_SHIFT, DMA_ERR_ERR1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR2[2] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR2 field. */
#define DMA_RD_ERR_ERR2(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR2_MASK) >> DMA_ERR_ERR2_SHIFT)
#define DMA_BRD_ERR_ERR2(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR2_SHIFT, DMA_ERR_ERR2_WIDTH))

/*! @brief Set the ERR2 field to a new value. */
#define DMA_WR_ERR_ERR2(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR2_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR3_MASK), DMA_ERR_ERR2(value)))
#define DMA_BWR_ERR_ERR2(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR2_SHIFT), DMA_ERR_ERR2_SHIFT, DMA_ERR_ERR2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR3[3] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR3 field. */
#define DMA_RD_ERR_ERR3(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR3_MASK) >> DMA_ERR_ERR3_SHIFT)
#define DMA_BRD_ERR_ERR3(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR3_SHIFT, DMA_ERR_ERR3_WIDTH))

/*! @brief Set the ERR3 field to a new value. */
#define DMA_WR_ERR_ERR3(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR3_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK), DMA_ERR_ERR3(value)))
#define DMA_BWR_ERR_ERR3(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR3_SHIFT), DMA_ERR_ERR3_SHIFT, DMA_ERR_ERR3_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_HRS - Hardware Request Status Register
 ******************************************************************************/

/*!
 * @brief DMA_HRS - Hardware Request Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The HRS register provides a bit map for the DMA channels, signaling the
 * presence of a hardware request for each channel. The hardware request status bits
 * reflect the current state of the register and qualified (via the ERQ fields)
 * DMA request signals as seen by the DMA's arbitration logic. This view into the
 * hardware request signals may be used for debug purposes. These bits reflect the
 * state of the request as seen by the arbitration logic. Therefore, this status
 * is affected by the ERQ bits.
 */
/*!
 * @name Constants and macros for entire DMA_HRS register
 */
/*@{*/
#define DMA_RD_HRS(base)         (DMA_HRS_REG(base))
/*@}*/

/*
 * Constants & macros for individual DMA_HRS bitfields
 */

/*!
 * @name Register DMA_HRS, field HRS0[0] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 0 is not present
 * - 1 - A hardware service request for channel 0 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS0 field. */
#define DMA_RD_HRS_HRS0(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS0_MASK) >> DMA_HRS_HRS0_SHIFT)
#define DMA_BRD_HRS_HRS0(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS0_SHIFT, DMA_HRS_HRS0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS1[1] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 1 is not present
 * - 1 - A hardware service request for channel 1 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS1 field. */
#define DMA_RD_HRS_HRS1(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS1_MASK) >> DMA_HRS_HRS1_SHIFT)
#define DMA_BRD_HRS_HRS1(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS1_SHIFT, DMA_HRS_HRS1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS2[2] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 2 is not present
 * - 1 - A hardware service request for channel 2 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS2 field. */
#define DMA_RD_HRS_HRS2(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS2_MASK) >> DMA_HRS_HRS2_SHIFT)
#define DMA_BRD_HRS_HRS2(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS2_SHIFT, DMA_HRS_HRS2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS3[3] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 3 is not present
 * - 1 - A hardware service request for channel 3 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS3 field. */
#define DMA_RD_HRS_HRS3(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS3_MASK) >> DMA_HRS_HRS3_SHIFT)
#define DMA_BRD_HRS_HRS3(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS3_SHIFT, DMA_HRS_HRS3_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_EARS - Enable Asynchronous Request in Stop Register
 ******************************************************************************/

/*!
 * @brief DMA_EARS - Enable Asynchronous Request in Stop Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_EARS register
 */
/*@{*/
#define DMA_RD_EARS(base)        (DMA_EARS_REG(base))
#define DMA_WR_EARS(base, value) (DMA_EARS_REG(base) = (value))
#define DMA_RMW_EARS(base, mask, value) (DMA_WR_EARS(base, (DMA_RD_EARS(base) & ~(mask)) | (value)))
#define DMA_SET_EARS(base, value) (BME_OR32(&DMA_EARS_REG(base), (uint32_t)(value)))
#define DMA_CLR_EARS(base, value) (BME_AND32(&DMA_EARS_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_EARS(base, value) (BME_XOR32(&DMA_EARS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_EARS bitfields
 */

/*!
 * @name Register DMA_EARS, field EDREQ_0[0] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 0.
 * - 1 - Enable asynchronous DMA request for channel 0.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_0 field. */
#define DMA_RD_EARS_EDREQ_0(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_0_MASK) >> DMA_EARS_EDREQ_0_SHIFT)
#define DMA_BRD_EARS_EDREQ_0(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_0_SHIFT, DMA_EARS_EDREQ_0_WIDTH))

/*! @brief Set the EDREQ_0 field to a new value. */
#define DMA_WR_EARS_EDREQ_0(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_0_MASK, DMA_EARS_EDREQ_0(value)))
#define DMA_BWR_EARS_EDREQ_0(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_0_SHIFT), DMA_EARS_EDREQ_0_SHIFT, DMA_EARS_EDREQ_0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_1[1] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 1
 * - 1 - Enable asynchronous DMA request for channel 1.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_1 field. */
#define DMA_RD_EARS_EDREQ_1(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_1_MASK) >> DMA_EARS_EDREQ_1_SHIFT)
#define DMA_BRD_EARS_EDREQ_1(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_1_SHIFT, DMA_EARS_EDREQ_1_WIDTH))

/*! @brief Set the EDREQ_1 field to a new value. */
#define DMA_WR_EARS_EDREQ_1(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_1_MASK, DMA_EARS_EDREQ_1(value)))
#define DMA_BWR_EARS_EDREQ_1(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_1_SHIFT), DMA_EARS_EDREQ_1_SHIFT, DMA_EARS_EDREQ_1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_2[2] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 2.
 * - 1 - Enable asynchronous DMA request for channel 2.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_2 field. */
#define DMA_RD_EARS_EDREQ_2(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_2_MASK) >> DMA_EARS_EDREQ_2_SHIFT)
#define DMA_BRD_EARS_EDREQ_2(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_2_SHIFT, DMA_EARS_EDREQ_2_WIDTH))

/*! @brief Set the EDREQ_2 field to a new value. */
#define DMA_WR_EARS_EDREQ_2(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_2_MASK, DMA_EARS_EDREQ_2(value)))
#define DMA_BWR_EARS_EDREQ_2(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_2_SHIFT), DMA_EARS_EDREQ_2_SHIFT, DMA_EARS_EDREQ_2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_3[3] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 3.
 * - 1 - Enable asynchronous DMA request for channel 3.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_3 field. */
#define DMA_RD_EARS_EDREQ_3(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_3_MASK) >> DMA_EARS_EDREQ_3_SHIFT)
#define DMA_BRD_EARS_EDREQ_3(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_3_SHIFT, DMA_EARS_EDREQ_3_WIDTH))

/*! @brief Set the EDREQ_3 field to a new value. */
#define DMA_WR_EARS_EDREQ_3(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_3_MASK, DMA_EARS_EDREQ_3(value)))
#define DMA_BWR_EARS_EDREQ_3(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_3_SHIFT), DMA_EARS_EDREQ_3_SHIFT, DMA_EARS_EDREQ_3_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI3 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI3 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 3.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI3 register
 */
/*@{*/
#define DMA_RD_DCHPRI3(base)     (DMA_DCHPRI3_REG(base))
#define DMA_WR_DCHPRI3(base, value) (DMA_DCHPRI3_REG(base) = (value))
#define DMA_RMW_DCHPRI3(base, mask, value) (DMA_WR_DCHPRI3(base, (DMA_RD_DCHPRI3(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI3(base, value) (BME_OR8(&DMA_DCHPRI3_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI3(base, value) (BME_AND8(&DMA_DCHPRI3_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI3(base, value) (BME_XOR8(&DMA_DCHPRI3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI3 bitfields
 */

/*!
 * @name Register DMA_DCHPRI3, field CHPRI[1:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI3[CHPRI] = 0b11.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_CHPRI field. */
#define DMA_RD_DCHPRI3_CHPRI(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_CHPRI_MASK) >> DMA_DCHPRI3_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI3_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_CHPRI_SHIFT, DMA_DCHPRI3_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI3_CHPRI(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_CHPRI_MASK, DMA_DCHPRI3_CHPRI(value)))
#define DMA_BWR_DCHPRI3_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI3_REG(base), ((uint8_t)(value) << DMA_DCHPRI3_CHPRI_SHIFT), DMA_DCHPRI3_CHPRI_SHIFT, DMA_DCHPRI3_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI3, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_DPA field. */
#define DMA_RD_DCHPRI3_DPA(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_DPA_MASK) >> DMA_DCHPRI3_DPA_SHIFT)
#define DMA_BRD_DCHPRI3_DPA(base) (BME_UBFX8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_DPA_SHIFT, DMA_DCHPRI3_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI3_DPA(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_DPA_MASK, DMA_DCHPRI3_DPA(value)))
#define DMA_BWR_DCHPRI3_DPA(base, value) (BME_BFI8(&DMA_DCHPRI3_REG(base), ((uint8_t)(value) << DMA_DCHPRI3_DPA_SHIFT), DMA_DCHPRI3_DPA_SHIFT, DMA_DCHPRI3_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI3, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_ECP field. */
#define DMA_RD_DCHPRI3_ECP(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_ECP_MASK) >> DMA_DCHPRI3_ECP_SHIFT)
#define DMA_BRD_DCHPRI3_ECP(base) (BME_UBFX8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_ECP_SHIFT, DMA_DCHPRI3_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI3_ECP(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_ECP_MASK, DMA_DCHPRI3_ECP(value)))
#define DMA_BWR_DCHPRI3_ECP(base, value) (BME_BFI8(&DMA_DCHPRI3_REG(base), ((uint8_t)(value) << DMA_DCHPRI3_ECP_SHIFT), DMA_DCHPRI3_ECP_SHIFT, DMA_DCHPRI3_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI2 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI2 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 3.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI2 register
 */
/*@{*/
#define DMA_RD_DCHPRI2(base)     (DMA_DCHPRI2_REG(base))
#define DMA_WR_DCHPRI2(base, value) (DMA_DCHPRI2_REG(base) = (value))
#define DMA_RMW_DCHPRI2(base, mask, value) (DMA_WR_DCHPRI2(base, (DMA_RD_DCHPRI2(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI2(base, value) (BME_OR8(&DMA_DCHPRI2_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI2(base, value) (BME_AND8(&DMA_DCHPRI2_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI2(base, value) (BME_XOR8(&DMA_DCHPRI2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI2 bitfields
 */

/*!
 * @name Register DMA_DCHPRI2, field CHPRI[1:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI3[CHPRI] = 0b11.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_CHPRI field. */
#define DMA_RD_DCHPRI2_CHPRI(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_CHPRI_MASK) >> DMA_DCHPRI2_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI2_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_CHPRI_SHIFT, DMA_DCHPRI2_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI2_CHPRI(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_CHPRI_MASK, DMA_DCHPRI2_CHPRI(value)))
#define DMA_BWR_DCHPRI2_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI2_REG(base), ((uint8_t)(value) << DMA_DCHPRI2_CHPRI_SHIFT), DMA_DCHPRI2_CHPRI_SHIFT, DMA_DCHPRI2_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI2, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_DPA field. */
#define DMA_RD_DCHPRI2_DPA(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_DPA_MASK) >> DMA_DCHPRI2_DPA_SHIFT)
#define DMA_BRD_DCHPRI2_DPA(base) (BME_UBFX8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_DPA_SHIFT, DMA_DCHPRI2_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI2_DPA(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_DPA_MASK, DMA_DCHPRI2_DPA(value)))
#define DMA_BWR_DCHPRI2_DPA(base, value) (BME_BFI8(&DMA_DCHPRI2_REG(base), ((uint8_t)(value) << DMA_DCHPRI2_DPA_SHIFT), DMA_DCHPRI2_DPA_SHIFT, DMA_DCHPRI2_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI2, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_ECP field. */
#define DMA_RD_DCHPRI2_ECP(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_ECP_MASK) >> DMA_DCHPRI2_ECP_SHIFT)
#define DMA_BRD_DCHPRI2_ECP(base) (BME_UBFX8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_ECP_SHIFT, DMA_DCHPRI2_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI2_ECP(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_ECP_MASK, DMA_DCHPRI2_ECP(value)))
#define DMA_BWR_DCHPRI2_ECP(base, value) (BME_BFI8(&DMA_DCHPRI2_REG(base), ((uint8_t)(value) << DMA_DCHPRI2_ECP_SHIFT), DMA_DCHPRI2_ECP_SHIFT, DMA_DCHPRI2_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI1 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI1 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 3.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI1 register
 */
/*@{*/
#define DMA_RD_DCHPRI1(base)     (DMA_DCHPRI1_REG(base))
#define DMA_WR_DCHPRI1(base, value) (DMA_DCHPRI1_REG(base) = (value))
#define DMA_RMW_DCHPRI1(base, mask, value) (DMA_WR_DCHPRI1(base, (DMA_RD_DCHPRI1(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI1(base, value) (BME_OR8(&DMA_DCHPRI1_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI1(base, value) (BME_AND8(&DMA_DCHPRI1_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI1(base, value) (BME_XOR8(&DMA_DCHPRI1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI1 bitfields
 */

/*!
 * @name Register DMA_DCHPRI1, field CHPRI[1:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI3[CHPRI] = 0b11.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_CHPRI field. */
#define DMA_RD_DCHPRI1_CHPRI(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_CHPRI_MASK) >> DMA_DCHPRI1_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI1_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_CHPRI_SHIFT, DMA_DCHPRI1_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI1_CHPRI(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_CHPRI_MASK, DMA_DCHPRI1_CHPRI(value)))
#define DMA_BWR_DCHPRI1_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI1_REG(base), ((uint8_t)(value) << DMA_DCHPRI1_CHPRI_SHIFT), DMA_DCHPRI1_CHPRI_SHIFT, DMA_DCHPRI1_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI1, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_DPA field. */
#define DMA_RD_DCHPRI1_DPA(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_DPA_MASK) >> DMA_DCHPRI1_DPA_SHIFT)
#define DMA_BRD_DCHPRI1_DPA(base) (BME_UBFX8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_DPA_SHIFT, DMA_DCHPRI1_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI1_DPA(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_DPA_MASK, DMA_DCHPRI1_DPA(value)))
#define DMA_BWR_DCHPRI1_DPA(base, value) (BME_BFI8(&DMA_DCHPRI1_REG(base), ((uint8_t)(value) << DMA_DCHPRI1_DPA_SHIFT), DMA_DCHPRI1_DPA_SHIFT, DMA_DCHPRI1_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI1, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_ECP field. */
#define DMA_RD_DCHPRI1_ECP(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_ECP_MASK) >> DMA_DCHPRI1_ECP_SHIFT)
#define DMA_BRD_DCHPRI1_ECP(base) (BME_UBFX8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_ECP_SHIFT, DMA_DCHPRI1_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI1_ECP(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_ECP_MASK, DMA_DCHPRI1_ECP(value)))
#define DMA_BWR_DCHPRI1_ECP(base, value) (BME_BFI8(&DMA_DCHPRI1_REG(base), ((uint8_t)(value) << DMA_DCHPRI1_ECP_SHIFT), DMA_DCHPRI1_ECP_SHIFT, DMA_DCHPRI1_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI0 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI0 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 3.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI0 register
 */
/*@{*/
#define DMA_RD_DCHPRI0(base)     (DMA_DCHPRI0_REG(base))
#define DMA_WR_DCHPRI0(base, value) (DMA_DCHPRI0_REG(base) = (value))
#define DMA_RMW_DCHPRI0(base, mask, value) (DMA_WR_DCHPRI0(base, (DMA_RD_DCHPRI0(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI0(base, value) (BME_OR8(&DMA_DCHPRI0_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI0(base, value) (BME_AND8(&DMA_DCHPRI0_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI0(base, value) (BME_XOR8(&DMA_DCHPRI0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI0 bitfields
 */

/*!
 * @name Register DMA_DCHPRI0, field CHPRI[1:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI3[CHPRI] = 0b11.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_CHPRI field. */
#define DMA_RD_DCHPRI0_CHPRI(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_CHPRI_MASK) >> DMA_DCHPRI0_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI0_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_CHPRI_SHIFT, DMA_DCHPRI0_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI0_CHPRI(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_CHPRI_MASK, DMA_DCHPRI0_CHPRI(value)))
#define DMA_BWR_DCHPRI0_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI0_REG(base), ((uint8_t)(value) << DMA_DCHPRI0_CHPRI_SHIFT), DMA_DCHPRI0_CHPRI_SHIFT, DMA_DCHPRI0_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI0, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_DPA field. */
#define DMA_RD_DCHPRI0_DPA(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_DPA_MASK) >> DMA_DCHPRI0_DPA_SHIFT)
#define DMA_BRD_DCHPRI0_DPA(base) (BME_UBFX8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_DPA_SHIFT, DMA_DCHPRI0_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI0_DPA(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_DPA_MASK, DMA_DCHPRI0_DPA(value)))
#define DMA_BWR_DCHPRI0_DPA(base, value) (BME_BFI8(&DMA_DCHPRI0_REG(base), ((uint8_t)(value) << DMA_DCHPRI0_DPA_SHIFT), DMA_DCHPRI0_DPA_SHIFT, DMA_DCHPRI0_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI0, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_ECP field. */
#define DMA_RD_DCHPRI0_ECP(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_ECP_MASK) >> DMA_DCHPRI0_ECP_SHIFT)
#define DMA_BRD_DCHPRI0_ECP(base) (BME_UBFX8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_ECP_SHIFT, DMA_DCHPRI0_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI0_ECP(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_ECP_MASK, DMA_DCHPRI0_ECP(value)))
#define DMA_BWR_DCHPRI0_ECP(base, value) (BME_BFI8(&DMA_DCHPRI0_REG(base), ((uint8_t)(value) << DMA_DCHPRI0_ECP_SHIFT), DMA_DCHPRI0_ECP_SHIFT, DMA_DCHPRI0_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_SADDR register
 */
/*@{*/
#define DMA_RD_SADDR(base, index) (DMA_SADDR_REG(base, index))
#define DMA_WR_SADDR(base, index, value) (DMA_SADDR_REG(base, index) = (value))
#define DMA_RMW_SADDR(base, index, mask, value) (DMA_WR_SADDR(base, index, (DMA_RD_SADDR(base, index) & ~(mask)) | (value)))
#define DMA_SET_SADDR(base, index, value) (BME_OR32(&DMA_SADDR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_SADDR(base, index, value) (BME_AND32(&DMA_SADDR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_SADDR(base, index, value) (BME_XOR32(&DMA_SADDR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_SOFF register
 */
/*@{*/
#define DMA_RD_SOFF(base, index) (DMA_SOFF_REG(base, index))
#define DMA_WR_SOFF(base, index, value) (DMA_SOFF_REG(base, index) = (value))
#define DMA_RMW_SOFF(base, index, mask, value) (DMA_WR_SOFF(base, index, (DMA_RD_SOFF(base, index) & ~(mask)) | (value)))
#define DMA_SET_SOFF(base, index, value) (BME_OR16(&DMA_SOFF_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_SOFF(base, index, value) (BME_AND16(&DMA_SOFF_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_SOFF(base, index, value) (BME_XOR16(&DMA_SOFF_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_ATTR register
 */
/*@{*/
#define DMA_RD_ATTR(base, index) (DMA_ATTR_REG(base, index))
#define DMA_WR_ATTR(base, index, value) (DMA_ATTR_REG(base, index) = (value))
#define DMA_RMW_ATTR(base, index, mask, value) (DMA_WR_ATTR(base, index, (DMA_RD_ATTR(base, index) & ~(mask)) | (value)))
#define DMA_SET_ATTR(base, index, value) (BME_OR16(&DMA_ATTR_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_ATTR(base, index, value) (BME_AND16(&DMA_ATTR_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_ATTR(base, index, value) (BME_XOR16(&DMA_ATTR_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ATTR bitfields
 */

/*!
 * @name Register DMA_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_DSIZE field. */
#define DMA_RD_ATTR_DSIZE(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_DSIZE_MASK) >> DMA_ATTR_DSIZE_SHIFT)
#define DMA_BRD_ATTR_DSIZE(base, index) (BME_UBFX16(&DMA_ATTR_REG(base, index), DMA_ATTR_DSIZE_SHIFT, DMA_ATTR_DSIZE_WIDTH))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_ATTR_DSIZE(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_DSIZE_MASK, DMA_ATTR_DSIZE(value)))
#define DMA_BWR_ATTR_DSIZE(base, index, value) (BME_BFI16(&DMA_ATTR_REG(base, index), ((uint16_t)(value) << DMA_ATTR_DSIZE_SHIFT), DMA_ATTR_DSIZE_SHIFT, DMA_ATTR_DSIZE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_DMOD field. */
#define DMA_RD_ATTR_DMOD(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_DMOD_MASK) >> DMA_ATTR_DMOD_SHIFT)
#define DMA_BRD_ATTR_DMOD(base, index) (BME_UBFX16(&DMA_ATTR_REG(base, index), DMA_ATTR_DMOD_SHIFT, DMA_ATTR_DMOD_WIDTH))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_ATTR_DMOD(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_DMOD_MASK, DMA_ATTR_DMOD(value)))
#define DMA_BWR_ATTR_DMOD(base, index, value) (BME_BFI16(&DMA_ATTR_REG(base, index), ((uint16_t)(value) << DMA_ATTR_DMOD_SHIFT), DMA_ATTR_DMOD_SHIFT, DMA_ATTR_DMOD_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte burst
 * - 101 - 32-byte burst
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_SSIZE field. */
#define DMA_RD_ATTR_SSIZE(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_SSIZE_MASK) >> DMA_ATTR_SSIZE_SHIFT)
#define DMA_BRD_ATTR_SSIZE(base, index) (BME_UBFX16(&DMA_ATTR_REG(base, index), DMA_ATTR_SSIZE_SHIFT, DMA_ATTR_SSIZE_WIDTH))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_ATTR_SSIZE(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_SSIZE_MASK, DMA_ATTR_SSIZE(value)))
#define DMA_BWR_ATTR_SSIZE(base, index, value) (BME_BFI16(&DMA_ATTR_REG(base, index), ((uint16_t)(value) << DMA_ATTR_SSIZE_SHIFT), DMA_ATTR_SSIZE_SHIFT, DMA_ATTR_SSIZE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_SMOD field. */
#define DMA_RD_ATTR_SMOD(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_SMOD_MASK) >> DMA_ATTR_SMOD_SHIFT)
#define DMA_BRD_ATTR_SMOD(base, index) (BME_UBFX16(&DMA_ATTR_REG(base, index), DMA_ATTR_SMOD_SHIFT, DMA_ATTR_SMOD_WIDTH))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_ATTR_SMOD(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_SMOD_MASK, DMA_ATTR_SMOD(value)))
#define DMA_BWR_ATTR_SMOD(base, index, value) (BME_BFI16(&DMA_ATTR_REG(base, index), ((uint16_t)(value) << DMA_ATTR_SMOD_SHIFT), DMA_ATTR_SMOD_SHIFT, DMA_ATTR_SMOD_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_NBYTES_MLOFFNO(base, index) (DMA_NBYTES_MLOFFNO_REG(base, index))
#define DMA_WR_NBYTES_MLOFFNO(base, index, value) (DMA_NBYTES_MLOFFNO_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLOFFNO(base, index, mask, value) (DMA_WR_NBYTES_MLOFFNO(base, index, (DMA_RD_NBYTES_MLOFFNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLOFFNO(base, index, value) (BME_OR32(&DMA_NBYTES_MLOFFNO_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_NBYTES_MLOFFNO(base, index, value) (BME_AND32(&DMA_NBYTES_MLOFFNO_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_NBYTES_MLOFFNO(base, index, value) (BME_XOR32(&DMA_NBYTES_MLOFFNO_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_NBYTES_MLOFFNO_NBYTES(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_NBYTES(base, index) (DMA_RD_NBYTES_MLOFFNO_NBYTES(base, index))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_NBYTES(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_NBYTES_MASK, DMA_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_NBYTES_MLOFFNO_NBYTES(base, index, value) (DMA_WR_NBYTES_MLOFFNO_NBYTES(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_NBYTES_MLOFFNO_DMLOE(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_DMLOE(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_DMLOE_SHIFT, DMA_NBYTES_MLOFFNO_DMLOE_WIDTH))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_DMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_DMLOE_MASK, DMA_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFNO_DMLOE(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFNO_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFNO_DMLOE_SHIFT), DMA_NBYTES_MLOFFNO_DMLOE_SHIFT, DMA_NBYTES_MLOFFNO_DMLOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_NBYTES_MLOFFNO_SMLOE(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_SMLOE(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_SMLOE_SHIFT, DMA_NBYTES_MLOFFNO_SMLOE_WIDTH))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_SMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_SMLOE_MASK, DMA_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFNO_SMLOE(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFNO_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFNO_SMLOE_SHIFT), DMA_NBYTES_MLOFFNO_SMLOE_SHIFT, DMA_NBYTES_MLOFFNO_SMLOE_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_NBYTES_MLNO(base, index) (DMA_NBYTES_MLNO_REG(base, index))
#define DMA_WR_NBYTES_MLNO(base, index, value) (DMA_NBYTES_MLNO_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLNO(base, index, mask, value) (DMA_WR_NBYTES_MLNO(base, index, (DMA_RD_NBYTES_MLNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLNO(base, index, value) (BME_OR32(&DMA_NBYTES_MLNO_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_NBYTES_MLNO(base, index, value) (BME_AND32(&DMA_NBYTES_MLNO_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_NBYTES_MLNO(base, index, value) (BME_XOR32(&DMA_NBYTES_MLNO_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_NBYTES_MLOFFYES(base, index) (DMA_NBYTES_MLOFFYES_REG(base, index))
#define DMA_WR_NBYTES_MLOFFYES(base, index, value) (DMA_NBYTES_MLOFFYES_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLOFFYES(base, index, mask, value) (DMA_WR_NBYTES_MLOFFYES(base, index, (DMA_RD_NBYTES_MLOFFYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLOFFYES(base, index, value) (BME_OR32(&DMA_NBYTES_MLOFFYES_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_NBYTES_MLOFFYES(base, index, value) (BME_AND32(&DMA_NBYTES_MLOFFYES_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_NBYTES_MLOFFYES(base, index, value) (BME_XOR32(&DMA_NBYTES_MLOFFYES_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_NBYTES_MLOFFYES_NBYTES(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_NBYTES(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_NBYTES_SHIFT, DMA_NBYTES_MLOFFYES_NBYTES_WIDTH))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_NBYTES(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_NBYTES_MASK, DMA_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_NBYTES_MLOFFYES_NBYTES(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFYES_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFYES_NBYTES_SHIFT), DMA_NBYTES_MLOFFYES_NBYTES_SHIFT, DMA_NBYTES_MLOFFYES_NBYTES_WIDTH))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_NBYTES_MLOFFYES_MLOFF(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_MLOFF(base, index) (DMA_RD_NBYTES_MLOFFYES_MLOFF(base, index))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_MLOFF(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_MLOFF_MASK, DMA_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_NBYTES_MLOFFYES_MLOFF(base, index, value) (DMA_WR_NBYTES_MLOFFYES_MLOFF(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_NBYTES_MLOFFYES_DMLOE(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_DMLOE(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_DMLOE_SHIFT, DMA_NBYTES_MLOFFYES_DMLOE_WIDTH))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_DMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_DMLOE_MASK, DMA_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFYES_DMLOE(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFYES_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFYES_DMLOE_SHIFT), DMA_NBYTES_MLOFFYES_DMLOE_SHIFT, DMA_NBYTES_MLOFFYES_DMLOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_NBYTES_MLOFFYES_SMLOE(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_SMLOE(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_SMLOE_SHIFT, DMA_NBYTES_MLOFFYES_SMLOE_WIDTH))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_SMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_SMLOE_MASK, DMA_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFYES_SMLOE(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFYES_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFYES_SMLOE_SHIFT), DMA_NBYTES_MLOFFYES_SMLOE_SHIFT, DMA_NBYTES_MLOFFYES_SMLOE_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_SLAST register
 */
/*@{*/
#define DMA_RD_SLAST(base, index) (DMA_SLAST_REG(base, index))
#define DMA_WR_SLAST(base, index, value) (DMA_SLAST_REG(base, index) = (value))
#define DMA_RMW_SLAST(base, index, mask, value) (DMA_WR_SLAST(base, index, (DMA_RD_SLAST(base, index) & ~(mask)) | (value)))
#define DMA_SET_SLAST(base, index, value) (BME_OR32(&DMA_SLAST_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_SLAST(base, index, value) (BME_AND32(&DMA_SLAST_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_SLAST(base, index, value) (BME_XOR32(&DMA_SLAST_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_DADDR register
 */
/*@{*/
#define DMA_RD_DADDR(base, index) (DMA_DADDR_REG(base, index))
#define DMA_WR_DADDR(base, index, value) (DMA_DADDR_REG(base, index) = (value))
#define DMA_RMW_DADDR(base, index, mask, value) (DMA_WR_DADDR(base, index, (DMA_RD_DADDR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DADDR(base, index, value) (BME_OR32(&DMA_DADDR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_DADDR(base, index, value) (BME_AND32(&DMA_DADDR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_DADDR(base, index, value) (BME_XOR32(&DMA_DADDR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_DOFF register
 */
/*@{*/
#define DMA_RD_DOFF(base, index) (DMA_DOFF_REG(base, index))
#define DMA_WR_DOFF(base, index, value) (DMA_DOFF_REG(base, index) = (value))
#define DMA_RMW_DOFF(base, index, mask, value) (DMA_WR_DOFF(base, index, (DMA_RD_DOFF(base, index) & ~(mask)) | (value)))
#define DMA_SET_DOFF(base, index, value) (BME_OR16(&DMA_DOFF_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_DOFF(base, index, value) (BME_AND16(&DMA_DOFF_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_DOFF(base, index, value) (BME_XOR16(&DMA_DOFF_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_CITER_ELINKYES(base, index) (DMA_CITER_ELINKYES_REG(base, index))
#define DMA_WR_CITER_ELINKYES(base, index, value) (DMA_CITER_ELINKYES_REG(base, index) = (value))
#define DMA_RMW_CITER_ELINKYES(base, index, mask, value) (DMA_WR_CITER_ELINKYES(base, index, (DMA_RD_CITER_ELINKYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_CITER_ELINKYES(base, index, value) (BME_OR16(&DMA_CITER_ELINKYES_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_CITER_ELINKYES(base, index, value) (BME_AND16(&DMA_CITER_ELINKYES_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_CITER_ELINKYES(base, index, value) (BME_XOR16(&DMA_CITER_ELINKYES_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_CITER field. */
#define DMA_RD_CITER_ELINKYES_CITER(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_CITER_MASK) >> DMA_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_CITER_ELINKYES_CITER(base, index) (BME_UBFX16(&DMA_CITER_ELINKYES_REG(base, index), DMA_CITER_ELINKYES_CITER_SHIFT, DMA_CITER_ELINKYES_CITER_WIDTH))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_CITER_ELINKYES_CITER(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_CITER_MASK, DMA_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_CITER_ELINKYES_CITER(base, index, value) (BME_BFI16(&DMA_CITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_CITER_ELINKYES_CITER_SHIFT), DMA_CITER_ELINKYES_CITER_SHIFT, DMA_CITER_ELINKYES_CITER_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKYES, field LINKCH[10:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_CITER_ELINKYES_LINKCH(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_LINKCH_MASK) >> DMA_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_CITER_ELINKYES_LINKCH(base, index) (BME_UBFX16(&DMA_CITER_ELINKYES_REG(base, index), DMA_CITER_ELINKYES_LINKCH_SHIFT, DMA_CITER_ELINKYES_LINKCH_WIDTH))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_CITER_ELINKYES_LINKCH(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_LINKCH_MASK, DMA_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_CITER_ELINKYES_LINKCH(base, index, value) (BME_BFI16(&DMA_CITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_CITER_ELINKYES_LINKCH_SHIFT), DMA_CITER_ELINKYES_LINKCH_SHIFT, DMA_CITER_ELINKYES_LINKCH_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_ELINK field. */
#define DMA_RD_CITER_ELINKYES_ELINK(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_ELINK_MASK) >> DMA_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_CITER_ELINKYES_ELINK(base, index) (BME_UBFX16(&DMA_CITER_ELINKYES_REG(base, index), DMA_CITER_ELINKYES_ELINK_SHIFT, DMA_CITER_ELINKYES_ELINK_WIDTH))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_CITER_ELINKYES_ELINK(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_ELINK_MASK, DMA_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_CITER_ELINKYES_ELINK(base, index, value) (BME_BFI16(&DMA_CITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_CITER_ELINKYES_ELINK_SHIFT), DMA_CITER_ELINKYES_ELINK_SHIFT, DMA_CITER_ELINKYES_ELINK_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_CITER_ELINKNO(base, index) (DMA_CITER_ELINKNO_REG(base, index))
#define DMA_WR_CITER_ELINKNO(base, index, value) (DMA_CITER_ELINKNO_REG(base, index) = (value))
#define DMA_RMW_CITER_ELINKNO(base, index, mask, value) (DMA_WR_CITER_ELINKNO(base, index, (DMA_RD_CITER_ELINKNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_CITER_ELINKNO(base, index, value) (BME_OR16(&DMA_CITER_ELINKNO_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_CITER_ELINKNO(base, index, value) (BME_AND16(&DMA_CITER_ELINKNO_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_CITER_ELINKNO(base, index, value) (BME_XOR16(&DMA_CITER_ELINKNO_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKNO_CITER field. */
#define DMA_RD_CITER_ELINKNO_CITER(base, index) ((DMA_CITER_ELINKNO_REG(base, index) & DMA_CITER_ELINKNO_CITER_MASK) >> DMA_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_CITER_ELINKNO_CITER(base, index) (BME_UBFX16(&DMA_CITER_ELINKNO_REG(base, index), DMA_CITER_ELINKNO_CITER_SHIFT, DMA_CITER_ELINKNO_CITER_WIDTH))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_CITER_ELINKNO_CITER(base, index, value) (DMA_RMW_CITER_ELINKNO(base, index, DMA_CITER_ELINKNO_CITER_MASK, DMA_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_CITER_ELINKNO_CITER(base, index, value) (BME_BFI16(&DMA_CITER_ELINKNO_REG(base, index), ((uint16_t)(value) << DMA_CITER_ELINKNO_CITER_SHIFT), DMA_CITER_ELINKNO_CITER_SHIFT, DMA_CITER_ELINKNO_CITER_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKNO_ELINK field. */
#define DMA_RD_CITER_ELINKNO_ELINK(base, index) ((DMA_CITER_ELINKNO_REG(base, index) & DMA_CITER_ELINKNO_ELINK_MASK) >> DMA_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_CITER_ELINKNO_ELINK(base, index) (BME_UBFX16(&DMA_CITER_ELINKNO_REG(base, index), DMA_CITER_ELINKNO_ELINK_SHIFT, DMA_CITER_ELINKNO_ELINK_WIDTH))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_CITER_ELINKNO_ELINK(base, index, value) (DMA_RMW_CITER_ELINKNO(base, index, DMA_CITER_ELINKNO_ELINK_MASK, DMA_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_CITER_ELINKNO_ELINK(base, index, value) (BME_BFI16(&DMA_CITER_ELINKNO_REG(base, index), ((uint16_t)(value) << DMA_CITER_ELINKNO_ELINK_SHIFT), DMA_CITER_ELINKNO_ELINK_SHIFT, DMA_CITER_ELINKNO_ELINK_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_DLAST_SGA register
 */
/*@{*/
#define DMA_RD_DLAST_SGA(base, index) (DMA_DLAST_SGA_REG(base, index))
#define DMA_WR_DLAST_SGA(base, index, value) (DMA_DLAST_SGA_REG(base, index) = (value))
#define DMA_RMW_DLAST_SGA(base, index, mask, value) (DMA_WR_DLAST_SGA(base, index, (DMA_RD_DLAST_SGA(base, index) & ~(mask)) | (value)))
#define DMA_SET_DLAST_SGA(base, index, value) (BME_OR32(&DMA_DLAST_SGA_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_DLAST_SGA(base, index, value) (BME_AND32(&DMA_DLAST_SGA_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_DLAST_SGA(base, index, value) (BME_XOR32(&DMA_DLAST_SGA_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_CSR register
 */
/*@{*/
#define DMA_RD_CSR(base, index)  (DMA_CSR_REG(base, index))
#define DMA_WR_CSR(base, index, value) (DMA_CSR_REG(base, index) = (value))
#define DMA_RMW_CSR(base, index, mask, value) (DMA_WR_CSR(base, index, (DMA_RD_CSR(base, index) & ~(mask)) | (value)))
#define DMA_SET_CSR(base, index, value) (BME_OR16(&DMA_CSR_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_CSR(base, index, value) (BME_AND16(&DMA_CSR_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_CSR(base, index, value) (BME_XOR16(&DMA_CSR_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CSR bitfields
 */

/*!
 * @name Register DMA_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0 - The channel is not explicitly started.
 * - 1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_START field. */
#define DMA_RD_CSR_START(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_START_MASK) >> DMA_CSR_START_SHIFT)
#define DMA_BRD_CSR_START(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_START_SHIFT, DMA_CSR_START_WIDTH))

/*! @brief Set the START field to a new value. */
#define DMA_WR_CSR_START(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_START_MASK, DMA_CSR_START(value)))
#define DMA_BWR_CSR_START(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_START_SHIFT), DMA_CSR_START_SHIFT, DMA_CSR_START_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled.
 * - 1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_INTMAJOR field. */
#define DMA_RD_CSR_INTMAJOR(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_INTMAJOR_MASK) >> DMA_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_CSR_INTMAJOR(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_INTMAJOR_SHIFT, DMA_CSR_INTMAJOR_WIDTH))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_CSR_INTMAJOR(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_INTMAJOR_MASK, DMA_CSR_INTMAJOR(value)))
#define DMA_BWR_CSR_INTMAJOR(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_INTMAJOR_SHIFT), DMA_CSR_INTMAJOR_SHIFT, DMA_CSR_INTMAJOR_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled.
 * - 1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_INTHALF field. */
#define DMA_RD_CSR_INTHALF(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_INTHALF_MASK) >> DMA_CSR_INTHALF_SHIFT)
#define DMA_BRD_CSR_INTHALF(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_INTHALF_SHIFT, DMA_CSR_INTHALF_WIDTH))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_CSR_INTHALF(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_INTHALF_MASK, DMA_CSR_INTHALF(value)))
#define DMA_BWR_CSR_INTHALF(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_INTHALF_SHIFT), DMA_CSR_INTHALF_SHIFT, DMA_CSR_INTHALF_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channel's ERQ bit is not affected.
 * - 1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_DREQ field. */
#define DMA_RD_CSR_DREQ(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_DREQ_MASK) >> DMA_CSR_DREQ_SHIFT)
#define DMA_BRD_CSR_DREQ(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_DREQ_SHIFT, DMA_CSR_DREQ_WIDTH))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_CSR_DREQ(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_DREQ_MASK, DMA_CSR_DREQ(value)))
#define DMA_BWR_CSR_DREQ(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_DREQ_SHIFT), DMA_CSR_DREQ_SHIFT, DMA_CSR_DREQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channel's TCD is normal format.
 * - 1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into this
 *     channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_ESG field. */
#define DMA_RD_CSR_ESG(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_ESG_MASK) >> DMA_CSR_ESG_SHIFT)
#define DMA_BRD_CSR_ESG(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_ESG_SHIFT, DMA_CSR_ESG_WIDTH))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_CSR_ESG(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_ESG_MASK, DMA_CSR_ESG(value)))
#define DMA_BWR_CSR_ESG(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_ESG_SHIFT), DMA_CSR_ESG_SHIFT, DMA_CSR_ESG_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled.
 * - 1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_MAJORELINK field. */
#define DMA_RD_CSR_MAJORELINK(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_MAJORELINK_MASK) >> DMA_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_CSR_MAJORELINK(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_MAJORELINK_SHIFT, DMA_CSR_MAJORELINK_WIDTH))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_CSR_MAJORELINK(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_MAJORELINK_MASK, DMA_CSR_MAJORELINK(value)))
#define DMA_BWR_CSR_MAJORELINK(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_MAJORELINK_SHIFT), DMA_CSR_MAJORELINK_SHIFT, DMA_CSR_MAJORELINK_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_ACTIVE field. */
#define DMA_RD_CSR_ACTIVE(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_ACTIVE_MASK) >> DMA_CSR_ACTIVE_SHIFT)
#define DMA_BRD_CSR_ACTIVE(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_ACTIVE_SHIFT, DMA_CSR_ACTIVE_WIDTH))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_CSR_ACTIVE(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_ACTIVE_MASK, DMA_CSR_ACTIVE(value)))
#define DMA_BWR_CSR_ACTIVE(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_ACTIVE_SHIFT), DMA_CSR_ACTIVE_SHIFT, DMA_CSR_ACTIVE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_DONE field. */
#define DMA_RD_CSR_DONE(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_DONE_MASK) >> DMA_CSR_DONE_SHIFT)
#define DMA_BRD_CSR_DONE(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_DONE_SHIFT, DMA_CSR_DONE_WIDTH))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_CSR_DONE(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_DONE_MASK, DMA_CSR_DONE(value)))
#define DMA_BWR_CSR_DONE(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_DONE_SHIFT), DMA_CSR_DONE_SHIFT, DMA_CSR_DONE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field MAJORLINKCH[9:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_MAJORLINKCH field. */
#define DMA_RD_CSR_MAJORLINKCH(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_MAJORLINKCH_MASK) >> DMA_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_CSR_MAJORLINKCH(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_MAJORLINKCH_SHIFT, DMA_CSR_MAJORLINKCH_WIDTH))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_CSR_MAJORLINKCH(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_MAJORLINKCH_MASK, DMA_CSR_MAJORLINKCH(value)))
#define DMA_BWR_CSR_MAJORLINKCH(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_MAJORLINKCH_SHIFT), DMA_CSR_MAJORLINKCH_SHIFT, DMA_CSR_MAJORLINKCH_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_BWC field. */
#define DMA_RD_CSR_BWC(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_BWC_MASK) >> DMA_CSR_BWC_SHIFT)
#define DMA_BRD_CSR_BWC(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_BWC_SHIFT, DMA_CSR_BWC_WIDTH))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_CSR_BWC(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_BWC_MASK, DMA_CSR_BWC(value)))
#define DMA_BWR_CSR_BWC(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_BWC_SHIFT), DMA_CSR_BWC_SHIFT, DMA_CSR_BWC_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_BITER_ELINKNO(base, index) (DMA_BITER_ELINKNO_REG(base, index))
#define DMA_WR_BITER_ELINKNO(base, index, value) (DMA_BITER_ELINKNO_REG(base, index) = (value))
#define DMA_RMW_BITER_ELINKNO(base, index, mask, value) (DMA_WR_BITER_ELINKNO(base, index, (DMA_RD_BITER_ELINKNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_BITER_ELINKNO(base, index, value) (BME_OR16(&DMA_BITER_ELINKNO_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_BITER_ELINKNO(base, index, value) (BME_AND16(&DMA_BITER_ELINKNO_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_BITER_ELINKNO(base, index, value) (BME_XOR16(&DMA_BITER_ELINKNO_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKNO_BITER field. */
#define DMA_RD_BITER_ELINKNO_BITER(base, index) ((DMA_BITER_ELINKNO_REG(base, index) & DMA_BITER_ELINKNO_BITER_MASK) >> DMA_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_BITER_ELINKNO_BITER(base, index) (BME_UBFX16(&DMA_BITER_ELINKNO_REG(base, index), DMA_BITER_ELINKNO_BITER_SHIFT, DMA_BITER_ELINKNO_BITER_WIDTH))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_BITER_ELINKNO_BITER(base, index, value) (DMA_RMW_BITER_ELINKNO(base, index, DMA_BITER_ELINKNO_BITER_MASK, DMA_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_BITER_ELINKNO_BITER(base, index, value) (BME_BFI16(&DMA_BITER_ELINKNO_REG(base, index), ((uint16_t)(value) << DMA_BITER_ELINKNO_BITER_SHIFT), DMA_BITER_ELINKNO_BITER_SHIFT, DMA_BITER_ELINKNO_BITER_WIDTH))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKNO_ELINK field. */
#define DMA_RD_BITER_ELINKNO_ELINK(base, index) ((DMA_BITER_ELINKNO_REG(base, index) & DMA_BITER_ELINKNO_ELINK_MASK) >> DMA_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_BITER_ELINKNO_ELINK(base, index) (BME_UBFX16(&DMA_BITER_ELINKNO_REG(base, index), DMA_BITER_ELINKNO_ELINK_SHIFT, DMA_BITER_ELINKNO_ELINK_WIDTH))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_BITER_ELINKNO_ELINK(base, index, value) (DMA_RMW_BITER_ELINKNO(base, index, DMA_BITER_ELINKNO_ELINK_MASK, DMA_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_BITER_ELINKNO_ELINK(base, index, value) (BME_BFI16(&DMA_BITER_ELINKNO_REG(base, index), ((uint16_t)(value) << DMA_BITER_ELINKNO_ELINK_SHIFT), DMA_BITER_ELINKNO_ELINK_SHIFT, DMA_BITER_ELINKNO_ELINK_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_BITER_ELINKYES(base, index) (DMA_BITER_ELINKYES_REG(base, index))
#define DMA_WR_BITER_ELINKYES(base, index, value) (DMA_BITER_ELINKYES_REG(base, index) = (value))
#define DMA_RMW_BITER_ELINKYES(base, index, mask, value) (DMA_WR_BITER_ELINKYES(base, index, (DMA_RD_BITER_ELINKYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_BITER_ELINKYES(base, index, value) (BME_OR16(&DMA_BITER_ELINKYES_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_BITER_ELINKYES(base, index, value) (BME_AND16(&DMA_BITER_ELINKYES_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_BITER_ELINKYES(base, index, value) (BME_XOR16(&DMA_BITER_ELINKYES_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_BITER field. */
#define DMA_RD_BITER_ELINKYES_BITER(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_BITER_MASK) >> DMA_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_BITER_ELINKYES_BITER(base, index) (BME_UBFX16(&DMA_BITER_ELINKYES_REG(base, index), DMA_BITER_ELINKYES_BITER_SHIFT, DMA_BITER_ELINKYES_BITER_WIDTH))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_BITER_ELINKYES_BITER(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_BITER_MASK, DMA_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_BITER_ELINKYES_BITER(base, index, value) (BME_BFI16(&DMA_BITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_BITER_ELINKYES_BITER_SHIFT), DMA_BITER_ELINKYES_BITER_SHIFT, DMA_BITER_ELINKYES_BITER_WIDTH))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKYES, field LINKCH[10:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_BITER_ELINKYES_LINKCH(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_LINKCH_MASK) >> DMA_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_BITER_ELINKYES_LINKCH(base, index) (BME_UBFX16(&DMA_BITER_ELINKYES_REG(base, index), DMA_BITER_ELINKYES_LINKCH_SHIFT, DMA_BITER_ELINKYES_LINKCH_WIDTH))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_BITER_ELINKYES_LINKCH(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_LINKCH_MASK, DMA_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_BITER_ELINKYES_LINKCH(base, index, value) (BME_BFI16(&DMA_BITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_BITER_ELINKYES_LINKCH_SHIFT), DMA_BITER_ELINKYES_LINKCH_SHIFT, DMA_BITER_ELINKYES_LINKCH_WIDTH))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_ELINK field. */
#define DMA_RD_BITER_ELINKYES_ELINK(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_ELINK_MASK) >> DMA_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_BITER_ELINKYES_ELINK(base, index) (BME_UBFX16(&DMA_BITER_ELINKYES_REG(base, index), DMA_BITER_ELINKYES_ELINK_SHIFT, DMA_BITER_ELINKYES_ELINK_WIDTH))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_BITER_ELINKYES_ELINK(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_ELINK_MASK, DMA_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_BITER_ELINKYES_ELINK(base, index, value) (BME_BFI16(&DMA_BITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_BITER_ELINKYES_ELINK_SHIFT), DMA_BITER_ELINKYES_ELINK_SHIFT, DMA_BITER_ELINKYES_ELINK_WIDTH))
/*@}*/

/* Register macros for indexed access to DMA channel priority registers */
/*
 * Constants and macros for entire DMA_DCHPRIn register
 */
#define DMA_DCHPRIn_INDEX(channel)          (((channel) & ~0x03U) | (3 - ((channel) & 0x03U)))
#define DMA_DCHPRIn_REG(base, index)        (((volatile uint8_t *)&DMA_DCHPRI3_REG(base))[DMA_DCHPRIn_INDEX(index)])
#define DMA_RD_DCHPRIn(base, index)         (DMA_DCHPRIn_REG((base), (index)))
#define DMA_WR_DCHPRIn(base, index, value)  (DMA_DCHPRIn_REG((base), (index)) = (value))
#define DMA_SET_DCHPRIn(base, index, value) (BME_OR8(&DMA_DCHPRIn_REG((base), (index)), (uint8_t)(value)))
#define DMA_CLR_DCHPRIn(base, index, value) (BME_AND8(&DMA_DCHPRIn_REG((base), (index)), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRIn(base, index, value) (BME_XOR8(&DMA_DCHPRIn_REG((base), (index)), (uint8_t)(value)))

/*
 * Register DMA_DCHPRIn, bit field CHPRI
 */
/* Read current value of the CHPRI bit field. */
#define DMA_RD_DCHPRIn_CHPRI(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_CHPRI_MASK) >> DMA_DCHPRI0_CHPRI_SHIFT)
#define DMA_BRD_DCHPRIn_CHPRI(base, index) (BME_UBFX8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_CHPRI_SHIFT, DMA_DCHPRI0_CHPRI_WIDTH))

/* Set the CHPRI bit field to a new value. */
#define DMA_WR_DCHPRIn_CHPRI(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_CHPRI_MASK) | DMA_DCHPRI0_CHPRI(value)))
#define DMA_BWR_DCHPRIn_CHPRI(base, index, value) (BME_BFI8(&DMA_DCHPRIn_REG((base), (index)), ((uint8_t)(value) << DMA_DCHPRI0_CHPRI_SHIFT), DMA_DCHPRI0_CHPRI_SHIFT, DMA_DCHPRI0_CHPRI_WIDTH))

/*
 * Register DMA_DCHPRIn, bit field DPA
 */
/* Read current value of the DPA bit field. */
#define DMA_RD_DCHPRIn_DPA(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_DPA_MASK) >> DMA_DCHPRI0_DPA_SHIFT)
#define DMA_BRD_DCHPRIn_DPA(base, index) (BME_UBFX8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_DPA_SHIFT, DMA_DCHPRI0_DPA_WIDTH))

/* Set the DPA bit field to a new value. */
#define DMA_WR_DCHPRIn_DPA(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_DPA_MASK) | DMA_DCHPRI0_DPA(value)))
#define DMA_BWR_DCHPRIn_DPA(base, index, value) (BME_BFI8(&DMA_DCHPRIn_REG((base), (index)), ((uint8_t)(value) << DMA_DCHPRI0_DPA_SHIFT), DMA_DCHPRI0_DPA_SHIFT, DMA_DCHPRI0_DPA_WIDTH))

/*
 * Register DMA_DCHPRIn, bit field ECP
 */
/* Read current value of the ECP bit field. */
#define DMA_RD_DCHPRIn_ECP(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_ECP_MASK) >> DMA_DCHPRI0_ECP_SHIFT)
#define DMA_BRD_DCHPRIn_ECP(base, index) (BME_UBFX8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_ECP_SHIFT, DMA_DCHPRI0_ECP_WIDTH))

/* Set the ECP bit field to a new value. */
#define DMA_WR_DCHPRIn_ECP(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_ECP_MASK) | DMA_DCHPRI0_ECP(value)))
#define DMA_BWR_DCHPRIn_ECP(base, index, value) (BME_BFI8(&DMA_DCHPRIn_REG((base), (index)), ((uint8_t)(value) << DMA_DCHPRI0_ECP_SHIFT), DMA_DCHPRI0_ECP_SHIFT, DMA_DCHPRI0_ECP_WIDTH))

/*
 * MKV10Z7 DMAMUX
 *
 * DMA channel multiplexor
 *
 * Registers defined in this header file:
 * - DMAMUX_CHCFG - Channel Configuration register
 */

#define DMAMUX_INSTANCE_COUNT (1U) /*!< Number of instances of the DMAMUX module. */
#define DMAMUX_IDX (0U) /*!< Instance number for DMAMUX. */

/*******************************************************************************
 * DMAMUX_CHCFG - Channel Configuration register
 ******************************************************************************/

/*!
 * @brief DMAMUX_CHCFG - Channel Configuration register (RW)
 *
 * Reset value: 0x00U
 *
 * Each of the DMA channels can be independently enabled/disabled and associated
 * with one of the DMA slots (peripheral slots or always-on slots) in the
 * system. Setting multiple CHCFG registers with the same source value will result in
 * unpredictable behavior. This is true, even if a channel is disabled (ENBL==0).
 * Before changing the source settings, a DMA channel must be disabled via
 * CHCFGn[ENBL].
 */
/*!
 * @name Constants and macros for entire DMAMUX_CHCFG register
 */
/*@{*/
#define DMAMUX_RD_CHCFG(base, index) (DMAMUX_CHCFG_REG(base, index))
#define DMAMUX_WR_CHCFG(base, index, value) (DMAMUX_CHCFG_REG(base, index) = (value))
#define DMAMUX_RMW_CHCFG(base, index, mask, value) (DMAMUX_WR_CHCFG(base, index, (DMAMUX_RD_CHCFG(base, index) & ~(mask)) | (value)))
#define DMAMUX_SET_CHCFG(base, index, value) (BME_OR8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(value)))
#define DMAMUX_CLR_CHCFG(base, index, value) (BME_AND8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(~(value))))
#define DMAMUX_TOG_CHCFG(base, index, value) (BME_XOR8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMAMUX_CHCFG bitfields
 */

/*!
 * @name Register DMAMUX_CHCFG, field SOURCE[5:0] (RW)
 *
 * Specifies which DMA source, if any, is routed to a particular DMA channel.
 * See the chip-specific DMAMUX information for details about the peripherals and
 * their slot numbers.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_SOURCE field. */
#define DMAMUX_RD_CHCFG_SOURCE(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_SOURCE_MASK) >> DMAMUX_CHCFG_SOURCE_SHIFT)
#define DMAMUX_BRD_CHCFG_SOURCE(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_SOURCE_SHIFT, DMAMUX_CHCFG_SOURCE_WIDTH))

/*! @brief Set the SOURCE field to a new value. */
#define DMAMUX_WR_CHCFG_SOURCE(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_SOURCE_MASK, DMAMUX_CHCFG_SOURCE(value)))
#define DMAMUX_BWR_CHCFG_SOURCE(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_SOURCE_SHIFT), DMAMUX_CHCFG_SOURCE_SHIFT, DMAMUX_CHCFG_SOURCE_WIDTH))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field ENBL[7] (RW)
 *
 * Enables the DMA channel.
 *
 * Values:
 * - 0 - DMA channel is disabled. This mode is primarily used during
 *     configuration of the DMAMux. The DMA has separate channel enables/disables, which
 *     should be used to disable or reconfigure a DMA channel.
 * - 1 - DMA channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_ENBL field. */
#define DMAMUX_RD_CHCFG_ENBL(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_ENBL_MASK) >> DMAMUX_CHCFG_ENBL_SHIFT)
#define DMAMUX_BRD_CHCFG_ENBL(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_ENBL_SHIFT, DMAMUX_CHCFG_ENBL_WIDTH))

/*! @brief Set the ENBL field to a new value. */
#define DMAMUX_WR_CHCFG_ENBL(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_ENBL_MASK, DMAMUX_CHCFG_ENBL(value)))
#define DMAMUX_BWR_CHCFG_ENBL(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_ENBL_SHIFT), DMAMUX_CHCFG_ENBL_SHIFT, DMAMUX_CHCFG_ENBL_WIDTH))
/*@}*/

/*
 * MKV10Z7 EWM
 *
 * External Watchdog Monitor
 *
 * Registers defined in this header file:
 * - EWM_CTRL - Control Register
 * - EWM_SERV - Service Register
 * - EWM_CMPL - Compare Low Register
 * - EWM_CMPH - Compare High Register
 * - EWM_CLKCTRL - Clock Control Register
 * - EWM_CLKPRESCALER - Clock Prescaler Register
 */

#define EWM_INSTANCE_COUNT (1U) /*!< Number of instances of the EWM module. */
#define EWM_IDX (0U) /*!< Instance number for EWM. */

/*******************************************************************************
 * EWM_CTRL - Control Register
 ******************************************************************************/

/*!
 * @brief EWM_CTRL - Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CTRL register is cleared by any reset. INEN, ASSIN and EWMEN bits can be
 * written once after a CPU reset. Modifying these bits more than once, generates
 * a bus transfer error.
 */
/*!
 * @name Constants and macros for entire EWM_CTRL register
 */
/*@{*/
#define EWM_RD_CTRL(base)        (EWM_CTRL_REG(base))
#define EWM_WR_CTRL(base, value) (EWM_CTRL_REG(base) = (value))
#define EWM_RMW_CTRL(base, mask, value) (EWM_WR_CTRL(base, (EWM_RD_CTRL(base) & ~(mask)) | (value)))
#define EWM_SET_CTRL(base, value) (BME_OR8(&EWM_CTRL_REG(base), (uint8_t)(value)))
#define EWM_CLR_CTRL(base, value) (BME_AND8(&EWM_CTRL_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CTRL(base, value) (BME_XOR8(&EWM_CTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EWM_CTRL bitfields
 */

/*!
 * @name Register EWM_CTRL, field EWMEN[0] (RW)
 *
 * This bit when set, enables the EWM module. This resets the EWM counter to
 * zero and deasserts the EWM_out signal. Clearing EWMEN bit disables the EWM, and
 * therefore it cannot be enabled until a reset occurs, due to the write-once
 * nature of this bit.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_EWMEN field. */
#define EWM_RD_CTRL_EWMEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_EWMEN_MASK) >> EWM_CTRL_EWMEN_SHIFT)
#define EWM_BRD_CTRL_EWMEN(base) (BME_UBFX8(&EWM_CTRL_REG(base), EWM_CTRL_EWMEN_SHIFT, EWM_CTRL_EWMEN_WIDTH))

/*! @brief Set the EWMEN field to a new value. */
#define EWM_WR_CTRL_EWMEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_EWMEN_MASK, EWM_CTRL_EWMEN(value)))
#define EWM_BWR_CTRL_EWMEN(base, value) (BME_BFI8(&EWM_CTRL_REG(base), ((uint8_t)(value) << EWM_CTRL_EWMEN_SHIFT), EWM_CTRL_EWMEN_SHIFT, EWM_CTRL_EWMEN_WIDTH))
/*@}*/

/*!
 * @name Register EWM_CTRL, field ASSIN[1] (RW)
 *
 * Default assert state of the EWM_in signal is logic zero. Setting ASSIN bit
 * inverts the assert state to a logic one.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_ASSIN field. */
#define EWM_RD_CTRL_ASSIN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_ASSIN_MASK) >> EWM_CTRL_ASSIN_SHIFT)
#define EWM_BRD_CTRL_ASSIN(base) (BME_UBFX8(&EWM_CTRL_REG(base), EWM_CTRL_ASSIN_SHIFT, EWM_CTRL_ASSIN_WIDTH))

/*! @brief Set the ASSIN field to a new value. */
#define EWM_WR_CTRL_ASSIN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_ASSIN_MASK, EWM_CTRL_ASSIN(value)))
#define EWM_BWR_CTRL_ASSIN(base, value) (BME_BFI8(&EWM_CTRL_REG(base), ((uint8_t)(value) << EWM_CTRL_ASSIN_SHIFT), EWM_CTRL_ASSIN_SHIFT, EWM_CTRL_ASSIN_WIDTH))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INEN[2] (RW)
 *
 * This bit when set, enables the EWM_in port.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_INEN field. */
#define EWM_RD_CTRL_INEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_INEN_MASK) >> EWM_CTRL_INEN_SHIFT)
#define EWM_BRD_CTRL_INEN(base) (BME_UBFX8(&EWM_CTRL_REG(base), EWM_CTRL_INEN_SHIFT, EWM_CTRL_INEN_WIDTH))

/*! @brief Set the INEN field to a new value. */
#define EWM_WR_CTRL_INEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_INEN_MASK, EWM_CTRL_INEN(value)))
#define EWM_BWR_CTRL_INEN(base, value) (BME_BFI8(&EWM_CTRL_REG(base), ((uint8_t)(value) << EWM_CTRL_INEN_SHIFT), EWM_CTRL_INEN_SHIFT, EWM_CTRL_INEN_WIDTH))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INTEN[3] (RW)
 *
 * This bit when set and EWM_out is asserted, an interrupt request is generated.
 * To de-assert interrupt request, user should clear this bit by writing 0.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_INTEN field. */
#define EWM_RD_CTRL_INTEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_INTEN_MASK) >> EWM_CTRL_INTEN_SHIFT)
#define EWM_BRD_CTRL_INTEN(base) (BME_UBFX8(&EWM_CTRL_REG(base), EWM_CTRL_INTEN_SHIFT, EWM_CTRL_INTEN_WIDTH))

/*! @brief Set the INTEN field to a new value. */
#define EWM_WR_CTRL_INTEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_INTEN_MASK, EWM_CTRL_INTEN(value)))
#define EWM_BWR_CTRL_INTEN(base, value) (BME_BFI8(&EWM_CTRL_REG(base), ((uint8_t)(value) << EWM_CTRL_INTEN_SHIFT), EWM_CTRL_INTEN_SHIFT, EWM_CTRL_INTEN_WIDTH))
/*@}*/

/*******************************************************************************
 * EWM_SERV - Service Register
 ******************************************************************************/

/*!
 * @brief EWM_SERV - Service Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The SERV register provides the interface from the CPU to the EWM module. It
 * is write-only and reads of this register return zero.
 */
/*!
 * @name Constants and macros for entire EWM_SERV register
 */
/*@{*/
#define EWM_RD_SERV(base)        (EWM_SERV_REG(base))
#define EWM_WR_SERV(base, value) (EWM_SERV_REG(base) = (value))
#define EWM_RMW_SERV(base, mask, value) (EWM_WR_SERV(base, (EWM_RD_SERV(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * EWM_CMPL - Compare Low Register
 ******************************************************************************/

/*!
 * @brief EWM_CMPL - Compare Low Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CMPL register is reset to zero after a CPU reset. This provides no
 * minimum time for the CPU to service the EWM counter. This register can be written
 * only once after a CPU reset. Writing this register more than once generates a
 * bus transfer error.
 */
/*!
 * @name Constants and macros for entire EWM_CMPL register
 */
/*@{*/
#define EWM_RD_CMPL(base)        (EWM_CMPL_REG(base))
#define EWM_WR_CMPL(base, value) (EWM_CMPL_REG(base) = (value))
#define EWM_RMW_CMPL(base, mask, value) (EWM_WR_CMPL(base, (EWM_RD_CMPL(base) & ~(mask)) | (value)))
#define EWM_SET_CMPL(base, value) (BME_OR8(&EWM_CMPL_REG(base), (uint8_t)(value)))
#define EWM_CLR_CMPL(base, value) (BME_AND8(&EWM_CMPL_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CMPL(base, value) (BME_XOR8(&EWM_CMPL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * EWM_CMPH - Compare High Register
 ******************************************************************************/

/*!
 * @brief EWM_CMPH - Compare High Register (RW)
 *
 * Reset value: 0xFFU
 *
 * The CMPH register is reset to 0xFF after a CPU reset. This provides a maximum
 * of 256 clocks time, for the CPU to service the EWM counter. This register can
 * be written only once after a CPU reset. Writing this register more than once
 * generates a bus transfer error. The valid values for CMPH are up to 0xFE
 * because the EWM counter never expires when CMPH = 0xFF. The expiration happens only
 * if EWM counter is greater than CMPH.
 */
/*!
 * @name Constants and macros for entire EWM_CMPH register
 */
/*@{*/
#define EWM_RD_CMPH(base)        (EWM_CMPH_REG(base))
#define EWM_WR_CMPH(base, value) (EWM_CMPH_REG(base) = (value))
#define EWM_RMW_CMPH(base, mask, value) (EWM_WR_CMPH(base, (EWM_RD_CMPH(base) & ~(mask)) | (value)))
#define EWM_SET_CMPH(base, value) (BME_OR8(&EWM_CMPH_REG(base), (uint8_t)(value)))
#define EWM_CLR_CMPH(base, value) (BME_AND8(&EWM_CMPH_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CMPH(base, value) (BME_XOR8(&EWM_CMPH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * EWM_CLKCTRL - Clock Control Register
 ******************************************************************************/

/*!
 * @brief EWM_CLKCTRL - Clock Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This CLKCTRL register is reset to 0x00 after a CPU reset. This register can
 * be written only once after a CPU reset. Writing this register more than once
 * generates a bus transfer error. User should select the required low power clock
 * before enabling the EWM.
 */
/*!
 * @name Constants and macros for entire EWM_CLKCTRL register
 */
/*@{*/
#define EWM_RD_CLKCTRL(base)     (EWM_CLKCTRL_REG(base))
#define EWM_WR_CLKCTRL(base, value) (EWM_CLKCTRL_REG(base) = (value))
#define EWM_RMW_CLKCTRL(base, mask, value) (EWM_WR_CLKCTRL(base, (EWM_RD_CLKCTRL(base) & ~(mask)) | (value)))
#define EWM_SET_CLKCTRL(base, value) (BME_OR8(&EWM_CLKCTRL_REG(base), (uint8_t)(value)))
#define EWM_CLR_CLKCTRL(base, value) (BME_AND8(&EWM_CLKCTRL_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CLKCTRL(base, value) (BME_XOR8(&EWM_CLKCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EWM_CLKCTRL bitfields
 */

/*!
 * @name Register EWM_CLKCTRL, field CLKSEL[1:0] (RW)
 *
 * EWM has 4 possible low power clock sources for running EWM counter. One of
 * the clock source can be selected by writing into this field. 00 - lpo_clk[0]
 * will be selected for running EWM counter. 01 - lpo_clk[1] will be selected for
 * running EWM counter. 10 - lpo_clk[2] will be selected for running EWM counter.
 * 11 - lpo_clk[3] will be selected for running EWM counter.
 */
/*@{*/
/*! @brief Read current value of the EWM_CLKCTRL_CLKSEL field. */
#define EWM_RD_CLKCTRL_CLKSEL(base) ((EWM_CLKCTRL_REG(base) & EWM_CLKCTRL_CLKSEL_MASK) >> EWM_CLKCTRL_CLKSEL_SHIFT)
#define EWM_BRD_CLKCTRL_CLKSEL(base) (BME_UBFX8(&EWM_CLKCTRL_REG(base), EWM_CLKCTRL_CLKSEL_SHIFT, EWM_CLKCTRL_CLKSEL_WIDTH))

/*! @brief Set the CLKSEL field to a new value. */
#define EWM_WR_CLKCTRL_CLKSEL(base, value) (EWM_RMW_CLKCTRL(base, EWM_CLKCTRL_CLKSEL_MASK, EWM_CLKCTRL_CLKSEL(value)))
#define EWM_BWR_CLKCTRL_CLKSEL(base, value) (BME_BFI8(&EWM_CLKCTRL_REG(base), ((uint8_t)(value) << EWM_CLKCTRL_CLKSEL_SHIFT), EWM_CLKCTRL_CLKSEL_SHIFT, EWM_CLKCTRL_CLKSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * EWM_CLKPRESCALER - Clock Prescaler Register
 ******************************************************************************/

/*!
 * @brief EWM_CLKPRESCALER - Clock Prescaler Register (RW)
 *
 * Reset value: 0x00U
 *
 * This CLKPRESCALER register is reset to 0x00 after a CPU reset. This register
 * can be written only once after a CPU reset. Writing this register more than
 * once generates a bus transfer error. Write the required prescaler value before
 * enabling the EWM. The implementation of this register is chip-specific. See the
 * Chip Configuration details.
 */
/*!
 * @name Constants and macros for entire EWM_CLKPRESCALER register
 */
/*@{*/
#define EWM_RD_CLKPRESCALER(base) (EWM_CLKPRESCALER_REG(base))
#define EWM_WR_CLKPRESCALER(base, value) (EWM_CLKPRESCALER_REG(base) = (value))
#define EWM_RMW_CLKPRESCALER(base, mask, value) (EWM_WR_CLKPRESCALER(base, (EWM_RD_CLKPRESCALER(base) & ~(mask)) | (value)))
#define EWM_SET_CLKPRESCALER(base, value) (BME_OR8(&EWM_CLKPRESCALER_REG(base), (uint8_t)(value)))
#define EWM_CLR_CLKPRESCALER(base, value) (BME_AND8(&EWM_CLKPRESCALER_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CLKPRESCALER(base, value) (BME_XOR8(&EWM_CLKPRESCALER_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * MKV10Z7 FGPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - FGPIO_PDOR - Port Data Output Register
 * - FGPIO_PSOR - Port Set Output Register
 * - FGPIO_PCOR - Port Clear Output Register
 * - FGPIO_PTOR - Port Toggle Output Register
 * - FGPIO_PDIR - Port Data Input Register
 * - FGPIO_PDDR - Port Data Direction Register
 */

#define FGPIO_INSTANCE_COUNT (5U) /*!< Number of instances of the FGPIO module. */
#define FGPIOA_IDX (0U) /*!< Instance number for FGPIOA. */
#define FGPIOB_IDX (1U) /*!< Instance number for FGPIOB. */
#define FGPIOC_IDX (2U) /*!< Instance number for FGPIOC. */
#define FGPIOD_IDX (3U) /*!< Instance number for FGPIOD. */
#define FGPIOE_IDX (4U) /*!< Instance number for FGPIOE. */

/*******************************************************************************
 * FGPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the logic levels that are driven on each
 * general-purpose output pins.
 */
/*!
 * @name Constants and macros for entire FGPIO_PDOR register
 */
/*@{*/
#define FGPIO_RD_PDOR(base)      (FGPIO_PDOR_REG(base))
#define FGPIO_WR_PDOR(base, value) (FGPIO_PDOR_REG(base) = (value))
#define FGPIO_RMW_PDOR(base, mask, value) (FGPIO_WR_PDOR(base, (FGPIO_RD_PDOR(base) & ~(mask)) | (value)))
#define FGPIO_SET_PDOR(base, value) (FGPIO_WR_PDOR(base, FGPIO_RD_PDOR(base) |  (value)))
#define FGPIO_CLR_PDOR(base, value) (FGPIO_WR_PDOR(base, FGPIO_RD_PDOR(base) & ~(value)))
#define FGPIO_TOG_PDOR(base, value) (FGPIO_WR_PDOR(base, FGPIO_RD_PDOR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to set the fields of the PDOR.
 */
/*!
 * @name Constants and macros for entire FGPIO_PSOR register
 */
/*@{*/
#define FGPIO_RD_PSOR(base)      (FGPIO_PSOR_REG(base))
#define FGPIO_WR_PSOR(base, value) (FGPIO_PSOR_REG(base) = (value))
#define FGPIO_RMW_PSOR(base, mask, value) (FGPIO_WR_PSOR(base, (FGPIO_RD_PSOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to clear the fields of PDOR.
 */
/*!
 * @name Constants and macros for entire FGPIO_PCOR register
 */
/*@{*/
#define FGPIO_RD_PCOR(base)      (FGPIO_PCOR_REG(base))
#define FGPIO_WR_PCOR(base, value) (FGPIO_PCOR_REG(base) = (value))
#define FGPIO_RMW_PCOR(base, mask, value) (FGPIO_WR_PCOR(base, (FGPIO_RD_PCOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FGPIO_PTOR register
 */
/*@{*/
#define FGPIO_RD_PTOR(base)      (FGPIO_PTOR_REG(base))
#define FGPIO_WR_PTOR(base, value) (FGPIO_PTOR_REG(base) = (value))
#define FGPIO_RMW_PTOR(base, mask, value) (FGPIO_WR_PTOR(base, (FGPIO_RD_PTOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FGPIO_PDIR register
 */
/*@{*/
#define FGPIO_RD_PDIR(base)      (FGPIO_PDIR_REG(base))
/*@}*/

/*******************************************************************************
 * FGPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDDR configures the individual port pins for input or output.
 */
/*!
 * @name Constants and macros for entire FGPIO_PDDR register
 */
/*@{*/
#define FGPIO_RD_PDDR(base)      (FGPIO_PDDR_REG(base))
#define FGPIO_WR_PDDR(base, value) (FGPIO_PDDR_REG(base) = (value))
#define FGPIO_RMW_PDDR(base, mask, value) (FGPIO_WR_PDDR(base, (FGPIO_RD_PDDR(base) & ~(mask)) | (value)))
#define FGPIO_SET_PDDR(base, value) (FGPIO_WR_PDDR(base, FGPIO_RD_PDDR(base) |  (value)))
#define FGPIO_CLR_PDDR(base, value) (FGPIO_WR_PDDR(base, FGPIO_RD_PDDR(base) & ~(value)))
#define FGPIO_TOG_PDDR(base, value) (FGPIO_WR_PDDR(base, FGPIO_RD_PDDR(base) ^  (value)))
/*@}*/

/*
 * MKV10Z7 FTFA
 *
 * Flash Memory Interface
 *
 * Registers defined in this header file:
 * - FTFA_FSTAT - Flash Status Register
 * - FTFA_FCNFG - Flash Configuration Register
 * - FTFA_FSEC - Flash Security Register
 * - FTFA_FOPT - Flash Option Register
 * - FTFA_FCCOB3 - Flash Common Command Object Registers
 * - FTFA_FCCOB2 - Flash Common Command Object Registers
 * - FTFA_FCCOB1 - Flash Common Command Object Registers
 * - FTFA_FCCOB0 - Flash Common Command Object Registers
 * - FTFA_FCCOB7 - Flash Common Command Object Registers
 * - FTFA_FCCOB6 - Flash Common Command Object Registers
 * - FTFA_FCCOB5 - Flash Common Command Object Registers
 * - FTFA_FCCOB4 - Flash Common Command Object Registers
 * - FTFA_FCCOBB - Flash Common Command Object Registers
 * - FTFA_FCCOBA - Flash Common Command Object Registers
 * - FTFA_FCCOB9 - Flash Common Command Object Registers
 * - FTFA_FCCOB8 - Flash Common Command Object Registers
 * - FTFA_FPROT3 - Program Flash Protection Registers
 * - FTFA_FPROT2 - Program Flash Protection Registers
 * - FTFA_FPROT1 - Program Flash Protection Registers
 * - FTFA_FPROT0 - Program Flash Protection Registers
 */

#define FTFA_INSTANCE_COUNT (1U) /*!< Number of instances of the FTFA module. */
#define FTFA_IDX (0U) /*!< Instance number for FTFA. */

/*******************************************************************************
 * FTFA_FSTAT - Flash Status Register
 ******************************************************************************/

/*!
 * @brief FTFA_FSTAT - Flash Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FSTAT register reports the operational status of the flash memory module.
 * The CCIF, RDCOLERR, ACCERR, and FPVIOL bits are readable and writable. The
 * MGSTAT0 bit is read only. The unassigned bits read 0 and are not writable. When
 * set, the Access Error (ACCERR) and Flash Protection Violation (FPVIOL) bits in
 * this register prevent the launch of any more commands until the flag is
 * cleared (by writing a one to it).
 */
/*!
 * @name Constants and macros for entire FTFA_FSTAT register
 */
/*@{*/
#define FTFA_RD_FSTAT(base)      (FTFA_FSTAT_REG(base))
#define FTFA_WR_FSTAT(base, value) (FTFA_FSTAT_REG(base) = (value))
#define FTFA_RMW_FSTAT(base, mask, value) (FTFA_WR_FSTAT(base, (FTFA_RD_FSTAT(base) & ~(mask)) | (value)))
#define FTFA_SET_FSTAT(base, value) (BME_OR8(&FTFA_FSTAT_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FSTAT(base, value) (BME_AND8(&FTFA_FSTAT_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FSTAT(base, value) (BME_XOR8(&FTFA_FSTAT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FSTAT bitfields
 */

/*!
 * @name Register FTFA_FSTAT, field MGSTAT0[0] (RO)
 *
 * The MGSTAT0 status flag is set if an error is detected during execution of a
 * flash command or during the flash reset sequence. As a status flag, this field
 * cannot (and need not) be cleared by the user like the other error flags in
 * this register. The value of the MGSTAT0 bit for "command-N" is valid only at the
 * end of the "command-N" execution when CCIF=1 and before the next command has
 * been launched. At some point during the execution of "command-N+1," the
 * previous result is discarded and any previous error is cleared.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_MGSTAT0 field. */
#define FTFA_RD_FSTAT_MGSTAT0(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_MGSTAT0_MASK) >> FTFA_FSTAT_MGSTAT0_SHIFT)
#define FTFA_BRD_FSTAT_MGSTAT0(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_MGSTAT0_SHIFT, FTFA_FSTAT_MGSTAT0_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field FPVIOL[4] (W1C)
 *
 * Indicates an attempt was made to program or erase an address in a protected
 * area of program flash memory during a command write sequence . While FPVIOL is
 * set, the CCIF flag cannot be cleared to launch a command. The FPVIOL bit is
 * cleared by writing a 1 to it. Writing a 0 to the FPVIOL bit has no effect.
 *
 * Values:
 * - 0 - No protection violation detected
 * - 1 - Protection violation detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_FPVIOL field. */
#define FTFA_RD_FSTAT_FPVIOL(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_FPVIOL_MASK) >> FTFA_FSTAT_FPVIOL_SHIFT)
#define FTFA_BRD_FSTAT_FPVIOL(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_FPVIOL_SHIFT, FTFA_FSTAT_FPVIOL_WIDTH))

/*! @brief Set the FPVIOL field to a new value. */
#define FTFA_WR_FSTAT_FPVIOL(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_FPVIOL(value)))
#define FTFA_BWR_FSTAT_FPVIOL(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_FPVIOL_SHIFT), FTFA_FSTAT_FPVIOL_SHIFT, FTFA_FSTAT_FPVIOL_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field ACCERR[5] (W1C)
 *
 * Indicates an illegal access has occurred to a flash memory resource caused by
 * a violation of the command write sequence or issuing an illegal flash
 * command. While ACCERR is set, the CCIF flag cannot be cleared to launch a command.
 * The ACCERR bit is cleared by writing a 1 to it. Writing a 0 to the ACCERR bit
 * has no effect.
 *
 * Values:
 * - 0 - No access error detected
 * - 1 - Access error detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_ACCERR field. */
#define FTFA_RD_FSTAT_ACCERR(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_ACCERR_MASK) >> FTFA_FSTAT_ACCERR_SHIFT)
#define FTFA_BRD_FSTAT_ACCERR(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_ACCERR_SHIFT, FTFA_FSTAT_ACCERR_WIDTH))

/*! @brief Set the ACCERR field to a new value. */
#define FTFA_WR_FSTAT_ACCERR(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_ACCERR(value)))
#define FTFA_BWR_FSTAT_ACCERR(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_ACCERR_SHIFT), FTFA_FSTAT_ACCERR_SHIFT, FTFA_FSTAT_ACCERR_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field RDCOLERR[6] (W1C)
 *
 * Indicates that the MCU attempted a read from a flash memory resource that was
 * being manipulated by a flash command (CCIF=0). Any simultaneous access is
 * detected as a collision error by the block arbitration logic. The read data in
 * this case cannot be guaranteed. The RDCOLERR bit is cleared by writing a 1 to
 * it. Writing a 0 to RDCOLERR has no effect.
 *
 * Values:
 * - 0 - No collision error detected
 * - 1 - Collision error detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_RDCOLERR field. */
#define FTFA_RD_FSTAT_RDCOLERR(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_RDCOLERR_MASK) >> FTFA_FSTAT_RDCOLERR_SHIFT)
#define FTFA_BRD_FSTAT_RDCOLERR(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_RDCOLERR_SHIFT, FTFA_FSTAT_RDCOLERR_WIDTH))

/*! @brief Set the RDCOLERR field to a new value. */
#define FTFA_WR_FSTAT_RDCOLERR(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_RDCOLERR(value)))
#define FTFA_BWR_FSTAT_RDCOLERR(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_RDCOLERR_SHIFT), FTFA_FSTAT_RDCOLERR_SHIFT, FTFA_FSTAT_RDCOLERR_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field CCIF[7] (W1C)
 *
 * Indicates that a flash command has completed. The CCIF flag is cleared by
 * writing a 1 to CCIF to launch a command, and CCIF stays low until command
 * completion or command violation. CCIF is reset to 0 but is set to 1 by the memory
 * controller at the end of the reset initialization sequence. Depending on how
 * quickly the read occurs after reset release, the user may or may not see the 0
 * hardware reset value.
 *
 * Values:
 * - 0 - Flash command in progress
 * - 1 - Flash command has completed
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_CCIF field. */
#define FTFA_RD_FSTAT_CCIF(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_CCIF_MASK) >> FTFA_FSTAT_CCIF_SHIFT)
#define FTFA_BRD_FSTAT_CCIF(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_CCIF_SHIFT, FTFA_FSTAT_CCIF_WIDTH))

/*! @brief Set the CCIF field to a new value. */
#define FTFA_WR_FSTAT_CCIF(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_CCIF_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_RDCOLERR_MASK), FTFA_FSTAT_CCIF(value)))
#define FTFA_BWR_FSTAT_CCIF(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_CCIF_SHIFT), FTFA_FSTAT_CCIF_SHIFT, FTFA_FSTAT_CCIF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFA_FCNFG - Flash Configuration Register
 ******************************************************************************/

/*!
 * @brief FTFA_FCNFG - Flash Configuration Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides information on the current functional state of the
 * flash memory module. The erase control bits (ERSAREQ and ERSSUSP) have write
 * restrictions. The unassigned bits read as noted and are not writable.
 */
/*!
 * @name Constants and macros for entire FTFA_FCNFG register
 */
/*@{*/
#define FTFA_RD_FCNFG(base)      (FTFA_FCNFG_REG(base))
#define FTFA_WR_FCNFG(base, value) (FTFA_FCNFG_REG(base) = (value))
#define FTFA_RMW_FCNFG(base, mask, value) (FTFA_WR_FCNFG(base, (FTFA_RD_FCNFG(base) & ~(mask)) | (value)))
#define FTFA_SET_FCNFG(base, value) (BME_OR8(&FTFA_FCNFG_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCNFG(base, value) (BME_AND8(&FTFA_FCNFG_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCNFG(base, value) (BME_XOR8(&FTFA_FCNFG_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCNFG bitfields
 */

/*!
 * @name Register FTFA_FCNFG, field ERSSUSP[4] (RW)
 *
 * Allows the user to suspend (interrupt) the Erase Flash Sector command while
 * it is executing.
 *
 * Values:
 * - 0 - No suspend requested
 * - 1 - Suspend the current Erase Flash Sector command execution.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_ERSSUSP field. */
#define FTFA_RD_FCNFG_ERSSUSP(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_ERSSUSP_MASK) >> FTFA_FCNFG_ERSSUSP_SHIFT)
#define FTFA_BRD_FCNFG_ERSSUSP(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_ERSSUSP_SHIFT, FTFA_FCNFG_ERSSUSP_WIDTH))

/*! @brief Set the ERSSUSP field to a new value. */
#define FTFA_WR_FCNFG_ERSSUSP(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_ERSSUSP_MASK, FTFA_FCNFG_ERSSUSP(value)))
#define FTFA_BWR_FCNFG_ERSSUSP(base, value) (BME_BFI8(&FTFA_FCNFG_REG(base), ((uint8_t)(value) << FTFA_FCNFG_ERSSUSP_SHIFT), FTFA_FCNFG_ERSSUSP_SHIFT, FTFA_FCNFG_ERSSUSP_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field ERSAREQ[5] (RO)
 *
 * Issues a request to the memory controller to execute the Erase All Blocks
 * command and release security. ERSAREQ is not directly writable but is under
 * indirect user control. Refer to the device's Chip Configuration details on how to
 * request this command. ERSAREQ sets when an erase all request is triggered
 * external to the flash memory module and CCIF is set (no command is currently being
 * executed). ERSAREQ is cleared by the flash memory module when the operation
 * completes.
 *
 * Values:
 * - 0 - No request or request complete
 * - 1 - Request to: run the Erase All Blocks command, verify the erased state,
 *     program the security byte in the Flash Configuration Field to the unsecure
 *     state, and release MCU security by setting the FSEC[SEC] field to the
 *     unsecure state.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_ERSAREQ field. */
#define FTFA_RD_FCNFG_ERSAREQ(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_ERSAREQ_MASK) >> FTFA_FCNFG_ERSAREQ_SHIFT)
#define FTFA_BRD_FCNFG_ERSAREQ(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_ERSAREQ_SHIFT, FTFA_FCNFG_ERSAREQ_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field RDCOLLIE[6] (RW)
 *
 * Controls interrupt generation when a flash memory read collision error occurs.
 *
 * Values:
 * - 0 - Read collision error interrupt disabled
 * - 1 - Read collision error interrupt enabled. An interrupt request is
 *     generated whenever a flash memory read collision error is detected (see the
 *     description of FSTAT[RDCOLERR]).
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_RDCOLLIE field. */
#define FTFA_RD_FCNFG_RDCOLLIE(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_RDCOLLIE_MASK) >> FTFA_FCNFG_RDCOLLIE_SHIFT)
#define FTFA_BRD_FCNFG_RDCOLLIE(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_RDCOLLIE_SHIFT, FTFA_FCNFG_RDCOLLIE_WIDTH))

/*! @brief Set the RDCOLLIE field to a new value. */
#define FTFA_WR_FCNFG_RDCOLLIE(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_RDCOLLIE_MASK, FTFA_FCNFG_RDCOLLIE(value)))
#define FTFA_BWR_FCNFG_RDCOLLIE(base, value) (BME_BFI8(&FTFA_FCNFG_REG(base), ((uint8_t)(value) << FTFA_FCNFG_RDCOLLIE_SHIFT), FTFA_FCNFG_RDCOLLIE_SHIFT, FTFA_FCNFG_RDCOLLIE_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field CCIE[7] (RW)
 *
 * Controls interrupt generation when a flash command completes.
 *
 * Values:
 * - 0 - Command complete interrupt disabled
 * - 1 - Command complete interrupt enabled. An interrupt request is generated
 *     whenever the FSTAT[CCIF] flag is set.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_CCIE field. */
#define FTFA_RD_FCNFG_CCIE(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_CCIE_MASK) >> FTFA_FCNFG_CCIE_SHIFT)
#define FTFA_BRD_FCNFG_CCIE(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_CCIE_SHIFT, FTFA_FCNFG_CCIE_WIDTH))

/*! @brief Set the CCIE field to a new value. */
#define FTFA_WR_FCNFG_CCIE(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_CCIE_MASK, FTFA_FCNFG_CCIE(value)))
#define FTFA_BWR_FCNFG_CCIE(base, value) (BME_BFI8(&FTFA_FCNFG_REG(base), ((uint8_t)(value) << FTFA_FCNFG_CCIE_SHIFT), FTFA_FCNFG_CCIE_SHIFT, FTFA_FCNFG_CCIE_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFA_FSEC - Flash Security Register
 ******************************************************************************/

/*!
 * @brief FTFA_FSEC - Flash Security Register (RO)
 *
 * Reset value: 0x00U
 *
 * This read-only register holds all bits associated with the security of the
 * MCU and flash memory module. During the reset sequence, the register is loaded
 * with the contents of the flash security byte in the Flash Configuration Field
 * located in program flash memory. The flash basis for the values is signified by
 * X in the reset value.
 */
/*!
 * @name Constants and macros for entire FTFA_FSEC register
 */
/*@{*/
#define FTFA_RD_FSEC(base)       (FTFA_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual FTFA_FSEC bitfields
 */

/*!
 * @name Register FTFA_FSEC, field SEC[1:0] (RO)
 *
 * Defines the security state of the MCU. In the secure state, the MCU limits
 * access to flash memory module resources. The limitations are defined per device
 * and are detailed in the Chip Configuration details. If the flash memory module
 * is unsecured using backdoor key access, SEC is forced to 10b.
 *
 * Values:
 * - 00 - MCU security status is secure.
 * - 01 - MCU security status is secure.
 * - 10 - MCU security status is unsecure. (The standard shipping condition of
 *     the flash memory module is unsecure.)
 * - 11 - MCU security status is secure.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_SEC field. */
#define FTFA_RD_FSEC_SEC(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_SEC_MASK) >> FTFA_FSEC_SEC_SHIFT)
#define FTFA_BRD_FSEC_SEC(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_SEC_SHIFT, FTFA_FSEC_SEC_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field FSLACC[3:2] (RO)
 *
 * Enables or disables access to the flash memory contents during returned part
 * failure analysis at Freescale. When SEC is secure and FSLACC is denied, access
 * to the program flash contents is denied and any failure analysis performed by
 * Freescale factory test must begin with a full erase to unsecure the part.
 * When access is granted (SEC is unsecure, or SEC is secure and FSLACC is granted),
 * Freescale factory testing has visibility of the current flash contents. The
 * state of the FSLACC bits is only relevant when SEC is set to secure. When SEC
 * is set to unsecure, the FSLACC setting does not matter.
 *
 * Values:
 * - 00 - Freescale factory access granted
 * - 01 - Freescale factory access denied
 * - 10 - Freescale factory access denied
 * - 11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_FSLACC field. */
#define FTFA_RD_FSEC_FSLACC(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_FSLACC_MASK) >> FTFA_FSEC_FSLACC_SHIFT)
#define FTFA_BRD_FSEC_FSLACC(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_FSLACC_SHIFT, FTFA_FSEC_FSLACC_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field MEEN[5:4] (RO)
 *
 * Enables and disables mass erase capability of the flash memory module. The
 * state of this field is relevant only when SEC is set to secure outside of NVM
 * Normal Mode. When SEC is set to unsecure, the MEEN setting does not matter.
 *
 * Values:
 * - 00 - Mass erase is enabled
 * - 01 - Mass erase is enabled
 * - 10 - Mass erase is disabled
 * - 11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_MEEN field. */
#define FTFA_RD_FSEC_MEEN(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_MEEN_MASK) >> FTFA_FSEC_MEEN_SHIFT)
#define FTFA_BRD_FSEC_MEEN(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_MEEN_SHIFT, FTFA_FSEC_MEEN_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field KEYEN[7:6] (RO)
 *
 * Enables or disables backdoor key access to the flash memory module.
 *
 * Values:
 * - 00 - Backdoor key access disabled
 * - 01 - Backdoor key access disabled (preferred KEYEN state to disable
 *     backdoor key access)
 * - 10 - Backdoor key access enabled
 * - 11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_KEYEN field. */
#define FTFA_RD_FSEC_KEYEN(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_KEYEN_MASK) >> FTFA_FSEC_KEYEN_SHIFT)
#define FTFA_BRD_FSEC_KEYEN(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_KEYEN_SHIFT, FTFA_FSEC_KEYEN_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFA_FOPT - Flash Option Register
 ******************************************************************************/

/*!
 * @brief FTFA_FOPT - Flash Option Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash option register allows the MCU to customize its operations by
 * examining the state of these read-only bits, which are loaded from NVM at reset.
 * The function of the bits is defined in the device's Chip Configuration details.
 * All bits in the register are read-only . During the reset sequence, the
 * register is loaded from the flash nonvolatile option byte in the Flash Configuration
 * Field located in program flash memory. The flash basis for the values is
 * signified by X in the reset value.
 */
/*!
 * @name Constants and macros for entire FTFA_FOPT register
 */
/*@{*/
#define FTFA_RD_FOPT(base)       (FTFA_FOPT_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB3 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB3 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB3 register
 */
/*@{*/
#define FTFA_RD_FCCOB3(base)     (FTFA_FCCOB3_REG(base))
#define FTFA_WR_FCCOB3(base, value) (FTFA_FCCOB3_REG(base) = (value))
#define FTFA_RMW_FCCOB3(base, mask, value) (FTFA_WR_FCCOB3(base, (FTFA_RD_FCCOB3(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB3(base, value) (BME_OR8(&FTFA_FCCOB3_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB3(base, value) (BME_AND8(&FTFA_FCCOB3_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB3(base, value) (BME_XOR8(&FTFA_FCCOB3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB2 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB2 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB2 register
 */
/*@{*/
#define FTFA_RD_FCCOB2(base)     (FTFA_FCCOB2_REG(base))
#define FTFA_WR_FCCOB2(base, value) (FTFA_FCCOB2_REG(base) = (value))
#define FTFA_RMW_FCCOB2(base, mask, value) (FTFA_WR_FCCOB2(base, (FTFA_RD_FCCOB2(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB2(base, value) (BME_OR8(&FTFA_FCCOB2_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB2(base, value) (BME_AND8(&FTFA_FCCOB2_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB2(base, value) (BME_XOR8(&FTFA_FCCOB2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB1 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB1 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB1 register
 */
/*@{*/
#define FTFA_RD_FCCOB1(base)     (FTFA_FCCOB1_REG(base))
#define FTFA_WR_FCCOB1(base, value) (FTFA_FCCOB1_REG(base) = (value))
#define FTFA_RMW_FCCOB1(base, mask, value) (FTFA_WR_FCCOB1(base, (FTFA_RD_FCCOB1(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB1(base, value) (BME_OR8(&FTFA_FCCOB1_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB1(base, value) (BME_AND8(&FTFA_FCCOB1_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB1(base, value) (BME_XOR8(&FTFA_FCCOB1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB0 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB0 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB0 register
 */
/*@{*/
#define FTFA_RD_FCCOB0(base)     (FTFA_FCCOB0_REG(base))
#define FTFA_WR_FCCOB0(base, value) (FTFA_FCCOB0_REG(base) = (value))
#define FTFA_RMW_FCCOB0(base, mask, value) (FTFA_WR_FCCOB0(base, (FTFA_RD_FCCOB0(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB0(base, value) (BME_OR8(&FTFA_FCCOB0_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB0(base, value) (BME_AND8(&FTFA_FCCOB0_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB0(base, value) (BME_XOR8(&FTFA_FCCOB0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB7 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB7 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB7 register
 */
/*@{*/
#define FTFA_RD_FCCOB7(base)     (FTFA_FCCOB7_REG(base))
#define FTFA_WR_FCCOB7(base, value) (FTFA_FCCOB7_REG(base) = (value))
#define FTFA_RMW_FCCOB7(base, mask, value) (FTFA_WR_FCCOB7(base, (FTFA_RD_FCCOB7(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB7(base, value) (BME_OR8(&FTFA_FCCOB7_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB7(base, value) (BME_AND8(&FTFA_FCCOB7_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB7(base, value) (BME_XOR8(&FTFA_FCCOB7_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB6 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB6 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB6 register
 */
/*@{*/
#define FTFA_RD_FCCOB6(base)     (FTFA_FCCOB6_REG(base))
#define FTFA_WR_FCCOB6(base, value) (FTFA_FCCOB6_REG(base) = (value))
#define FTFA_RMW_FCCOB6(base, mask, value) (FTFA_WR_FCCOB6(base, (FTFA_RD_FCCOB6(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB6(base, value) (BME_OR8(&FTFA_FCCOB6_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB6(base, value) (BME_AND8(&FTFA_FCCOB6_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB6(base, value) (BME_XOR8(&FTFA_FCCOB6_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB5 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB5 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB5 register
 */
/*@{*/
#define FTFA_RD_FCCOB5(base)     (FTFA_FCCOB5_REG(base))
#define FTFA_WR_FCCOB5(base, value) (FTFA_FCCOB5_REG(base) = (value))
#define FTFA_RMW_FCCOB5(base, mask, value) (FTFA_WR_FCCOB5(base, (FTFA_RD_FCCOB5(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB5(base, value) (BME_OR8(&FTFA_FCCOB5_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB5(base, value) (BME_AND8(&FTFA_FCCOB5_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB5(base, value) (BME_XOR8(&FTFA_FCCOB5_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB4 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB4 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB4 register
 */
/*@{*/
#define FTFA_RD_FCCOB4(base)     (FTFA_FCCOB4_REG(base))
#define FTFA_WR_FCCOB4(base, value) (FTFA_FCCOB4_REG(base) = (value))
#define FTFA_RMW_FCCOB4(base, mask, value) (FTFA_WR_FCCOB4(base, (FTFA_RD_FCCOB4(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB4(base, value) (BME_OR8(&FTFA_FCCOB4_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB4(base, value) (BME_AND8(&FTFA_FCCOB4_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB4(base, value) (BME_XOR8(&FTFA_FCCOB4_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOBB - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOBB - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOBB register
 */
/*@{*/
#define FTFA_RD_FCCOBB(base)     (FTFA_FCCOBB_REG(base))
#define FTFA_WR_FCCOBB(base, value) (FTFA_FCCOBB_REG(base) = (value))
#define FTFA_RMW_FCCOBB(base, mask, value) (FTFA_WR_FCCOBB(base, (FTFA_RD_FCCOBB(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOBB(base, value) (BME_OR8(&FTFA_FCCOBB_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOBB(base, value) (BME_AND8(&FTFA_FCCOBB_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOBB(base, value) (BME_XOR8(&FTFA_FCCOBB_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOBA - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOBA - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOBA register
 */
/*@{*/
#define FTFA_RD_FCCOBA(base)     (FTFA_FCCOBA_REG(base))
#define FTFA_WR_FCCOBA(base, value) (FTFA_FCCOBA_REG(base) = (value))
#define FTFA_RMW_FCCOBA(base, mask, value) (FTFA_WR_FCCOBA(base, (FTFA_RD_FCCOBA(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOBA(base, value) (BME_OR8(&FTFA_FCCOBA_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOBA(base, value) (BME_AND8(&FTFA_FCCOBA_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOBA(base, value) (BME_XOR8(&FTFA_FCCOBA_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB9 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB9 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB9 register
 */
/*@{*/
#define FTFA_RD_FCCOB9(base)     (FTFA_FCCOB9_REG(base))
#define FTFA_WR_FCCOB9(base, value) (FTFA_FCCOB9_REG(base) = (value))
#define FTFA_RMW_FCCOB9(base, mask, value) (FTFA_WR_FCCOB9(base, (FTFA_RD_FCCOB9(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB9(base, value) (BME_OR8(&FTFA_FCCOB9_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB9(base, value) (BME_AND8(&FTFA_FCCOB9_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB9(base, value) (BME_XOR8(&FTFA_FCCOB9_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB8 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB8 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB8 register
 */
/*@{*/
#define FTFA_RD_FCCOB8(base)     (FTFA_FCCOB8_REG(base))
#define FTFA_WR_FCCOB8(base, value) (FTFA_FCCOB8_REG(base) = (value))
#define FTFA_RMW_FCCOB8(base, mask, value) (FTFA_WR_FCCOB8(base, (FTFA_RD_FCCOB8(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB8(base, value) (BME_OR8(&FTFA_FCCOB8_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB8(base, value) (BME_AND8(&FTFA_FCCOB8_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB8(base, value) (BME_XOR8(&FTFA_FCCOB8_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT3 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT3 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address FPROT0
 * 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT3 register
 */
/*@{*/
#define FTFA_RD_FPROT3(base)     (FTFA_FPROT3_REG(base))
#define FTFA_WR_FPROT3(base, value) (FTFA_FPROT3_REG(base) = (value))
#define FTFA_RMW_FPROT3(base, mask, value) (FTFA_WR_FPROT3(base, (FTFA_RD_FPROT3(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT3(base, value) (BME_OR8(&FTFA_FPROT3_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT3(base, value) (BME_AND8(&FTFA_FPROT3_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT3(base, value) (BME_XOR8(&FTFA_FPROT3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT2 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT2 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address FPROT0
 * 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT2 register
 */
/*@{*/
#define FTFA_RD_FPROT2(base)     (FTFA_FPROT2_REG(base))
#define FTFA_WR_FPROT2(base, value) (FTFA_FPROT2_REG(base) = (value))
#define FTFA_RMW_FPROT2(base, mask, value) (FTFA_WR_FPROT2(base, (FTFA_RD_FPROT2(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT2(base, value) (BME_OR8(&FTFA_FPROT2_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT2(base, value) (BME_AND8(&FTFA_FPROT2_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT2(base, value) (BME_XOR8(&FTFA_FPROT2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT1 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT1 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address FPROT0
 * 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT1 register
 */
/*@{*/
#define FTFA_RD_FPROT1(base)     (FTFA_FPROT1_REG(base))
#define FTFA_WR_FPROT1(base, value) (FTFA_FPROT1_REG(base) = (value))
#define FTFA_RMW_FPROT1(base, mask, value) (FTFA_WR_FPROT1(base, (FTFA_RD_FPROT1(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT1(base, value) (BME_OR8(&FTFA_FPROT1_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT1(base, value) (BME_AND8(&FTFA_FPROT1_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT1(base, value) (BME_XOR8(&FTFA_FPROT1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT0 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT0 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address FPROT0
 * 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT0 register
 */
/*@{*/
#define FTFA_RD_FPROT0(base)     (FTFA_FPROT0_REG(base))
#define FTFA_WR_FPROT0(base, value) (FTFA_FPROT0_REG(base) = (value))
#define FTFA_RMW_FPROT0(base, mask, value) (FTFA_WR_FPROT0(base, (FTFA_RD_FPROT0(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT0(base, value) (BME_OR8(&FTFA_FPROT0_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT0(base, value) (BME_AND8(&FTFA_FPROT0_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT0(base, value) (BME_XOR8(&FTFA_FPROT0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * MKV10Z7 FTM
 *
 * FlexTimer Module
 *
 * Registers defined in this header file:
 * - FTM_SC - Status And Control
 * - FTM_CNT - Counter
 * - FTM_MOD - Modulo
 * - FTM_CnSC - Channel (n) Status And Control
 * - FTM_CnV - Channel (n) Value
 * - FTM_CNTIN - Counter Initial Value
 * - FTM_STATUS - Capture And Compare Status
 * - FTM_MODE - Features Mode Selection
 * - FTM_SYNC - Synchronization
 * - FTM_OUTINIT - Initial State For Channels Output
 * - FTM_OUTMASK - Output Mask
 * - FTM_COMBINE - Function For Linked Channels
 * - FTM_DEADTIME - Deadtime Insertion Control
 * - FTM_EXTTRIG - FTM External Trigger
 * - FTM_POL - Channels Polarity
 * - FTM_FMS - Fault Mode Status
 * - FTM_FILTER - Input Capture Filter Control
 * - FTM_FLTCTRL - Fault Control
 * - FTM_QDCTRL - Quadrature Decoder Control And Status
 * - FTM_CONF - Configuration
 * - FTM_FLTPOL - FTM Fault Input Polarity
 * - FTM_SYNCONF - Synchronization Configuration
 * - FTM_INVCTRL - FTM Inverting Control
 * - FTM_SWOCTRL - FTM Software Output Control
 * - FTM_PWMLOAD - FTM PWM Load
 */

#define FTM_INSTANCE_COUNT (3U) /*!< Number of instances of the FTM module. */
#define FTM0_IDX (0U) /*!< Instance number for FTM0. */
#define FTM1_IDX (1U) /*!< Instance number for FTM1. */
#define FTM2_IDX (2U) /*!< Instance number for FTM2. */

/*******************************************************************************
 * FTM_SC - Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_SC - Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * SC contains the overflow status flag and control bits used to configure the
 * interrupt enable, FTM configuration, clock source, and prescaler factor. These
 * controls relate to all channels within this module.
 */
/*!
 * @name Constants and macros for entire FTM_SC register
 */
/*@{*/
#define FTM_RD_SC(base)          (FTM_SC_REG(base))
#define FTM_WR_SC(base, value)   (FTM_SC_REG(base) = (value))
#define FTM_RMW_SC(base, mask, value) (FTM_WR_SC(base, (FTM_RD_SC(base) & ~(mask)) | (value)))
#define FTM_SET_SC(base, value)  (BME_OR32(&FTM_SC_REG(base), (uint32_t)(value)))
#define FTM_CLR_SC(base, value)  (BME_AND32(&FTM_SC_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_SC(base, value)  (BME_XOR32(&FTM_SC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SC bitfields
 */

/*!
 * @name Register FTM_SC, field PS[2:0] (RW)
 *
 * Selects one of 8 division factors for the clock source selected by CLKS. The
 * new prescaler factor affects the clock source on the next system clock cycle
 * after the new value is updated into the register bits. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 000 - Divide by 1
 * - 001 - Divide by 2
 * - 010 - Divide by 4
 * - 011 - Divide by 8
 * - 100 - Divide by 16
 * - 101 - Divide by 32
 * - 110 - Divide by 64
 * - 111 - Divide by 128
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_PS field. */
#define FTM_RD_SC_PS(base)   ((FTM_SC_REG(base) & FTM_SC_PS_MASK) >> FTM_SC_PS_SHIFT)
#define FTM_BRD_SC_PS(base)  (BME_UBFX32(&FTM_SC_REG(base), FTM_SC_PS_SHIFT, FTM_SC_PS_WIDTH))

/*! @brief Set the PS field to a new value. */
#define FTM_WR_SC_PS(base, value) (FTM_RMW_SC(base, FTM_SC_PS_MASK, FTM_SC_PS(value)))
#define FTM_BWR_SC_PS(base, value) (BME_BFI32(&FTM_SC_REG(base), ((uint32_t)(value) << FTM_SC_PS_SHIFT), FTM_SC_PS_SHIFT, FTM_SC_PS_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SC, field CLKS[4:3] (RW)
 *
 * Selects one of the three FTM counter clock sources. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 00 - No clock selected. This in effect disables the FTM counter.
 * - 01 - System clock
 * - 10 - Fixed frequency clock
 * - 11 - External clock
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_CLKS field. */
#define FTM_RD_SC_CLKS(base) ((FTM_SC_REG(base) & FTM_SC_CLKS_MASK) >> FTM_SC_CLKS_SHIFT)
#define FTM_BRD_SC_CLKS(base) (BME_UBFX32(&FTM_SC_REG(base), FTM_SC_CLKS_SHIFT, FTM_SC_CLKS_WIDTH))

/*! @brief Set the CLKS field to a new value. */
#define FTM_WR_SC_CLKS(base, value) (FTM_RMW_SC(base, FTM_SC_CLKS_MASK, FTM_SC_CLKS(value)))
#define FTM_BWR_SC_CLKS(base, value) (BME_BFI32(&FTM_SC_REG(base), ((uint32_t)(value) << FTM_SC_CLKS_SHIFT), FTM_SC_CLKS_SHIFT, FTM_SC_CLKS_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SC, field CPWMS[5] (RW)
 *
 * Selects CPWM mode. This mode configures the FTM to operate in Up-Down
 * Counting mode. This field is write protected. It can be written only when MODE[WPDIS]
 * = 1.
 *
 * Values:
 * - 0 - FTM counter operates in Up Counting mode.
 * - 1 - FTM counter operates in Up-Down Counting mode.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_CPWMS field. */
#define FTM_RD_SC_CPWMS(base) ((FTM_SC_REG(base) & FTM_SC_CPWMS_MASK) >> FTM_SC_CPWMS_SHIFT)
#define FTM_BRD_SC_CPWMS(base) (BME_UBFX32(&FTM_SC_REG(base), FTM_SC_CPWMS_SHIFT, FTM_SC_CPWMS_WIDTH))

/*! @brief Set the CPWMS field to a new value. */
#define FTM_WR_SC_CPWMS(base, value) (FTM_RMW_SC(base, FTM_SC_CPWMS_MASK, FTM_SC_CPWMS(value)))
#define FTM_BWR_SC_CPWMS(base, value) (BME_BFI32(&FTM_SC_REG(base), ((uint32_t)(value) << FTM_SC_CPWMS_SHIFT), FTM_SC_CPWMS_SHIFT, FTM_SC_CPWMS_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SC, field TOIE[6] (RW)
 *
 * Enables FTM overflow interrupts.
 *
 * Values:
 * - 0 - Disable TOF interrupts. Use software polling.
 * - 1 - Enable TOF interrupts. An interrupt is generated when TOF equals one.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_TOIE field. */
#define FTM_RD_SC_TOIE(base) ((FTM_SC_REG(base) & FTM_SC_TOIE_MASK) >> FTM_SC_TOIE_SHIFT)
#define FTM_BRD_SC_TOIE(base) (BME_UBFX32(&FTM_SC_REG(base), FTM_SC_TOIE_SHIFT, FTM_SC_TOIE_WIDTH))

/*! @brief Set the TOIE field to a new value. */
#define FTM_WR_SC_TOIE(base, value) (FTM_RMW_SC(base, FTM_SC_TOIE_MASK, FTM_SC_TOIE(value)))
#define FTM_BWR_SC_TOIE(base, value) (BME_BFI32(&FTM_SC_REG(base), ((uint32_t)(value) << FTM_SC_TOIE_SHIFT), FTM_SC_TOIE_SHIFT, FTM_SC_TOIE_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SC, field TOF[7] (ROWZ)
 *
 * Set by hardware when the FTM counter passes the value in the MOD register.
 * The TOF bit is cleared by reading the SC register while TOF is set and then
 * writing a 0 to TOF bit. Writing a 1 to TOF has no effect. If another FTM overflow
 * occurs between the read and write operations, the write operation has no
 * effect; therefore, TOF remains set indicating an overflow has occurred. In this
 * case, a TOF interrupt request is not lost due to the clearing sequence for a
 * previous TOF.
 *
 * Values:
 * - 0 - FTM counter has not overflowed.
 * - 1 - FTM counter has overflowed.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_TOF field. */
#define FTM_RD_SC_TOF(base)  ((FTM_SC_REG(base) & FTM_SC_TOF_MASK) >> FTM_SC_TOF_SHIFT)
#define FTM_BRD_SC_TOF(base) (BME_UBFX32(&FTM_SC_REG(base), FTM_SC_TOF_SHIFT, FTM_SC_TOF_WIDTH))

/*! @brief Set the TOF field to a new value. */
#define FTM_WR_SC_TOF(base, value) (FTM_RMW_SC(base, FTM_SC_TOF_MASK, FTM_SC_TOF(value)))
#define FTM_BWR_SC_TOF(base, value) (BME_BFI32(&FTM_SC_REG(base), ((uint32_t)(value) << FTM_SC_TOF_SHIFT), FTM_SC_TOF_SHIFT, FTM_SC_TOF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_CNT - Counter
 ******************************************************************************/

/*!
 * @brief FTM_CNT - Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CNT register contains the FTM counter value. Reset clears the CNT
 * register. Writing any value to COUNT updates the counter with its initial value,
 * CNTIN. When BDM is active, the FTM counter is frozen. This is the value that you
 * may read.
 */
/*!
 * @name Constants and macros for entire FTM_CNT register
 */
/*@{*/
#define FTM_RD_CNT(base)         (FTM_CNT_REG(base))
#define FTM_WR_CNT(base, value)  (FTM_CNT_REG(base) = (value))
#define FTM_RMW_CNT(base, mask, value) (FTM_WR_CNT(base, (FTM_RD_CNT(base) & ~(mask)) | (value)))
#define FTM_SET_CNT(base, value) (BME_OR32(&FTM_CNT_REG(base), (uint32_t)(value)))
#define FTM_CLR_CNT(base, value) (BME_AND32(&FTM_CNT_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_CNT(base, value) (BME_XOR32(&FTM_CNT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CNT bitfields
 */

/*!
 * @name Register FTM_CNT, field COUNT[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the FTM_CNT_COUNT field. */
#define FTM_RD_CNT_COUNT(base) ((FTM_CNT_REG(base) & FTM_CNT_COUNT_MASK) >> FTM_CNT_COUNT_SHIFT)
#define FTM_BRD_CNT_COUNT(base) (BME_UBFX32(&FTM_CNT_REG(base), FTM_CNT_COUNT_SHIFT, FTM_CNT_COUNT_WIDTH))

/*! @brief Set the COUNT field to a new value. */
#define FTM_WR_CNT_COUNT(base, value) (FTM_RMW_CNT(base, FTM_CNT_COUNT_MASK, FTM_CNT_COUNT(value)))
#define FTM_BWR_CNT_COUNT(base, value) (BME_BFI32(&FTM_CNT_REG(base), ((uint32_t)(value) << FTM_CNT_COUNT_SHIFT), FTM_CNT_COUNT_SHIFT, FTM_CNT_COUNT_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_MOD - Modulo
 ******************************************************************************/

/*!
 * @brief FTM_MOD - Modulo (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Modulo register contains the modulo value for the FTM counter. After the
 * FTM counter reaches the modulo value, the overflow flag (TOF) becomes set at
 * the next clock, and the next value of FTM counter depends on the selected
 * counting method; see Counter. Writing to the MOD register latches the value into a
 * buffer. The MOD register is updated with the value of its write buffer
 * according to Registers updated from write buffers. If FTMEN = 0, this write coherency
 * mechanism may be manually reset by writing to the SC register whether BDM is
 * active or not. Initialize the FTM counter, by writing to CNT, before writing
 * to the MOD register to avoid confusion about when the first counter overflow
 * will occur.
 */
/*!
 * @name Constants and macros for entire FTM_MOD register
 */
/*@{*/
#define FTM_RD_MOD(base)         (FTM_MOD_REG(base))
#define FTM_WR_MOD(base, value)  (FTM_MOD_REG(base) = (value))
#define FTM_RMW_MOD(base, mask, value) (FTM_WR_MOD(base, (FTM_RD_MOD(base) & ~(mask)) | (value)))
#define FTM_SET_MOD(base, value) (BME_OR32(&FTM_MOD_REG(base), (uint32_t)(value)))
#define FTM_CLR_MOD(base, value) (BME_AND32(&FTM_MOD_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_MOD(base, value) (BME_XOR32(&FTM_MOD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_MOD bitfields
 */

/*!
 * @name Register FTM_MOD, field MOD[15:0] (RW)
 *
 * Modulo Value
 */
/*@{*/
/*! @brief Read current value of the FTM_MOD_MOD field. */
#define FTM_RD_MOD_MOD(base) ((FTM_MOD_REG(base) & FTM_MOD_MOD_MASK) >> FTM_MOD_MOD_SHIFT)
#define FTM_BRD_MOD_MOD(base) (BME_UBFX32(&FTM_MOD_REG(base), FTM_MOD_MOD_SHIFT, FTM_MOD_MOD_WIDTH))

/*! @brief Set the MOD field to a new value. */
#define FTM_WR_MOD_MOD(base, value) (FTM_RMW_MOD(base, FTM_MOD_MOD_MASK, FTM_MOD_MOD(value)))
#define FTM_BWR_MOD_MOD(base, value) (BME_BFI32(&FTM_MOD_REG(base), ((uint32_t)(value) << FTM_MOD_MOD_SHIFT), FTM_MOD_MOD_SHIFT, FTM_MOD_MOD_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_CnSC - Channel (n) Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_CnSC - Channel (n) Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. Mode,
 * edge, and level selection DECAPEN COMBINE CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X X X XX 00 Pin not used for FTM-revert the channel pin to general
 * purpose I/O or other peripheral control 0 0 0 00 01 Input Capture Capture on
 * Rising Edge Only 10 Capture on Falling Edge Only 11 Capture on Rising or Falling
 * Edge 01 01 Output Compare Toggle Output on match 10 Clear Output on match 11
 * Set Output on match 1X 10 Edge-Aligned PWM High-true pulses (clear Output on
 * match) X1 Low-true pulses (set Output on match) 1 XX 10 Center-Aligned PWM
 * High-true pulses (clear Output on match-up) X1 Low-true pulses (set Output on
 * match-up) 1 0 XX 10 Combine PWM High-true pulses (set on channel (n) match, and
 * clear on channel (n+1) match) X1 Low-true pulses (clear on channel (n) match, and
 * set on channel (n+1) match) 1 0 0 X0 See the following table (#ModeSel2Table).
 * Dual Edge Capture One-Shot Capture mode X1 Continuous Capture mode Dual Edge
 * Capture mode - edge polarity selection ELSnB ELSnA Channel Port Enable
 * Detected Edges 0 0 Disabled No edge 0 1 Enabled Rising edge 1 0 Enabled Falling edge
 * 1 1 Enabled Rising and falling edges
 */
/*!
 * @name Constants and macros for entire FTM_CnSC register
 */
/*@{*/
#define FTM_RD_CnSC(base, index) (FTM_CnSC_REG(base, index))
#define FTM_WR_CnSC(base, index, value) (FTM_CnSC_REG(base, index) = (value))
#define FTM_RMW_CnSC(base, index, mask, value) (FTM_WR_CnSC(base, index, (FTM_RD_CnSC(base, index) & ~(mask)) | (value)))
#define FTM_SET_CnSC(base, index, value) (BME_OR32(&FTM_CnSC_REG(base, index), (uint32_t)(value)))
#define FTM_CLR_CnSC(base, index, value) (BME_AND32(&FTM_CnSC_REG(base, index), (uint32_t)(~(value))))
#define FTM_TOG_CnSC(base, index, value) (BME_XOR32(&FTM_CnSC_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CnSC bitfields
 */

/*!
 * @name Register FTM_CnSC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0 - Disable DMA transfers.
 * - 1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_DMA field. */
#define FTM_RD_CnSC_DMA(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_DMA_MASK) >> FTM_CnSC_DMA_SHIFT)
#define FTM_BRD_CnSC_DMA(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_DMA_SHIFT, FTM_CnSC_DMA_WIDTH))

/*! @brief Set the DMA field to a new value. */
#define FTM_WR_CnSC_DMA(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_DMA_MASK, FTM_CnSC_DMA(value)))
#define FTM_BWR_CnSC_DMA(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_DMA_SHIFT), FTM_CnSC_DMA_SHIFT, FTM_CnSC_DMA_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field ICRST[1] (RW)
 *
 * FTM counter reset is driven by the selected event of the channel (n) in the
 * Input Capture mode. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - FTM counter is not reset when the selected channel (n) input event is
 *     detected.
 * - 1 - FTM counter is reset when the selected channel (n) input event is
 *     detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_ICRST field. */
#define FTM_RD_CnSC_ICRST(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_ICRST_MASK) >> FTM_CnSC_ICRST_SHIFT)
#define FTM_BRD_CnSC_ICRST(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_ICRST_SHIFT, FTM_CnSC_ICRST_WIDTH))

/*! @brief Set the ICRST field to a new value. */
#define FTM_WR_CnSC_ICRST(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_ICRST_MASK, FTM_CnSC_ICRST(value)))
#define FTM_BWR_CnSC_ICRST(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_ICRST_SHIFT), FTM_CnSC_ICRST_SHIFT, FTM_CnSC_ICRST_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See
 * #ModeSel1Table. This field is write protected. It can be written only when MODE[WPDIS]
 * = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_ELSA field. */
#define FTM_RD_CnSC_ELSA(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_ELSA_MASK) >> FTM_CnSC_ELSA_SHIFT)
#define FTM_BRD_CnSC_ELSA(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_ELSA_SHIFT, FTM_CnSC_ELSA_WIDTH))

/*! @brief Set the ELSA field to a new value. */
#define FTM_WR_CnSC_ELSA(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_ELSA_MASK, FTM_CnSC_ELSA(value)))
#define FTM_BWR_CnSC_ELSA(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_ELSA_SHIFT), FTM_CnSC_ELSA_SHIFT, FTM_CnSC_ELSA_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See
 * #ModeSel1Table. This field is write protected. It can be written only when MODE[WPDIS]
 * = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_ELSB field. */
#define FTM_RD_CnSC_ELSB(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_ELSB_MASK) >> FTM_CnSC_ELSB_SHIFT)
#define FTM_BRD_CnSC_ELSB(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_ELSB_SHIFT, FTM_CnSC_ELSB_WIDTH))

/*! @brief Set the ELSB field to a new value. */
#define FTM_WR_CnSC_ELSB(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_ELSB_MASK, FTM_CnSC_ELSB(value)))
#define FTM_BWR_CnSC_ELSB(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_ELSB_SHIFT), FTM_CnSC_ELSB_SHIFT, FTM_CnSC_ELSB_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See #ModeSel1Table. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_MSA field. */
#define FTM_RD_CnSC_MSA(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_MSA_MASK) >> FTM_CnSC_MSA_SHIFT)
#define FTM_BRD_CnSC_MSA(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_MSA_SHIFT, FTM_CnSC_MSA_WIDTH))

/*! @brief Set the MSA field to a new value. */
#define FTM_WR_CnSC_MSA(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_MSA_MASK, FTM_CnSC_MSA(value)))
#define FTM_BWR_CnSC_MSA(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_MSA_SHIFT), FTM_CnSC_MSA_SHIFT, FTM_CnSC_MSA_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See #ModeSel1Table. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_MSB field. */
#define FTM_RD_CnSC_MSB(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_MSB_MASK) >> FTM_CnSC_MSB_SHIFT)
#define FTM_BRD_CnSC_MSB(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_MSB_SHIFT, FTM_CnSC_MSB_WIDTH))

/*! @brief Set the MSB field to a new value. */
#define FTM_WR_CnSC_MSB(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_MSB_MASK, FTM_CnSC_MSB(value)))
#define FTM_BWR_CnSC_MSB(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_MSB_SHIFT), FTM_CnSC_MSB_SHIFT, FTM_CnSC_MSB_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0 - Disable channel interrupts. Use software polling.
 * - 1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_CHIE field. */
#define FTM_RD_CnSC_CHIE(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_CHIE_MASK) >> FTM_CnSC_CHIE_SHIFT)
#define FTM_BRD_CnSC_CHIE(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_CHIE_SHIFT, FTM_CnSC_CHIE_WIDTH))

/*! @brief Set the CHIE field to a new value. */
#define FTM_WR_CnSC_CHIE(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_CHIE_MASK, FTM_CnSC_CHIE(value)))
#define FTM_BWR_CnSC_CHIE(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_CHIE_SHIFT), FTM_CnSC_CHIE_SHIFT, FTM_CnSC_CHIE_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field CHF[7] (ROWZ)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * reading the CSC register while CHnF is set and then writing a 0 to the CHF bit.
 * Writing a 1 to CHF has no effect. If another event occurs between the read and
 * write operations, the write operation has no effect; therefore, CHF remains set
 * indicating an event has occurred. In this case a CHF interrupt request is not
 * lost due to the clearing sequence for a previous CHF.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_CHF field. */
#define FTM_RD_CnSC_CHF(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_CHF_MASK) >> FTM_CnSC_CHF_SHIFT)
#define FTM_BRD_CnSC_CHF(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_CHF_SHIFT, FTM_CnSC_CHF_WIDTH))

/*! @brief Set the CHF field to a new value. */
#define FTM_WR_CnSC_CHF(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_CHF_MASK, FTM_CnSC_CHF(value)))
#define FTM_BWR_CnSC_CHF(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_CHF_SHIFT), FTM_CnSC_CHF_SHIFT, FTM_CnSC_CHF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_CnV - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief FTM_CnV - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured FTM counter value for the input modes or
 * the match value for the output modes. In Input Capture, Capture Test, and
 * Dual Edge Capture modes, any write to a CnV register is ignored. In output modes,
 * writing to a CnV register latches the value into a buffer. A CnV register is
 * updated with the value of its write buffer according to Registers updated from
 * write buffers. If FTMEN = 0, this write coherency mechanism may be manually
 * reset by writing to the CnSC register whether BDM mode is active or not.
 */
/*!
 * @name Constants and macros for entire FTM_CnV register
 */
/*@{*/
#define FTM_RD_CnV(base, index)  (FTM_CnV_REG(base, index))
#define FTM_WR_CnV(base, index, value) (FTM_CnV_REG(base, index) = (value))
#define FTM_RMW_CnV(base, index, mask, value) (FTM_WR_CnV(base, index, (FTM_RD_CnV(base, index) & ~(mask)) | (value)))
#define FTM_SET_CnV(base, index, value) (BME_OR32(&FTM_CnV_REG(base, index), (uint32_t)(value)))
#define FTM_CLR_CnV(base, index, value) (BME_AND32(&FTM_CnV_REG(base, index), (uint32_t)(~(value))))
#define FTM_TOG_CnV(base, index, value) (BME_XOR32(&FTM_CnV_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CnV bitfields
 */

/*!
 * @name Register FTM_CnV, field VAL[15:0] (RW)
 *
 * Captured FTM counter value of the input modes or the match value for the
 * output modes
 */
/*@{*/
/*! @brief Read current value of the FTM_CnV_VAL field. */
#define FTM_RD_CnV_VAL(base, index) ((FTM_CnV_REG(base, index) & FTM_CnV_VAL_MASK) >> FTM_CnV_VAL_SHIFT)
#define FTM_BRD_CnV_VAL(base, index) (BME_UBFX32(&FTM_CnV_REG(base, index), FTM_CnV_VAL_SHIFT, FTM_CnV_VAL_WIDTH))

/*! @brief Set the VAL field to a new value. */
#define FTM_WR_CnV_VAL(base, index, value) (FTM_RMW_CnV(base, index, FTM_CnV_VAL_MASK, FTM_CnV_VAL(value)))
#define FTM_BWR_CnV_VAL(base, index, value) (BME_BFI32(&FTM_CnV_REG(base, index), ((uint32_t)(value) << FTM_CnV_VAL_SHIFT), FTM_CnV_VAL_SHIFT, FTM_CnV_VAL_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_CNTIN - Counter Initial Value
 ******************************************************************************/

/*!
 * @brief FTM_CNTIN - Counter Initial Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Counter Initial Value register contains the initial value for the FTM
 * counter. Writing to the CNTIN register latches the value into a buffer. The CNTIN
 * register is updated with the value of its write buffer according to Registers
 * updated from write buffers. When the FTM clock is initially selected, by
 * writing a non-zero value to the CLKS bits, the FTM counter starts with the value
 * 0x0000. To avoid this behavior, before the first write to select the FTM clock,
 * write the new value to the the CNTIN register and then initialize the FTM
 * counter by writing any value to the CNT register.
 */
/*!
 * @name Constants and macros for entire FTM_CNTIN register
 */
/*@{*/
#define FTM_RD_CNTIN(base)       (FTM_CNTIN_REG(base))
#define FTM_WR_CNTIN(base, value) (FTM_CNTIN_REG(base) = (value))
#define FTM_RMW_CNTIN(base, mask, value) (FTM_WR_CNTIN(base, (FTM_RD_CNTIN(base) & ~(mask)) | (value)))
#define FTM_SET_CNTIN(base, value) (BME_OR32(&FTM_CNTIN_REG(base), (uint32_t)(value)))
#define FTM_CLR_CNTIN(base, value) (BME_AND32(&FTM_CNTIN_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_CNTIN(base, value) (BME_XOR32(&FTM_CNTIN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CNTIN bitfields
 */

/*!
 * @name Register FTM_CNTIN, field INIT[15:0] (RW)
 *
 * Initial Value Of The FTM Counter
 */
/*@{*/
/*! @brief Read current value of the FTM_CNTIN_INIT field. */
#define FTM_RD_CNTIN_INIT(base) ((FTM_CNTIN_REG(base) & FTM_CNTIN_INIT_MASK) >> FTM_CNTIN_INIT_SHIFT)
#define FTM_BRD_CNTIN_INIT(base) (BME_UBFX32(&FTM_CNTIN_REG(base), FTM_CNTIN_INIT_SHIFT, FTM_CNTIN_INIT_WIDTH))

/*! @brief Set the INIT field to a new value. */
#define FTM_WR_CNTIN_INIT(base, value) (FTM_RMW_CNTIN(base, FTM_CNTIN_INIT_MASK, FTM_CNTIN_INIT(value)))
#define FTM_BWR_CNTIN_INIT(base, value) (BME_BFI32(&FTM_CNTIN_REG(base), ((uint32_t)(value) << FTM_CNTIN_INIT_SHIFT), FTM_CNTIN_INIT_SHIFT, FTM_CNTIN_INIT_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_STATUS - Capture And Compare Status
 ******************************************************************************/

/*!
 * @brief FTM_STATUS - Capture And Compare Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * The STATUS register contains a copy of the status flag CHnF bit in CnSC for
 * each FTM channel for software convenience. Each CHnF bit in STATUS is a mirror
 * of CHnF bit in CnSC. All CHnF bits can be checked using only one read of
 * STATUS. All CHnF bits can be cleared by reading STATUS followed by writing 0x00 to
 * STATUS. Hardware sets the individual channel flags when an event occurs on the
 * channel. CHnF is cleared by reading STATUS while CHnF is set and then writing
 * a 0 to the CHnF bit. Writing a 1 to CHnF has no effect. If another event
 * occurs between the read and write operations, the write operation has no effect;
 * therefore, CHnF remains set indicating an event has occurred. In this case, a
 * CHnF interrupt request is not lost due to the clearing sequence for a previous
 * CHnF.
 */
/*!
 * @name Constants and macros for entire FTM_STATUS register
 */
/*@{*/
#define FTM_RD_STATUS(base)      (FTM_STATUS_REG(base))
#define FTM_WR_STATUS(base, value) (FTM_STATUS_REG(base) = (value))
#define FTM_RMW_STATUS(base, mask, value) (FTM_WR_STATUS(base, (FTM_RD_STATUS(base) & ~(mask)) | (value)))
#define FTM_SET_STATUS(base, value) (BME_OR32(&FTM_STATUS_REG(base), (uint32_t)(value)))
#define FTM_CLR_STATUS(base, value) (BME_AND32(&FTM_STATUS_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_STATUS(base, value) (BME_XOR32(&FTM_STATUS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_STATUS bitfields
 */

/*!
 * @name Register FTM_STATUS, field CH0F[0] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH0F field. */
#define FTM_RD_STATUS_CH0F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH0F_MASK) >> FTM_STATUS_CH0F_SHIFT)
#define FTM_BRD_STATUS_CH0F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH0F_SHIFT, FTM_STATUS_CH0F_WIDTH))

/*! @brief Set the CH0F field to a new value. */
#define FTM_WR_STATUS_CH0F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH0F(value)))
#define FTM_BWR_STATUS_CH0F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH0F_SHIFT), FTM_STATUS_CH0F_SHIFT, FTM_STATUS_CH0F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH1F[1] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH1F field. */
#define FTM_RD_STATUS_CH1F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH1F_MASK) >> FTM_STATUS_CH1F_SHIFT)
#define FTM_BRD_STATUS_CH1F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH1F_SHIFT, FTM_STATUS_CH1F_WIDTH))

/*! @brief Set the CH1F field to a new value. */
#define FTM_WR_STATUS_CH1F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH1F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH1F(value)))
#define FTM_BWR_STATUS_CH1F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH1F_SHIFT), FTM_STATUS_CH1F_SHIFT, FTM_STATUS_CH1F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH2F[2] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH2F field. */
#define FTM_RD_STATUS_CH2F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH2F_MASK) >> FTM_STATUS_CH2F_SHIFT)
#define FTM_BRD_STATUS_CH2F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH2F_SHIFT, FTM_STATUS_CH2F_WIDTH))

/*! @brief Set the CH2F field to a new value. */
#define FTM_WR_STATUS_CH2F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH2F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH2F(value)))
#define FTM_BWR_STATUS_CH2F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH2F_SHIFT), FTM_STATUS_CH2F_SHIFT, FTM_STATUS_CH2F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH3F[3] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH3F field. */
#define FTM_RD_STATUS_CH3F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH3F_MASK) >> FTM_STATUS_CH3F_SHIFT)
#define FTM_BRD_STATUS_CH3F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH3F_SHIFT, FTM_STATUS_CH3F_WIDTH))

/*! @brief Set the CH3F field to a new value. */
#define FTM_WR_STATUS_CH3F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH3F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH3F(value)))
#define FTM_BWR_STATUS_CH3F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH3F_SHIFT), FTM_STATUS_CH3F_SHIFT, FTM_STATUS_CH3F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH4F[4] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH4F field. */
#define FTM_RD_STATUS_CH4F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH4F_MASK) >> FTM_STATUS_CH4F_SHIFT)
#define FTM_BRD_STATUS_CH4F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH4F_SHIFT, FTM_STATUS_CH4F_WIDTH))

/*! @brief Set the CH4F field to a new value. */
#define FTM_WR_STATUS_CH4F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH4F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH4F(value)))
#define FTM_BWR_STATUS_CH4F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH4F_SHIFT), FTM_STATUS_CH4F_SHIFT, FTM_STATUS_CH4F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH5F[5] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH5F field. */
#define FTM_RD_STATUS_CH5F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH5F_MASK) >> FTM_STATUS_CH5F_SHIFT)
#define FTM_BRD_STATUS_CH5F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH5F_SHIFT, FTM_STATUS_CH5F_WIDTH))

/*! @brief Set the CH5F field to a new value. */
#define FTM_WR_STATUS_CH5F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH5F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH5F(value)))
#define FTM_BWR_STATUS_CH5F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH5F_SHIFT), FTM_STATUS_CH5F_SHIFT, FTM_STATUS_CH5F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH6F[6] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH6F field. */
#define FTM_RD_STATUS_CH6F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH6F_MASK) >> FTM_STATUS_CH6F_SHIFT)
#define FTM_BRD_STATUS_CH6F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH6F_SHIFT, FTM_STATUS_CH6F_WIDTH))

/*! @brief Set the CH6F field to a new value. */
#define FTM_WR_STATUS_CH6F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH6F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH6F(value)))
#define FTM_BWR_STATUS_CH6F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH6F_SHIFT), FTM_STATUS_CH6F_SHIFT, FTM_STATUS_CH6F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH7F[7] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH7F field. */
#define FTM_RD_STATUS_CH7F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH7F_MASK) >> FTM_STATUS_CH7F_SHIFT)
#define FTM_BRD_STATUS_CH7F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH7F_SHIFT, FTM_STATUS_CH7F_WIDTH))

/*! @brief Set the CH7F field to a new value. */
#define FTM_WR_STATUS_CH7F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH7F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK), FTM_STATUS_CH7F(value)))
#define FTM_BWR_STATUS_CH7F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH7F_SHIFT), FTM_STATUS_CH7F_SHIFT, FTM_STATUS_CH7F_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_MODE - Features Mode Selection
 ******************************************************************************/

/*!
 * @brief FTM_MODE - Features Mode Selection (RW)
 *
 * Reset value: 0x00000004U
 *
 * This register contains the global enable bit for FTM-specific features and
 * the control bits used to configure: Fault control mode and interrupt Capture
 * Test mode PWM synchronization Write protection Channel output initialization
 * These controls relate to all channels within this module.
 */
/*!
 * @name Constants and macros for entire FTM_MODE register
 */
/*@{*/
#define FTM_RD_MODE(base)        (FTM_MODE_REG(base))
#define FTM_WR_MODE(base, value) (FTM_MODE_REG(base) = (value))
#define FTM_RMW_MODE(base, mask, value) (FTM_WR_MODE(base, (FTM_RD_MODE(base) & ~(mask)) | (value)))
#define FTM_SET_MODE(base, value) (BME_OR32(&FTM_MODE_REG(base), (uint32_t)(value)))
#define FTM_CLR_MODE(base, value) (BME_AND32(&FTM_MODE_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_MODE(base, value) (BME_XOR32(&FTM_MODE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_MODE bitfields
 */

/*!
 * @name Register FTM_MODE, field FTMEN[0] (RW)
 *
 * This field is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - TPM compatibility. Free running counter and synchronization compatible
 *     with TPM.
 * - 1 - Free running counter and synchronization are different from TPM
 *     behavior.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_FTMEN field. */
#define FTM_RD_MODE_FTMEN(base) ((FTM_MODE_REG(base) & FTM_MODE_FTMEN_MASK) >> FTM_MODE_FTMEN_SHIFT)
#define FTM_BRD_MODE_FTMEN(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_FTMEN_SHIFT, FTM_MODE_FTMEN_WIDTH))

/*! @brief Set the FTMEN field to a new value. */
#define FTM_WR_MODE_FTMEN(base, value) (FTM_RMW_MODE(base, FTM_MODE_FTMEN_MASK, FTM_MODE_FTMEN(value)))
#define FTM_BWR_MODE_FTMEN(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_FTMEN_SHIFT), FTM_MODE_FTMEN_SHIFT, FTM_MODE_FTMEN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_MODE, field INIT[1] (RW)
 *
 * When a 1 is written to INIT bit the channels output is initialized according
 * to the state of their corresponding bit in the OUTINIT register. Writing a 0
 * to INIT bit has no effect. The INIT bit is always read as 0.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_INIT field. */
#define FTM_RD_MODE_INIT(base) ((FTM_MODE_REG(base) & FTM_MODE_INIT_MASK) >> FTM_MODE_INIT_SHIFT)
#define FTM_BRD_MODE_INIT(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_INIT_SHIFT, FTM_MODE_INIT_WIDTH))

/*! @brief Set the INIT field to a new value. */
#define FTM_WR_MODE_INIT(base, value) (FTM_RMW_MODE(base, FTM_MODE_INIT_MASK, FTM_MODE_INIT(value)))
#define FTM_BWR_MODE_INIT(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_INIT_SHIFT), FTM_MODE_INIT_SHIFT, FTM_MODE_INIT_WIDTH))
/*@}*/

/*!
 * @name Register FTM_MODE, field WPDIS[2] (RW)
 *
 * When write protection is enabled (WPDIS = 0), write protected bits cannot be
 * written. When write protection is disabled (WPDIS = 1), write protected bits
 * can be written. The WPDIS bit is the negation of the WPEN bit. WPDIS is cleared
 * when 1 is written to WPEN. WPDIS is set when WPEN bit is read as a 1 and then
 * 1 is written to WPDIS. Writing 0 to WPDIS has no effect.
 *
 * Values:
 * - 0 - Write protection is enabled.
 * - 1 - Write protection is disabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_WPDIS field. */
#define FTM_RD_MODE_WPDIS(base) ((FTM_MODE_REG(base) & FTM_MODE_WPDIS_MASK) >> FTM_MODE_WPDIS_SHIFT)
#define FTM_BRD_MODE_WPDIS(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_WPDIS_SHIFT, FTM_MODE_WPDIS_WIDTH))

/*! @brief Set the WPDIS field to a new value. */
#define FTM_WR_MODE_WPDIS(base, value) (FTM_RMW_MODE(base, FTM_MODE_WPDIS_MASK, FTM_MODE_WPDIS(value)))
#define FTM_BWR_MODE_WPDIS(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_WPDIS_SHIFT), FTM_MODE_WPDIS_SHIFT, FTM_MODE_WPDIS_WIDTH))
/*@}*/

/*!
 * @name Register FTM_MODE, field PWMSYNC[3] (RW)
 *
 * Selects which triggers can be used by MOD, CnV, OUTMASK, and FTM counter
 * synchronization. See PWM synchronization. The PWMSYNC bit configures the
 * synchronization when SYNCMODE is 0.
 *
 * Values:
 * - 0 - No restrictions. Software and hardware triggers can be used by MOD,
 *     CnV, OUTMASK, and FTM counter synchronization.
 * - 1 - Software trigger can only be used by MOD and CnV synchronization, and
 *     hardware triggers can only be used by OUTMASK and FTM counter
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_PWMSYNC field. */
#define FTM_RD_MODE_PWMSYNC(base) ((FTM_MODE_REG(base) & FTM_MODE_PWMSYNC_MASK) >> FTM_MODE_PWMSYNC_SHIFT)
#define FTM_BRD_MODE_PWMSYNC(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_PWMSYNC_SHIFT, FTM_MODE_PWMSYNC_WIDTH))

/*! @brief Set the PWMSYNC field to a new value. */
#define FTM_WR_MODE_PWMSYNC(base, value) (FTM_RMW_MODE(base, FTM_MODE_PWMSYNC_MASK, FTM_MODE_PWMSYNC(value)))
#define FTM_BWR_MODE_PWMSYNC(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_PWMSYNC_SHIFT), FTM_MODE_PWMSYNC_SHIFT, FTM_MODE_PWMSYNC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_MODE, field CAPTEST[4] (RW)
 *
 * Enables the capture test mode. This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Capture test mode is disabled.
 * - 1 - Capture test mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_CAPTEST field. */
#define FTM_RD_MODE_CAPTEST(base) ((FTM_MODE_REG(base) & FTM_MODE_CAPTEST_MASK) >> FTM_MODE_CAPTEST_SHIFT)
#define FTM_BRD_MODE_CAPTEST(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_CAPTEST_SHIFT, FTM_MODE_CAPTEST_WIDTH))

/*! @brief Set the CAPTEST field to a new value. */
#define FTM_WR_MODE_CAPTEST(base, value) (FTM_RMW_MODE(base, FTM_MODE_CAPTEST_MASK, FTM_MODE_CAPTEST(value)))
#define FTM_BWR_MODE_CAPTEST(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_CAPTEST_SHIFT), FTM_MODE_CAPTEST_SHIFT, FTM_MODE_CAPTEST_WIDTH))
/*@}*/

/*!
 * @name Register FTM_MODE, field FAULTM[6:5] (RW)
 *
 * Defines the FTM fault control mode. This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 00 - Fault control is disabled for all channels.
 * - 01 - Fault control is enabled for even channels only (channels 0, 2, 4, and
 *     6), and the selected mode is the manual fault clearing.
 * - 10 - Fault control is enabled for all channels, and the selected mode is
 *     the manual fault clearing.
 * - 11 - Fault control is enabled for all channels, and the selected mode is
 *     the automatic fault clearing.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_FAULTM field. */
#define FTM_RD_MODE_FAULTM(base) ((FTM_MODE_REG(base) & FTM_MODE_FAULTM_MASK) >> FTM_MODE_FAULTM_SHIFT)
#define FTM_BRD_MODE_FAULTM(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_FAULTM_SHIFT, FTM_MODE_FAULTM_WIDTH))

/*! @brief Set the FAULTM field to a new value. */
#define FTM_WR_MODE_FAULTM(base, value) (FTM_RMW_MODE(base, FTM_MODE_FAULTM_MASK, FTM_MODE_FAULTM(value)))
#define FTM_BWR_MODE_FAULTM(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_FAULTM_SHIFT), FTM_MODE_FAULTM_SHIFT, FTM_MODE_FAULTM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_MODE, field FAULTIE[7] (RW)
 *
 * Enables the generation of an interrupt when a fault is detected by FTM and
 * the FTM fault control is enabled.
 *
 * Values:
 * - 0 - Fault control interrupt is disabled.
 * - 1 - Fault control interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_FAULTIE field. */
#define FTM_RD_MODE_FAULTIE(base) ((FTM_MODE_REG(base) & FTM_MODE_FAULTIE_MASK) >> FTM_MODE_FAULTIE_SHIFT)
#define FTM_BRD_MODE_FAULTIE(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_FAULTIE_SHIFT, FTM_MODE_FAULTIE_WIDTH))

/*! @brief Set the FAULTIE field to a new value. */
#define FTM_WR_MODE_FAULTIE(base, value) (FTM_RMW_MODE(base, FTM_MODE_FAULTIE_MASK, FTM_MODE_FAULTIE(value)))
#define FTM_BWR_MODE_FAULTIE(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_FAULTIE_SHIFT), FTM_MODE_FAULTIE_SHIFT, FTM_MODE_FAULTIE_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_SYNC - Synchronization
 ******************************************************************************/

/*!
 * @brief FTM_SYNC - Synchronization (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the PWM synchronization. A synchronization event can
 * perform the synchronized update of MOD, CV, and OUTMASK registers with the
 * value of their write buffer and the FTM counter initialization. The software
 * trigger, SWSYNC bit, and hardware triggers TRIG0, TRIG1, and TRIG2 bits have a
 * potential conflict if used together when SYNCMODE = 0. Use only hardware or
 * software triggers but not both at the same time, otherwise unpredictable behavior
 * is likely to happen. The selection of the loading point, CNTMAX and CNTMIN
 * bits, is intended to provide the update of MOD, CNTIN, and CnV registers across
 * all enabled channels simultaneously. The use of the loading point selection
 * together with SYNCMODE = 0 and hardware trigger selection, TRIG0, TRIG1, or TRIG2
 * bits, is likely to result in unpredictable behavior. The synchronization
 * event selection also depends on the PWMSYNC (MODE register) and SYNCMODE (SYNCONF
 * register) bits. See PWM synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_SYNC register
 */
/*@{*/
#define FTM_RD_SYNC(base)        (FTM_SYNC_REG(base))
#define FTM_WR_SYNC(base, value) (FTM_SYNC_REG(base) = (value))
#define FTM_RMW_SYNC(base, mask, value) (FTM_WR_SYNC(base, (FTM_RD_SYNC(base) & ~(mask)) | (value)))
#define FTM_SET_SYNC(base, value) (BME_OR32(&FTM_SYNC_REG(base), (uint32_t)(value)))
#define FTM_CLR_SYNC(base, value) (BME_AND32(&FTM_SYNC_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_SYNC(base, value) (BME_XOR32(&FTM_SYNC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SYNC bitfields
 */

/*!
 * @name Register FTM_SYNC, field CNTMIN[0] (RW)
 *
 * Selects the minimum loading point to PWM synchronization. See Boundary cycle
 * and loading points. If CNTMIN is one, the selected loading point is when the
 * FTM counter reaches its minimum value (CNTIN register).
 *
 * Values:
 * - 0 - The minimum loading point is disabled.
 * - 1 - The minimum loading point is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_CNTMIN field. */
#define FTM_RD_SYNC_CNTMIN(base) ((FTM_SYNC_REG(base) & FTM_SYNC_CNTMIN_MASK) >> FTM_SYNC_CNTMIN_SHIFT)
#define FTM_BRD_SYNC_CNTMIN(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_CNTMIN_SHIFT, FTM_SYNC_CNTMIN_WIDTH))

/*! @brief Set the CNTMIN field to a new value. */
#define FTM_WR_SYNC_CNTMIN(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_CNTMIN_MASK, FTM_SYNC_CNTMIN(value)))
#define FTM_BWR_SYNC_CNTMIN(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_CNTMIN_SHIFT), FTM_SYNC_CNTMIN_SHIFT, FTM_SYNC_CNTMIN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field CNTMAX[1] (RW)
 *
 * Selects the maximum loading point to PWM synchronization. See Boundary cycle
 * and loading points. If CNTMAX is 1, the selected loading point is when the FTM
 * counter reaches its maximum value (MOD register).
 *
 * Values:
 * - 0 - The maximum loading point is disabled.
 * - 1 - The maximum loading point is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_CNTMAX field. */
#define FTM_RD_SYNC_CNTMAX(base) ((FTM_SYNC_REG(base) & FTM_SYNC_CNTMAX_MASK) >> FTM_SYNC_CNTMAX_SHIFT)
#define FTM_BRD_SYNC_CNTMAX(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_CNTMAX_SHIFT, FTM_SYNC_CNTMAX_WIDTH))

/*! @brief Set the CNTMAX field to a new value. */
#define FTM_WR_SYNC_CNTMAX(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_CNTMAX_MASK, FTM_SYNC_CNTMAX(value)))
#define FTM_BWR_SYNC_CNTMAX(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_CNTMAX_SHIFT), FTM_SYNC_CNTMAX_SHIFT, FTM_SYNC_CNTMAX_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field REINIT[2] (RW)
 *
 * Determines if the FTM counter is reinitialized when the selected trigger for
 * the synchronization is detected. The REINIT bit configures the synchronization
 * when SYNCMODE is zero.
 *
 * Values:
 * - 0 - FTM counter continues to count normally.
 * - 1 - FTM counter is updated with its initial value when the selected trigger
 *     is detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_REINIT field. */
#define FTM_RD_SYNC_REINIT(base) ((FTM_SYNC_REG(base) & FTM_SYNC_REINIT_MASK) >> FTM_SYNC_REINIT_SHIFT)
#define FTM_BRD_SYNC_REINIT(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_REINIT_SHIFT, FTM_SYNC_REINIT_WIDTH))

/*! @brief Set the REINIT field to a new value. */
#define FTM_WR_SYNC_REINIT(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_REINIT_MASK, FTM_SYNC_REINIT(value)))
#define FTM_BWR_SYNC_REINIT(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_REINIT_SHIFT), FTM_SYNC_REINIT_SHIFT, FTM_SYNC_REINIT_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field SYNCHOM[3] (RW)
 *
 * Selects when the OUTMASK register is updated with the value of its buffer.
 *
 * Values:
 * - 0 - OUTMASK register is updated with the value of its buffer in all rising
 *     edges of the system clock.
 * - 1 - OUTMASK register is updated with the value of its buffer only by the
 *     PWM synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_SYNCHOM field. */
#define FTM_RD_SYNC_SYNCHOM(base) ((FTM_SYNC_REG(base) & FTM_SYNC_SYNCHOM_MASK) >> FTM_SYNC_SYNCHOM_SHIFT)
#define FTM_BRD_SYNC_SYNCHOM(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_SYNCHOM_SHIFT, FTM_SYNC_SYNCHOM_WIDTH))

/*! @brief Set the SYNCHOM field to a new value. */
#define FTM_WR_SYNC_SYNCHOM(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_SYNCHOM_MASK, FTM_SYNC_SYNCHOM(value)))
#define FTM_BWR_SYNC_SYNCHOM(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_SYNCHOM_SHIFT), FTM_SYNC_SYNCHOM_SHIFT, FTM_SYNC_SYNCHOM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG0[4] (RW)
 *
 * Enables hardware trigger 0 to the PWM synchronization. Hardware trigger 0
 * occurs when a rising edge is detected at the trigger 0 input signal.
 *
 * Values:
 * - 0 - Trigger is disabled.
 * - 1 - Trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_TRIG0 field. */
#define FTM_RD_SYNC_TRIG0(base) ((FTM_SYNC_REG(base) & FTM_SYNC_TRIG0_MASK) >> FTM_SYNC_TRIG0_SHIFT)
#define FTM_BRD_SYNC_TRIG0(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG0_SHIFT, FTM_SYNC_TRIG0_WIDTH))

/*! @brief Set the TRIG0 field to a new value. */
#define FTM_WR_SYNC_TRIG0(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_TRIG0_MASK, FTM_SYNC_TRIG0(value)))
#define FTM_BWR_SYNC_TRIG0(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_TRIG0_SHIFT), FTM_SYNC_TRIG0_SHIFT, FTM_SYNC_TRIG0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG1[5] (RW)
 *
 * Enables hardware trigger 1 to the PWM synchronization. Hardware trigger 1
 * happens when a rising edge is detected at the trigger 1 input signal.
 *
 * Values:
 * - 0 - Trigger is disabled.
 * - 1 - Trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_TRIG1 field. */
#define FTM_RD_SYNC_TRIG1(base) ((FTM_SYNC_REG(base) & FTM_SYNC_TRIG1_MASK) >> FTM_SYNC_TRIG1_SHIFT)
#define FTM_BRD_SYNC_TRIG1(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG1_SHIFT, FTM_SYNC_TRIG1_WIDTH))

/*! @brief Set the TRIG1 field to a new value. */
#define FTM_WR_SYNC_TRIG1(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_TRIG1_MASK, FTM_SYNC_TRIG1(value)))
#define FTM_BWR_SYNC_TRIG1(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_TRIG1_SHIFT), FTM_SYNC_TRIG1_SHIFT, FTM_SYNC_TRIG1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG2[6] (RW)
 *
 * Enables hardware trigger 2 to the PWM synchronization. Hardware trigger 2
 * happens when a rising edge is detected at the trigger 2 input signal.
 *
 * Values:
 * - 0 - Trigger is disabled.
 * - 1 - Trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_TRIG2 field. */
#define FTM_RD_SYNC_TRIG2(base) ((FTM_SYNC_REG(base) & FTM_SYNC_TRIG2_MASK) >> FTM_SYNC_TRIG2_SHIFT)
#define FTM_BRD_SYNC_TRIG2(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG2_SHIFT, FTM_SYNC_TRIG2_WIDTH))

/*! @brief Set the TRIG2 field to a new value. */
#define FTM_WR_SYNC_TRIG2(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_TRIG2_MASK, FTM_SYNC_TRIG2(value)))
#define FTM_BWR_SYNC_TRIG2(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_TRIG2_SHIFT), FTM_SYNC_TRIG2_SHIFT, FTM_SYNC_TRIG2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field SWSYNC[7] (RW)
 *
 * Selects the software trigger as the PWM synchronization trigger. The software
 * trigger happens when a 1 is written to SWSYNC bit.
 *
 * Values:
 * - 0 - Software trigger is not selected.
 * - 1 - Software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_SWSYNC field. */
#define FTM_RD_SYNC_SWSYNC(base) ((FTM_SYNC_REG(base) & FTM_SYNC_SWSYNC_MASK) >> FTM_SYNC_SWSYNC_SHIFT)
#define FTM_BRD_SYNC_SWSYNC(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_SWSYNC_SHIFT, FTM_SYNC_SWSYNC_WIDTH))

/*! @brief Set the SWSYNC field to a new value. */
#define FTM_WR_SYNC_SWSYNC(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_SWSYNC_MASK, FTM_SYNC_SWSYNC(value)))
#define FTM_BWR_SYNC_SWSYNC(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_SWSYNC_SHIFT), FTM_SYNC_SWSYNC_SHIFT, FTM_SYNC_SWSYNC_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_OUTINIT - Initial State For Channels Output
 ******************************************************************************/

/*!
 * @brief FTM_OUTINIT - Initial State For Channels Output (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FTM_OUTINIT register
 */
/*@{*/
#define FTM_RD_OUTINIT(base)     (FTM_OUTINIT_REG(base))
#define FTM_WR_OUTINIT(base, value) (FTM_OUTINIT_REG(base) = (value))
#define FTM_RMW_OUTINIT(base, mask, value) (FTM_WR_OUTINIT(base, (FTM_RD_OUTINIT(base) & ~(mask)) | (value)))
#define FTM_SET_OUTINIT(base, value) (BME_OR32(&FTM_OUTINIT_REG(base), (uint32_t)(value)))
#define FTM_CLR_OUTINIT(base, value) (BME_AND32(&FTM_OUTINIT_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_OUTINIT(base, value) (BME_XOR32(&FTM_OUTINIT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_OUTINIT bitfields
 */

/*!
 * @name Register FTM_OUTINIT, field CH0OI[0] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH0OI field. */
#define FTM_RD_OUTINIT_CH0OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH0OI_MASK) >> FTM_OUTINIT_CH0OI_SHIFT)
#define FTM_BRD_OUTINIT_CH0OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH0OI_SHIFT, FTM_OUTINIT_CH0OI_WIDTH))

/*! @brief Set the CH0OI field to a new value. */
#define FTM_WR_OUTINIT_CH0OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH0OI_MASK, FTM_OUTINIT_CH0OI(value)))
#define FTM_BWR_OUTINIT_CH0OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH0OI_SHIFT), FTM_OUTINIT_CH0OI_SHIFT, FTM_OUTINIT_CH0OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH1OI[1] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH1OI field. */
#define FTM_RD_OUTINIT_CH1OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH1OI_MASK) >> FTM_OUTINIT_CH1OI_SHIFT)
#define FTM_BRD_OUTINIT_CH1OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH1OI_SHIFT, FTM_OUTINIT_CH1OI_WIDTH))

/*! @brief Set the CH1OI field to a new value. */
#define FTM_WR_OUTINIT_CH1OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH1OI_MASK, FTM_OUTINIT_CH1OI(value)))
#define FTM_BWR_OUTINIT_CH1OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH1OI_SHIFT), FTM_OUTINIT_CH1OI_SHIFT, FTM_OUTINIT_CH1OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH2OI[2] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH2OI field. */
#define FTM_RD_OUTINIT_CH2OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH2OI_MASK) >> FTM_OUTINIT_CH2OI_SHIFT)
#define FTM_BRD_OUTINIT_CH2OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH2OI_SHIFT, FTM_OUTINIT_CH2OI_WIDTH))

/*! @brief Set the CH2OI field to a new value. */
#define FTM_WR_OUTINIT_CH2OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH2OI_MASK, FTM_OUTINIT_CH2OI(value)))
#define FTM_BWR_OUTINIT_CH2OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH2OI_SHIFT), FTM_OUTINIT_CH2OI_SHIFT, FTM_OUTINIT_CH2OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH3OI[3] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH3OI field. */
#define FTM_RD_OUTINIT_CH3OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH3OI_MASK) >> FTM_OUTINIT_CH3OI_SHIFT)
#define FTM_BRD_OUTINIT_CH3OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH3OI_SHIFT, FTM_OUTINIT_CH3OI_WIDTH))

/*! @brief Set the CH3OI field to a new value. */
#define FTM_WR_OUTINIT_CH3OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH3OI_MASK, FTM_OUTINIT_CH3OI(value)))
#define FTM_BWR_OUTINIT_CH3OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH3OI_SHIFT), FTM_OUTINIT_CH3OI_SHIFT, FTM_OUTINIT_CH3OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH4OI[4] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH4OI field. */
#define FTM_RD_OUTINIT_CH4OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH4OI_MASK) >> FTM_OUTINIT_CH4OI_SHIFT)
#define FTM_BRD_OUTINIT_CH4OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH4OI_SHIFT, FTM_OUTINIT_CH4OI_WIDTH))

/*! @brief Set the CH4OI field to a new value. */
#define FTM_WR_OUTINIT_CH4OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH4OI_MASK, FTM_OUTINIT_CH4OI(value)))
#define FTM_BWR_OUTINIT_CH4OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH4OI_SHIFT), FTM_OUTINIT_CH4OI_SHIFT, FTM_OUTINIT_CH4OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH5OI[5] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH5OI field. */
#define FTM_RD_OUTINIT_CH5OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH5OI_MASK) >> FTM_OUTINIT_CH5OI_SHIFT)
#define FTM_BRD_OUTINIT_CH5OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH5OI_SHIFT, FTM_OUTINIT_CH5OI_WIDTH))

/*! @brief Set the CH5OI field to a new value. */
#define FTM_WR_OUTINIT_CH5OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH5OI_MASK, FTM_OUTINIT_CH5OI(value)))
#define FTM_BWR_OUTINIT_CH5OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH5OI_SHIFT), FTM_OUTINIT_CH5OI_SHIFT, FTM_OUTINIT_CH5OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH6OI[6] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH6OI field. */
#define FTM_RD_OUTINIT_CH6OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH6OI_MASK) >> FTM_OUTINIT_CH6OI_SHIFT)
#define FTM_BRD_OUTINIT_CH6OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH6OI_SHIFT, FTM_OUTINIT_CH6OI_WIDTH))

/*! @brief Set the CH6OI field to a new value. */
#define FTM_WR_OUTINIT_CH6OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH6OI_MASK, FTM_OUTINIT_CH6OI(value)))
#define FTM_BWR_OUTINIT_CH6OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH6OI_SHIFT), FTM_OUTINIT_CH6OI_SHIFT, FTM_OUTINIT_CH6OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH7OI[7] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH7OI field. */
#define FTM_RD_OUTINIT_CH7OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH7OI_MASK) >> FTM_OUTINIT_CH7OI_SHIFT)
#define FTM_BRD_OUTINIT_CH7OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH7OI_SHIFT, FTM_OUTINIT_CH7OI_WIDTH))

/*! @brief Set the CH7OI field to a new value. */
#define FTM_WR_OUTINIT_CH7OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH7OI_MASK, FTM_OUTINIT_CH7OI(value)))
#define FTM_BWR_OUTINIT_CH7OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH7OI_SHIFT), FTM_OUTINIT_CH7OI_SHIFT, FTM_OUTINIT_CH7OI_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_OUTMASK - Output Mask
 ******************************************************************************/

/*!
 * @brief FTM_OUTMASK - Output Mask (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register provides a mask for each FTM channel. The mask of a channel
 * determines if its output responds, that is, it is masked or not, when a match
 * occurs. This feature is used for BLDC control where the PWM signal is presented
 * to an electric motor at specific times to provide electronic commutation. Any
 * write to the OUTMASK register, stores the value in its write buffer. The
 * register is updated with the value of its write buffer according to PWM
 * synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_OUTMASK register
 */
/*@{*/
#define FTM_RD_OUTMASK(base)     (FTM_OUTMASK_REG(base))
#define FTM_WR_OUTMASK(base, value) (FTM_OUTMASK_REG(base) = (value))
#define FTM_RMW_OUTMASK(base, mask, value) (FTM_WR_OUTMASK(base, (FTM_RD_OUTMASK(base) & ~(mask)) | (value)))
#define FTM_SET_OUTMASK(base, value) (BME_OR32(&FTM_OUTMASK_REG(base), (uint32_t)(value)))
#define FTM_CLR_OUTMASK(base, value) (BME_AND32(&FTM_OUTMASK_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_OUTMASK(base, value) (BME_XOR32(&FTM_OUTMASK_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_OUTMASK bitfields
 */

/*!
 * @name Register FTM_OUTMASK, field CH0OM[0] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH0OM field. */
#define FTM_RD_OUTMASK_CH0OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH0OM_MASK) >> FTM_OUTMASK_CH0OM_SHIFT)
#define FTM_BRD_OUTMASK_CH0OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH0OM_SHIFT, FTM_OUTMASK_CH0OM_WIDTH))

/*! @brief Set the CH0OM field to a new value. */
#define FTM_WR_OUTMASK_CH0OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH0OM_MASK, FTM_OUTMASK_CH0OM(value)))
#define FTM_BWR_OUTMASK_CH0OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH0OM_SHIFT), FTM_OUTMASK_CH0OM_SHIFT, FTM_OUTMASK_CH0OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH1OM[1] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH1OM field. */
#define FTM_RD_OUTMASK_CH1OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH1OM_MASK) >> FTM_OUTMASK_CH1OM_SHIFT)
#define FTM_BRD_OUTMASK_CH1OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH1OM_SHIFT, FTM_OUTMASK_CH1OM_WIDTH))

/*! @brief Set the CH1OM field to a new value. */
#define FTM_WR_OUTMASK_CH1OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH1OM_MASK, FTM_OUTMASK_CH1OM(value)))
#define FTM_BWR_OUTMASK_CH1OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH1OM_SHIFT), FTM_OUTMASK_CH1OM_SHIFT, FTM_OUTMASK_CH1OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH2OM[2] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH2OM field. */
#define FTM_RD_OUTMASK_CH2OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH2OM_MASK) >> FTM_OUTMASK_CH2OM_SHIFT)
#define FTM_BRD_OUTMASK_CH2OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH2OM_SHIFT, FTM_OUTMASK_CH2OM_WIDTH))

/*! @brief Set the CH2OM field to a new value. */
#define FTM_WR_OUTMASK_CH2OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH2OM_MASK, FTM_OUTMASK_CH2OM(value)))
#define FTM_BWR_OUTMASK_CH2OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH2OM_SHIFT), FTM_OUTMASK_CH2OM_SHIFT, FTM_OUTMASK_CH2OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH3OM[3] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH3OM field. */
#define FTM_RD_OUTMASK_CH3OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH3OM_MASK) >> FTM_OUTMASK_CH3OM_SHIFT)
#define FTM_BRD_OUTMASK_CH3OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH3OM_SHIFT, FTM_OUTMASK_CH3OM_WIDTH))

/*! @brief Set the CH3OM field to a new value. */
#define FTM_WR_OUTMASK_CH3OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH3OM_MASK, FTM_OUTMASK_CH3OM(value)))
#define FTM_BWR_OUTMASK_CH3OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH3OM_SHIFT), FTM_OUTMASK_CH3OM_SHIFT, FTM_OUTMASK_CH3OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH4OM[4] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH4OM field. */
#define FTM_RD_OUTMASK_CH4OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH4OM_MASK) >> FTM_OUTMASK_CH4OM_SHIFT)
#define FTM_BRD_OUTMASK_CH4OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH4OM_SHIFT, FTM_OUTMASK_CH4OM_WIDTH))

/*! @brief Set the CH4OM field to a new value. */
#define FTM_WR_OUTMASK_CH4OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH4OM_MASK, FTM_OUTMASK_CH4OM(value)))
#define FTM_BWR_OUTMASK_CH4OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH4OM_SHIFT), FTM_OUTMASK_CH4OM_SHIFT, FTM_OUTMASK_CH4OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH5OM[5] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH5OM field. */
#define FTM_RD_OUTMASK_CH5OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH5OM_MASK) >> FTM_OUTMASK_CH5OM_SHIFT)
#define FTM_BRD_OUTMASK_CH5OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH5OM_SHIFT, FTM_OUTMASK_CH5OM_WIDTH))

/*! @brief Set the CH5OM field to a new value. */
#define FTM_WR_OUTMASK_CH5OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH5OM_MASK, FTM_OUTMASK_CH5OM(value)))
#define FTM_BWR_OUTMASK_CH5OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH5OM_SHIFT), FTM_OUTMASK_CH5OM_SHIFT, FTM_OUTMASK_CH5OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH6OM[6] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH6OM field. */
#define FTM_RD_OUTMASK_CH6OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH6OM_MASK) >> FTM_OUTMASK_CH6OM_SHIFT)
#define FTM_BRD_OUTMASK_CH6OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH6OM_SHIFT, FTM_OUTMASK_CH6OM_WIDTH))

/*! @brief Set the CH6OM field to a new value. */
#define FTM_WR_OUTMASK_CH6OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH6OM_MASK, FTM_OUTMASK_CH6OM(value)))
#define FTM_BWR_OUTMASK_CH6OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH6OM_SHIFT), FTM_OUTMASK_CH6OM_SHIFT, FTM_OUTMASK_CH6OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH7OM[7] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH7OM field. */
#define FTM_RD_OUTMASK_CH7OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH7OM_MASK) >> FTM_OUTMASK_CH7OM_SHIFT)
#define FTM_BRD_OUTMASK_CH7OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH7OM_SHIFT, FTM_OUTMASK_CH7OM_WIDTH))

/*! @brief Set the CH7OM field to a new value. */
#define FTM_WR_OUTMASK_CH7OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH7OM_MASK, FTM_OUTMASK_CH7OM(value)))
#define FTM_BWR_OUTMASK_CH7OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH7OM_SHIFT), FTM_OUTMASK_CH7OM_SHIFT, FTM_OUTMASK_CH7OM_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_COMBINE - Function For Linked Channels
 ******************************************************************************/

/*!
 * @brief FTM_COMBINE - Function For Linked Channels (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the control bits used to configure the fault control,
 * synchronization, deadtime insertion, Dual Edge Capture mode, Complementary,
 * and Combine mode for each pair of channels (n) and (n+1), where n equals 0, 2,
 * 4, and 6.
 */
/*!
 * @name Constants and macros for entire FTM_COMBINE register
 */
/*@{*/
#define FTM_RD_COMBINE(base)     (FTM_COMBINE_REG(base))
#define FTM_WR_COMBINE(base, value) (FTM_COMBINE_REG(base) = (value))
#define FTM_RMW_COMBINE(base, mask, value) (FTM_WR_COMBINE(base, (FTM_RD_COMBINE(base) & ~(mask)) | (value)))
#define FTM_SET_COMBINE(base, value) (BME_OR32(&FTM_COMBINE_REG(base), (uint32_t)(value)))
#define FTM_CLR_COMBINE(base, value) (BME_AND32(&FTM_COMBINE_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_COMBINE(base, value) (BME_XOR32(&FTM_COMBINE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_COMBINE bitfields
 */

/*!
 * @name Register FTM_COMBINE, field COMBINE0[0] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Channels (n) and (n+1) are independent.
 * - 1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE0 field. */
#define FTM_RD_COMBINE_COMBINE0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE0_MASK) >> FTM_COMBINE_COMBINE0_SHIFT)
#define FTM_BRD_COMBINE_COMBINE0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE0_SHIFT, FTM_COMBINE_COMBINE0_WIDTH))

/*! @brief Set the COMBINE0 field to a new value. */
#define FTM_WR_COMBINE_COMBINE0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE0_MASK, FTM_COMBINE_COMBINE0(value)))
#define FTM_BWR_COMBINE_COMBINE0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMBINE0_SHIFT), FTM_COMBINE_COMBINE0_SHIFT, FTM_COMBINE_COMBINE0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP0[1] (RW)
 *
 * Enables Complementary mode for the combined channels. In Complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel (n+1) output is the same as the channel (n) output.
 * - 1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP0 field. */
#define FTM_RD_COMBINE_COMP0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP0_MASK) >> FTM_COMBINE_COMP0_SHIFT)
#define FTM_BRD_COMBINE_COMP0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP0_SHIFT, FTM_COMBINE_COMP0_WIDTH))

/*! @brief Set the COMP0 field to a new value. */
#define FTM_WR_COMBINE_COMP0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP0_MASK, FTM_COMBINE_COMP0(value)))
#define FTM_BWR_COMBINE_COMP0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMP0_SHIFT), FTM_COMBINE_COMP0_SHIFT, FTM_COMBINE_COMP0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN0[2] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to #ModeSel1Table. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN0 field. */
#define FTM_RD_COMBINE_DECAPEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN0_MASK) >> FTM_COMBINE_DECAPEN0_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN0_SHIFT, FTM_COMBINE_DECAPEN0_WIDTH))

/*! @brief Set the DECAPEN0 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN0_MASK, FTM_COMBINE_DECAPEN0(value)))
#define FTM_BWR_COMBINE_DECAPEN0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAPEN0_SHIFT), FTM_COMBINE_DECAPEN0_SHIFT, FTM_COMBINE_DECAPEN0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP0[3] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if
 * dual edge capture - one-shot mode is selected and when the capture of channel
 * (n+1) event is made.
 *
 * Values:
 * - 0 - The dual edge captures are inactive.
 * - 1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP0 field. */
#define FTM_RD_COMBINE_DECAP0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP0_MASK) >> FTM_COMBINE_DECAP0_SHIFT)
#define FTM_BRD_COMBINE_DECAP0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP0_SHIFT, FTM_COMBINE_DECAP0_WIDTH))

/*! @brief Set the DECAP0 field to a new value. */
#define FTM_WR_COMBINE_DECAP0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP0_MASK, FTM_COMBINE_DECAP0(value)))
#define FTM_BWR_COMBINE_DECAP0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAP0_SHIFT), FTM_COMBINE_DECAP0_SHIFT, FTM_COMBINE_DECAP0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN0[4] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The deadtime insertion in this pair of channels is disabled.
 * - 1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN0 field. */
#define FTM_RD_COMBINE_DTEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN0_MASK) >> FTM_COMBINE_DTEN0_SHIFT)
#define FTM_BRD_COMBINE_DTEN0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN0_SHIFT, FTM_COMBINE_DTEN0_WIDTH))

/*! @brief Set the DTEN0 field to a new value. */
#define FTM_WR_COMBINE_DTEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN0_MASK, FTM_COMBINE_DTEN0(value)))
#define FTM_BWR_COMBINE_DTEN0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DTEN0_SHIFT), FTM_COMBINE_DTEN0_SHIFT, FTM_COMBINE_DTEN0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN0[5] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0 - The PWM synchronization in this pair of channels is disabled.
 * - 1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN0 field. */
#define FTM_RD_COMBINE_SYNCEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN0_MASK) >> FTM_COMBINE_SYNCEN0_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN0_SHIFT, FTM_COMBINE_SYNCEN0_WIDTH))

/*! @brief Set the SYNCEN0 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN0_MASK, FTM_COMBINE_SYNCEN0(value)))
#define FTM_BWR_COMBINE_SYNCEN0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_SYNCEN0_SHIFT), FTM_COMBINE_SYNCEN0_SHIFT, FTM_COMBINE_SYNCEN0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN0[6] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault control in this pair of channels is disabled.
 * - 1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN0 field. */
#define FTM_RD_COMBINE_FAULTEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN0_MASK) >> FTM_COMBINE_FAULTEN0_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN0_SHIFT, FTM_COMBINE_FAULTEN0_WIDTH))

/*! @brief Set the FAULTEN0 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN0_MASK, FTM_COMBINE_FAULTEN0(value)))
#define FTM_BWR_COMBINE_FAULTEN0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_FAULTEN0_SHIFT), FTM_COMBINE_FAULTEN0_SHIFT, FTM_COMBINE_FAULTEN0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE1[8] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Channels (n) and (n+1) are independent.
 * - 1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE1 field. */
#define FTM_RD_COMBINE_COMBINE1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE1_MASK) >> FTM_COMBINE_COMBINE1_SHIFT)
#define FTM_BRD_COMBINE_COMBINE1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE1_SHIFT, FTM_COMBINE_COMBINE1_WIDTH))

/*! @brief Set the COMBINE1 field to a new value. */
#define FTM_WR_COMBINE_COMBINE1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE1_MASK, FTM_COMBINE_COMBINE1(value)))
#define FTM_BWR_COMBINE_COMBINE1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMBINE1_SHIFT), FTM_COMBINE_COMBINE1_SHIFT, FTM_COMBINE_COMBINE1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP1[9] (RW)
 *
 * Enables Complementary mode for the combined channels. In Complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel (n+1) output is the same as the channel (n) output.
 * - 1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP1 field. */
#define FTM_RD_COMBINE_COMP1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP1_MASK) >> FTM_COMBINE_COMP1_SHIFT)
#define FTM_BRD_COMBINE_COMP1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP1_SHIFT, FTM_COMBINE_COMP1_WIDTH))

/*! @brief Set the COMP1 field to a new value. */
#define FTM_WR_COMBINE_COMP1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP1_MASK, FTM_COMBINE_COMP1(value)))
#define FTM_BWR_COMBINE_COMP1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMP1_SHIFT), FTM_COMBINE_COMP1_SHIFT, FTM_COMBINE_COMP1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN1[10] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to #ModeSel1Table. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN1 field. */
#define FTM_RD_COMBINE_DECAPEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN1_MASK) >> FTM_COMBINE_DECAPEN1_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN1_SHIFT, FTM_COMBINE_DECAPEN1_WIDTH))

/*! @brief Set the DECAPEN1 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN1_MASK, FTM_COMBINE_DECAPEN1(value)))
#define FTM_BWR_COMBINE_DECAPEN1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAPEN1_SHIFT), FTM_COMBINE_DECAPEN1_SHIFT, FTM_COMBINE_DECAPEN1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP1[11] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if
 * Dual Edge Capture - One-Shot mode is selected and when the capture of channel
 * (n+1) event is made.
 *
 * Values:
 * - 0 - The dual edge captures are inactive.
 * - 1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP1 field. */
#define FTM_RD_COMBINE_DECAP1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP1_MASK) >> FTM_COMBINE_DECAP1_SHIFT)
#define FTM_BRD_COMBINE_DECAP1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP1_SHIFT, FTM_COMBINE_DECAP1_WIDTH))

/*! @brief Set the DECAP1 field to a new value. */
#define FTM_WR_COMBINE_DECAP1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP1_MASK, FTM_COMBINE_DECAP1(value)))
#define FTM_BWR_COMBINE_DECAP1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAP1_SHIFT), FTM_COMBINE_DECAP1_SHIFT, FTM_COMBINE_DECAP1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN1[12] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The deadtime insertion in this pair of channels is disabled.
 * - 1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN1 field. */
#define FTM_RD_COMBINE_DTEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN1_MASK) >> FTM_COMBINE_DTEN1_SHIFT)
#define FTM_BRD_COMBINE_DTEN1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN1_SHIFT, FTM_COMBINE_DTEN1_WIDTH))

/*! @brief Set the DTEN1 field to a new value. */
#define FTM_WR_COMBINE_DTEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN1_MASK, FTM_COMBINE_DTEN1(value)))
#define FTM_BWR_COMBINE_DTEN1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DTEN1_SHIFT), FTM_COMBINE_DTEN1_SHIFT, FTM_COMBINE_DTEN1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN1[13] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0 - The PWM synchronization in this pair of channels is disabled.
 * - 1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN1 field. */
#define FTM_RD_COMBINE_SYNCEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN1_MASK) >> FTM_COMBINE_SYNCEN1_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN1_SHIFT, FTM_COMBINE_SYNCEN1_WIDTH))

/*! @brief Set the SYNCEN1 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN1_MASK, FTM_COMBINE_SYNCEN1(value)))
#define FTM_BWR_COMBINE_SYNCEN1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_SYNCEN1_SHIFT), FTM_COMBINE_SYNCEN1_SHIFT, FTM_COMBINE_SYNCEN1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN1[14] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault control in this pair of channels is disabled.
 * - 1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN1 field. */
#define FTM_RD_COMBINE_FAULTEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN1_MASK) >> FTM_COMBINE_FAULTEN1_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN1_SHIFT, FTM_COMBINE_FAULTEN1_WIDTH))

/*! @brief Set the FAULTEN1 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN1_MASK, FTM_COMBINE_FAULTEN1(value)))
#define FTM_BWR_COMBINE_FAULTEN1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_FAULTEN1_SHIFT), FTM_COMBINE_FAULTEN1_SHIFT, FTM_COMBINE_FAULTEN1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE2[16] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Channels (n) and (n+1) are independent.
 * - 1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE2 field. */
#define FTM_RD_COMBINE_COMBINE2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE2_MASK) >> FTM_COMBINE_COMBINE2_SHIFT)
#define FTM_BRD_COMBINE_COMBINE2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE2_SHIFT, FTM_COMBINE_COMBINE2_WIDTH))

/*! @brief Set the COMBINE2 field to a new value. */
#define FTM_WR_COMBINE_COMBINE2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE2_MASK, FTM_COMBINE_COMBINE2(value)))
#define FTM_BWR_COMBINE_COMBINE2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMBINE2_SHIFT), FTM_COMBINE_COMBINE2_SHIFT, FTM_COMBINE_COMBINE2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP2[17] (RW)
 *
 * Enables Complementary mode for the combined channels. In Complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel (n+1) output is the same as the channel (n) output.
 * - 1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP2 field. */
#define FTM_RD_COMBINE_COMP2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP2_MASK) >> FTM_COMBINE_COMP2_SHIFT)
#define FTM_BRD_COMBINE_COMP2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP2_SHIFT, FTM_COMBINE_COMP2_WIDTH))

/*! @brief Set the COMP2 field to a new value. */
#define FTM_WR_COMBINE_COMP2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP2_MASK, FTM_COMBINE_COMP2(value)))
#define FTM_BWR_COMBINE_COMP2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMP2_SHIFT), FTM_COMBINE_COMP2_SHIFT, FTM_COMBINE_COMP2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN2[18] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to #ModeSel1Table. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN2 field. */
#define FTM_RD_COMBINE_DECAPEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN2_MASK) >> FTM_COMBINE_DECAPEN2_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN2_SHIFT, FTM_COMBINE_DECAPEN2_WIDTH))

/*! @brief Set the DECAPEN2 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN2_MASK, FTM_COMBINE_DECAPEN2(value)))
#define FTM_BWR_COMBINE_DECAPEN2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAPEN2_SHIFT), FTM_COMBINE_DECAPEN2_SHIFT, FTM_COMBINE_DECAPEN2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP2[19] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if
 * dual edge capture - one-shot mode is selected and when the capture of channel
 * (n+1) event is made.
 *
 * Values:
 * - 0 - The dual edge captures are inactive.
 * - 1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP2 field. */
#define FTM_RD_COMBINE_DECAP2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP2_MASK) >> FTM_COMBINE_DECAP2_SHIFT)
#define FTM_BRD_COMBINE_DECAP2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP2_SHIFT, FTM_COMBINE_DECAP2_WIDTH))

/*! @brief Set the DECAP2 field to a new value. */
#define FTM_WR_COMBINE_DECAP2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP2_MASK, FTM_COMBINE_DECAP2(value)))
#define FTM_BWR_COMBINE_DECAP2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAP2_SHIFT), FTM_COMBINE_DECAP2_SHIFT, FTM_COMBINE_DECAP2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN2[20] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The deadtime insertion in this pair of channels is disabled.
 * - 1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN2 field. */
#define FTM_RD_COMBINE_DTEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN2_MASK) >> FTM_COMBINE_DTEN2_SHIFT)
#define FTM_BRD_COMBINE_DTEN2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN2_SHIFT, FTM_COMBINE_DTEN2_WIDTH))

/*! @brief Set the DTEN2 field to a new value. */
#define FTM_WR_COMBINE_DTEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN2_MASK, FTM_COMBINE_DTEN2(value)))
#define FTM_BWR_COMBINE_DTEN2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DTEN2_SHIFT), FTM_COMBINE_DTEN2_SHIFT, FTM_COMBINE_DTEN2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN2[21] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0 - The PWM synchronization in this pair of channels is disabled.
 * - 1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN2 field. */
#define FTM_RD_COMBINE_SYNCEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN2_MASK) >> FTM_COMBINE_SYNCEN2_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN2_SHIFT, FTM_COMBINE_SYNCEN2_WIDTH))

/*! @brief Set the SYNCEN2 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN2_MASK, FTM_COMBINE_SYNCEN2(value)))
#define FTM_BWR_COMBINE_SYNCEN2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_SYNCEN2_SHIFT), FTM_COMBINE_SYNCEN2_SHIFT, FTM_COMBINE_SYNCEN2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN2[22] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault control in this pair of channels is disabled.
 * - 1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN2 field. */
#define FTM_RD_COMBINE_FAULTEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN2_MASK) >> FTM_COMBINE_FAULTEN2_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN2_SHIFT, FTM_COMBINE_FAULTEN2_WIDTH))

/*! @brief Set the FAULTEN2 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN2_MASK, FTM_COMBINE_FAULTEN2(value)))
#define FTM_BWR_COMBINE_FAULTEN2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_FAULTEN2_SHIFT), FTM_COMBINE_FAULTEN2_SHIFT, FTM_COMBINE_FAULTEN2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE3[24] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Channels (n) and (n+1) are independent.
 * - 1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE3 field. */
#define FTM_RD_COMBINE_COMBINE3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE3_MASK) >> FTM_COMBINE_COMBINE3_SHIFT)
#define FTM_BRD_COMBINE_COMBINE3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE3_SHIFT, FTM_COMBINE_COMBINE3_WIDTH))

/*! @brief Set the COMBINE3 field to a new value. */
#define FTM_WR_COMBINE_COMBINE3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE3_MASK, FTM_COMBINE_COMBINE3(value)))
#define FTM_BWR_COMBINE_COMBINE3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMBINE3_SHIFT), FTM_COMBINE_COMBINE3_SHIFT, FTM_COMBINE_COMBINE3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP3[25] (RW)
 *
 * Enables Complementary mode for the combined channels. In Complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel (n+1) output is the same as the channel (n) output.
 * - 1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP3 field. */
#define FTM_RD_COMBINE_COMP3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP3_MASK) >> FTM_COMBINE_COMP3_SHIFT)
#define FTM_BRD_COMBINE_COMP3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP3_SHIFT, FTM_COMBINE_COMP3_WIDTH))

/*! @brief Set the COMP3 field to a new value. */
#define FTM_WR_COMBINE_COMP3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP3_MASK, FTM_COMBINE_COMP3(value)))
#define FTM_BWR_COMBINE_COMP3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMP3_SHIFT), FTM_COMBINE_COMP3_SHIFT, FTM_COMBINE_COMP3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN3[26] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to #ModeSel1Table. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN3 field. */
#define FTM_RD_COMBINE_DECAPEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN3_MASK) >> FTM_COMBINE_DECAPEN3_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN3_SHIFT, FTM_COMBINE_DECAPEN3_WIDTH))

/*! @brief Set the DECAPEN3 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN3_MASK, FTM_COMBINE_DECAPEN3(value)))
#define FTM_BWR_COMBINE_DECAPEN3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAPEN3_SHIFT), FTM_COMBINE_DECAPEN3_SHIFT, FTM_COMBINE_DECAPEN3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP3[27] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if
 * dual edge capture - one-shot mode is selected and when the capture of channel
 * (n+1) event is made.
 *
 * Values:
 * - 0 - The dual edge captures are inactive.
 * - 1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP3 field. */
#define FTM_RD_COMBINE_DECAP3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP3_MASK) >> FTM_COMBINE_DECAP3_SHIFT)
#define FTM_BRD_COMBINE_DECAP3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP3_SHIFT, FTM_COMBINE_DECAP3_WIDTH))

/*! @brief Set the DECAP3 field to a new value. */
#define FTM_WR_COMBINE_DECAP3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP3_MASK, FTM_COMBINE_DECAP3(value)))
#define FTM_BWR_COMBINE_DECAP3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAP3_SHIFT), FTM_COMBINE_DECAP3_SHIFT, FTM_COMBINE_DECAP3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN3[28] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The deadtime insertion in this pair of channels is disabled.
 * - 1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN3 field. */
#define FTM_RD_COMBINE_DTEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN3_MASK) >> FTM_COMBINE_DTEN3_SHIFT)
#define FTM_BRD_COMBINE_DTEN3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN3_SHIFT, FTM_COMBINE_DTEN3_WIDTH))

/*! @brief Set the DTEN3 field to a new value. */
#define FTM_WR_COMBINE_DTEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN3_MASK, FTM_COMBINE_DTEN3(value)))
#define FTM_BWR_COMBINE_DTEN3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DTEN3_SHIFT), FTM_COMBINE_DTEN3_SHIFT, FTM_COMBINE_DTEN3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN3[29] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0 - The PWM synchronization in this pair of channels is disabled.
 * - 1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN3 field. */
#define FTM_RD_COMBINE_SYNCEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN3_MASK) >> FTM_COMBINE_SYNCEN3_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN3_SHIFT, FTM_COMBINE_SYNCEN3_WIDTH))

/*! @brief Set the SYNCEN3 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN3_MASK, FTM_COMBINE_SYNCEN3(value)))
#define FTM_BWR_COMBINE_SYNCEN3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_SYNCEN3_SHIFT), FTM_COMBINE_SYNCEN3_SHIFT, FTM_COMBINE_SYNCEN3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN3[30] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault control in this pair of channels is disabled.
 * - 1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN3 field. */
#define FTM_RD_COMBINE_FAULTEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN3_MASK) >> FTM_COMBINE_FAULTEN3_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN3_SHIFT, FTM_COMBINE_FAULTEN3_WIDTH))

/*! @brief Set the FAULTEN3 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN3_MASK, FTM_COMBINE_FAULTEN3(value)))
#define FTM_BWR_COMBINE_FAULTEN3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_FAULTEN3_SHIFT), FTM_COMBINE_FAULTEN3_SHIFT, FTM_COMBINE_FAULTEN3_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_DEADTIME - Deadtime Insertion Control
 ******************************************************************************/

/*!
 * @brief FTM_DEADTIME - Deadtime Insertion Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the deadtime prescaler factor and deadtime value. All
 * FTM channels use this clock prescaler and this deadtime value for the deadtime
 * insertion.
 */
/*!
 * @name Constants and macros for entire FTM_DEADTIME register
 */
/*@{*/
#define FTM_RD_DEADTIME(base)    (FTM_DEADTIME_REG(base))
#define FTM_WR_DEADTIME(base, value) (FTM_DEADTIME_REG(base) = (value))
#define FTM_RMW_DEADTIME(base, mask, value) (FTM_WR_DEADTIME(base, (FTM_RD_DEADTIME(base) & ~(mask)) | (value)))
#define FTM_SET_DEADTIME(base, value) (BME_OR32(&FTM_DEADTIME_REG(base), (uint32_t)(value)))
#define FTM_CLR_DEADTIME(base, value) (BME_AND32(&FTM_DEADTIME_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_DEADTIME(base, value) (BME_XOR32(&FTM_DEADTIME_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_DEADTIME bitfields
 */

/*!
 * @name Register FTM_DEADTIME, field DTVAL[5:0] (RW)
 *
 * Selects the deadtime insertion value for the deadtime counter. The deadtime
 * counter is clocked by a scaled version of the system clock. See the description
 * of DTPS. Deadtime insert value = (DTPS * DTVAL). DTVAL selects the number of
 * deadtime counts inserted as follows: When DTVAL is 0, no counts are inserted.
 * When DTVAL is 1, 1 count is inserted. When DTVAL is 2, 2 counts are inserted.
 * This pattern continues up to a possible 63 counts. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_DEADTIME_DTVAL field. */
#define FTM_RD_DEADTIME_DTVAL(base) ((FTM_DEADTIME_REG(base) & FTM_DEADTIME_DTVAL_MASK) >> FTM_DEADTIME_DTVAL_SHIFT)
#define FTM_BRD_DEADTIME_DTVAL(base) (BME_UBFX32(&FTM_DEADTIME_REG(base), FTM_DEADTIME_DTVAL_SHIFT, FTM_DEADTIME_DTVAL_WIDTH))

/*! @brief Set the DTVAL field to a new value. */
#define FTM_WR_DEADTIME_DTVAL(base, value) (FTM_RMW_DEADTIME(base, FTM_DEADTIME_DTVAL_MASK, FTM_DEADTIME_DTVAL(value)))
#define FTM_BWR_DEADTIME_DTVAL(base, value) (BME_BFI32(&FTM_DEADTIME_REG(base), ((uint32_t)(value) << FTM_DEADTIME_DTVAL_SHIFT), FTM_DEADTIME_DTVAL_SHIFT, FTM_DEADTIME_DTVAL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_DEADTIME, field DTPS[7:6] (RW)
 *
 * Selects the division factor of the system clock. This prescaled clock is used
 * by the deadtime counter. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0x - Divide the system clock by 1.
 * - 10 - Divide the system clock by 4.
 * - 11 - Divide the system clock by 16.
 */
/*@{*/
/*! @brief Read current value of the FTM_DEADTIME_DTPS field. */
#define FTM_RD_DEADTIME_DTPS(base) ((FTM_DEADTIME_REG(base) & FTM_DEADTIME_DTPS_MASK) >> FTM_DEADTIME_DTPS_SHIFT)
#define FTM_BRD_DEADTIME_DTPS(base) (BME_UBFX32(&FTM_DEADTIME_REG(base), FTM_DEADTIME_DTPS_SHIFT, FTM_DEADTIME_DTPS_WIDTH))

/*! @brief Set the DTPS field to a new value. */
#define FTM_WR_DEADTIME_DTPS(base, value) (FTM_RMW_DEADTIME(base, FTM_DEADTIME_DTPS_MASK, FTM_DEADTIME_DTPS(value)))
#define FTM_BWR_DEADTIME_DTPS(base, value) (BME_BFI32(&FTM_DEADTIME_REG(base), ((uint32_t)(value) << FTM_DEADTIME_DTPS_SHIFT), FTM_DEADTIME_DTPS_SHIFT, FTM_DEADTIME_DTPS_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_EXTTRIG - FTM External Trigger
 ******************************************************************************/

/*!
 * @brief FTM_EXTTRIG - FTM External Trigger (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register: Indicates when a channel trigger was generated Enables the
 * generation of a trigger when the FTM counter is equal to its initial value
 * Selects which channels are used in the generation of the channel triggers Several
 * channels can be selected to generate multiple triggers in one PWM period.
 * Channels 6 and 7 are not used to generate channel triggers.
 */
/*!
 * @name Constants and macros for entire FTM_EXTTRIG register
 */
/*@{*/
#define FTM_RD_EXTTRIG(base)     (FTM_EXTTRIG_REG(base))
#define FTM_WR_EXTTRIG(base, value) (FTM_EXTTRIG_REG(base) = (value))
#define FTM_RMW_EXTTRIG(base, mask, value) (FTM_WR_EXTTRIG(base, (FTM_RD_EXTTRIG(base) & ~(mask)) | (value)))
#define FTM_SET_EXTTRIG(base, value) (BME_OR32(&FTM_EXTTRIG_REG(base), (uint32_t)(value)))
#define FTM_CLR_EXTTRIG(base, value) (BME_AND32(&FTM_EXTTRIG_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_EXTTRIG(base, value) (BME_XOR32(&FTM_EXTTRIG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_EXTTRIG bitfields
 */

/*!
 * @name Register FTM_EXTTRIG, field CH2TRIG[0] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH2TRIG field. */
#define FTM_RD_EXTTRIG_CH2TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH2TRIG_MASK) >> FTM_EXTTRIG_CH2TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH2TRIG(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH2TRIG_SHIFT, FTM_EXTTRIG_CH2TRIG_WIDTH))

/*! @brief Set the CH2TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH2TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH2TRIG_MASK, FTM_EXTTRIG_CH2TRIG(value)))
#define FTM_BWR_EXTTRIG_CH2TRIG(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_CH2TRIG_SHIFT), FTM_EXTTRIG_CH2TRIG_SHIFT, FTM_EXTTRIG_CH2TRIG_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH3TRIG[1] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH3TRIG field. */
#define FTM_RD_EXTTRIG_CH3TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH3TRIG_MASK) >> FTM_EXTTRIG_CH3TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH3TRIG(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH3TRIG_SHIFT, FTM_EXTTRIG_CH3TRIG_WIDTH))

/*! @brief Set the CH3TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH3TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH3TRIG_MASK, FTM_EXTTRIG_CH3TRIG(value)))
#define FTM_BWR_EXTTRIG_CH3TRIG(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_CH3TRIG_SHIFT), FTM_EXTTRIG_CH3TRIG_SHIFT, FTM_EXTTRIG_CH3TRIG_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH4TRIG[2] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH4TRIG field. */
#define FTM_RD_EXTTRIG_CH4TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH4TRIG_MASK) >> FTM_EXTTRIG_CH4TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH4TRIG(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH4TRIG_SHIFT, FTM_EXTTRIG_CH4TRIG_WIDTH))

/*! @brief Set the CH4TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH4TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH4TRIG_MASK, FTM_EXTTRIG_CH4TRIG(value)))
#define FTM_BWR_EXTTRIG_CH4TRIG(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_CH4TRIG_SHIFT), FTM_EXTTRIG_CH4TRIG_SHIFT, FTM_EXTTRIG_CH4TRIG_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH5TRIG[3] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH5TRIG field. */
#define FTM_RD_EXTTRIG_CH5TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH5TRIG_MASK) >> FTM_EXTTRIG_CH5TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH5TRIG(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH5TRIG_SHIFT, FTM_EXTTRIG_CH5TRIG_WIDTH))

/*! @brief Set the CH5TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH5TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH5TRIG_MASK, FTM_EXTTRIG_CH5TRIG(value)))
#define FTM_BWR_EXTTRIG_CH5TRIG(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_CH5TRIG_SHIFT), FTM_EXTTRIG_CH5TRIG_SHIFT, FTM_EXTTRIG_CH5TRIG_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH0TRIG[4] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH0TRIG field. */
#define FTM_RD_EXTTRIG_CH0TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH0TRIG_MASK) >> FTM_EXTTRIG_CH0TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH0TRIG(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH0TRIG_SHIFT, FTM_EXTTRIG_CH0TRIG_WIDTH))

/*! @brief Set the CH0TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH0TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH0TRIG_MASK, FTM_EXTTRIG_CH0TRIG(value)))
#define FTM_BWR_EXTTRIG_CH0TRIG(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_CH0TRIG_SHIFT), FTM_EXTTRIG_CH0TRIG_SHIFT, FTM_EXTTRIG_CH0TRIG_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH1TRIG[5] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH1TRIG field. */
#define FTM_RD_EXTTRIG_CH1TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH1TRIG_MASK) >> FTM_EXTTRIG_CH1TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH1TRIG(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH1TRIG_SHIFT, FTM_EXTTRIG_CH1TRIG_WIDTH))

/*! @brief Set the CH1TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH1TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH1TRIG_MASK, FTM_EXTTRIG_CH1TRIG(value)))
#define FTM_BWR_EXTTRIG_CH1TRIG(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_CH1TRIG_SHIFT), FTM_EXTTRIG_CH1TRIG_SHIFT, FTM_EXTTRIG_CH1TRIG_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field INITTRIGEN[6] (RW)
 *
 * Enables the generation of the trigger when the FTM counter is equal to the
 * CNTIN register.
 *
 * Values:
 * - 0 - The generation of initialization trigger is disabled.
 * - 1 - The generation of initialization trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_INITTRIGEN field. */
#define FTM_RD_EXTTRIG_INITTRIGEN(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_INITTRIGEN_MASK) >> FTM_EXTTRIG_INITTRIGEN_SHIFT)
#define FTM_BRD_EXTTRIG_INITTRIGEN(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_INITTRIGEN_SHIFT, FTM_EXTTRIG_INITTRIGEN_WIDTH))

/*! @brief Set the INITTRIGEN field to a new value. */
#define FTM_WR_EXTTRIG_INITTRIGEN(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_INITTRIGEN_MASK, FTM_EXTTRIG_INITTRIGEN(value)))
#define FTM_BWR_EXTTRIG_INITTRIGEN(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_INITTRIGEN_SHIFT), FTM_EXTTRIG_INITTRIGEN_SHIFT, FTM_EXTTRIG_INITTRIGEN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field TRIGF[7] (ROWZ)
 *
 * Set by hardware when a channel trigger is generated. Clear TRIGF by reading
 * EXTTRIG while TRIGF is set and then writing a 0 to TRIGF. Writing a 1 to TRIGF
 * has no effect. If another channel trigger is generated before the clearing
 * sequence is completed, the sequence is reset so TRIGF remains set after the clear
 * sequence is completed for the earlier TRIGF.
 *
 * Values:
 * - 0 - No channel trigger was generated.
 * - 1 - A channel trigger was generated.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_TRIGF field. */
#define FTM_RD_EXTTRIG_TRIGF(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_TRIGF_MASK) >> FTM_EXTTRIG_TRIGF_SHIFT)
#define FTM_BRD_EXTTRIG_TRIGF(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_TRIGF_SHIFT, FTM_EXTTRIG_TRIGF_WIDTH))

/*! @brief Set the TRIGF field to a new value. */
#define FTM_WR_EXTTRIG_TRIGF(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_TRIGF_MASK, FTM_EXTTRIG_TRIGF(value)))
#define FTM_BWR_EXTTRIG_TRIGF(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_TRIGF_SHIFT), FTM_EXTTRIG_TRIGF_SHIFT, FTM_EXTTRIG_TRIGF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_POL - Channels Polarity
 ******************************************************************************/

/*!
 * @brief FTM_POL - Channels Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the output polarity of the FTM channels. The safe value
 * that is driven in a channel output when the fault control is enabled and a
 * fault condition is detected is the inactive state of the channel. That is, the
 * safe value of a channel is the value of its POL bit.
 */
/*!
 * @name Constants and macros for entire FTM_POL register
 */
/*@{*/
#define FTM_RD_POL(base)         (FTM_POL_REG(base))
#define FTM_WR_POL(base, value)  (FTM_POL_REG(base) = (value))
#define FTM_RMW_POL(base, mask, value) (FTM_WR_POL(base, (FTM_RD_POL(base) & ~(mask)) | (value)))
#define FTM_SET_POL(base, value) (BME_OR32(&FTM_POL_REG(base), (uint32_t)(value)))
#define FTM_CLR_POL(base, value) (BME_AND32(&FTM_POL_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_POL(base, value) (BME_XOR32(&FTM_POL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_POL bitfields
 */

/*!
 * @name Register FTM_POL, field POL0[0] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL0 field. */
#define FTM_RD_POL_POL0(base) ((FTM_POL_REG(base) & FTM_POL_POL0_MASK) >> FTM_POL_POL0_SHIFT)
#define FTM_BRD_POL_POL0(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL0_SHIFT, FTM_POL_POL0_WIDTH))

/*! @brief Set the POL0 field to a new value. */
#define FTM_WR_POL_POL0(base, value) (FTM_RMW_POL(base, FTM_POL_POL0_MASK, FTM_POL_POL0(value)))
#define FTM_BWR_POL_POL0(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL0_SHIFT), FTM_POL_POL0_SHIFT, FTM_POL_POL0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL1[1] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL1 field. */
#define FTM_RD_POL_POL1(base) ((FTM_POL_REG(base) & FTM_POL_POL1_MASK) >> FTM_POL_POL1_SHIFT)
#define FTM_BRD_POL_POL1(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL1_SHIFT, FTM_POL_POL1_WIDTH))

/*! @brief Set the POL1 field to a new value. */
#define FTM_WR_POL_POL1(base, value) (FTM_RMW_POL(base, FTM_POL_POL1_MASK, FTM_POL_POL1(value)))
#define FTM_BWR_POL_POL1(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL1_SHIFT), FTM_POL_POL1_SHIFT, FTM_POL_POL1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL2[2] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL2 field. */
#define FTM_RD_POL_POL2(base) ((FTM_POL_REG(base) & FTM_POL_POL2_MASK) >> FTM_POL_POL2_SHIFT)
#define FTM_BRD_POL_POL2(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL2_SHIFT, FTM_POL_POL2_WIDTH))

/*! @brief Set the POL2 field to a new value. */
#define FTM_WR_POL_POL2(base, value) (FTM_RMW_POL(base, FTM_POL_POL2_MASK, FTM_POL_POL2(value)))
#define FTM_BWR_POL_POL2(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL2_SHIFT), FTM_POL_POL2_SHIFT, FTM_POL_POL2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL3[3] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL3 field. */
#define FTM_RD_POL_POL3(base) ((FTM_POL_REG(base) & FTM_POL_POL3_MASK) >> FTM_POL_POL3_SHIFT)
#define FTM_BRD_POL_POL3(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL3_SHIFT, FTM_POL_POL3_WIDTH))

/*! @brief Set the POL3 field to a new value. */
#define FTM_WR_POL_POL3(base, value) (FTM_RMW_POL(base, FTM_POL_POL3_MASK, FTM_POL_POL3(value)))
#define FTM_BWR_POL_POL3(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL3_SHIFT), FTM_POL_POL3_SHIFT, FTM_POL_POL3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL4[4] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL4 field. */
#define FTM_RD_POL_POL4(base) ((FTM_POL_REG(base) & FTM_POL_POL4_MASK) >> FTM_POL_POL4_SHIFT)
#define FTM_BRD_POL_POL4(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL4_SHIFT, FTM_POL_POL4_WIDTH))

/*! @brief Set the POL4 field to a new value. */
#define FTM_WR_POL_POL4(base, value) (FTM_RMW_POL(base, FTM_POL_POL4_MASK, FTM_POL_POL4(value)))
#define FTM_BWR_POL_POL4(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL4_SHIFT), FTM_POL_POL4_SHIFT, FTM_POL_POL4_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL5[5] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL5 field. */
#define FTM_RD_POL_POL5(base) ((FTM_POL_REG(base) & FTM_POL_POL5_MASK) >> FTM_POL_POL5_SHIFT)
#define FTM_BRD_POL_POL5(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL5_SHIFT, FTM_POL_POL5_WIDTH))

/*! @brief Set the POL5 field to a new value. */
#define FTM_WR_POL_POL5(base, value) (FTM_RMW_POL(base, FTM_POL_POL5_MASK, FTM_POL_POL5(value)))
#define FTM_BWR_POL_POL5(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL5_SHIFT), FTM_POL_POL5_SHIFT, FTM_POL_POL5_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL6[6] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL6 field. */
#define FTM_RD_POL_POL6(base) ((FTM_POL_REG(base) & FTM_POL_POL6_MASK) >> FTM_POL_POL6_SHIFT)
#define FTM_BRD_POL_POL6(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL6_SHIFT, FTM_POL_POL6_WIDTH))

/*! @brief Set the POL6 field to a new value. */
#define FTM_WR_POL_POL6(base, value) (FTM_RMW_POL(base, FTM_POL_POL6_MASK, FTM_POL_POL6(value)))
#define FTM_BWR_POL_POL6(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL6_SHIFT), FTM_POL_POL6_SHIFT, FTM_POL_POL6_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL7[7] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL7 field. */
#define FTM_RD_POL_POL7(base) ((FTM_POL_REG(base) & FTM_POL_POL7_MASK) >> FTM_POL_POL7_SHIFT)
#define FTM_BRD_POL_POL7(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL7_SHIFT, FTM_POL_POL7_WIDTH))

/*! @brief Set the POL7 field to a new value. */
#define FTM_WR_POL_POL7(base, value) (FTM_RMW_POL(base, FTM_POL_POL7_MASK, FTM_POL_POL7(value)))
#define FTM_BWR_POL_POL7(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL7_SHIFT), FTM_POL_POL7_SHIFT, FTM_POL_POL7_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_FMS - Fault Mode Status
 ******************************************************************************/

/*!
 * @brief FTM_FMS - Fault Mode Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the fault detection flags, write protection enable
 * bit, and the logic OR of the enabled fault inputs.
 */
/*!
 * @name Constants and macros for entire FTM_FMS register
 */
/*@{*/
#define FTM_RD_FMS(base)         (FTM_FMS_REG(base))
#define FTM_WR_FMS(base, value)  (FTM_FMS_REG(base) = (value))
#define FTM_RMW_FMS(base, mask, value) (FTM_WR_FMS(base, (FTM_RD_FMS(base) & ~(mask)) | (value)))
#define FTM_SET_FMS(base, value) (BME_OR32(&FTM_FMS_REG(base), (uint32_t)(value)))
#define FTM_CLR_FMS(base, value) (BME_AND32(&FTM_FMS_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_FMS(base, value) (BME_XOR32(&FTM_FMS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FMS bitfields
 */

/*!
 * @name Register FTM_FMS, field FAULTF0[0] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF0
 * by reading the FMS register while FAULTF0 is set and then writing a 0 to
 * FAULTF0 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF0 has no effect. FAULTF0 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF0 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0 - No fault condition was detected at the fault input.
 * - 1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF0 field. */
#define FTM_RD_FMS_FAULTF0(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF0_MASK) >> FTM_FMS_FAULTF0_SHIFT)
#define FTM_BRD_FMS_FAULTF0(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_FAULTF0_SHIFT, FTM_FMS_FAULTF0_WIDTH))

/*! @brief Set the FAULTF0 field to a new value. */
#define FTM_WR_FMS_FAULTF0(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF0_MASK, FTM_FMS_FAULTF0(value)))
#define FTM_BWR_FMS_FAULTF0(base, value) (BME_BFI32(&FTM_FMS_REG(base), ((uint32_t)(value) << FTM_FMS_FAULTF0_SHIFT), FTM_FMS_FAULTF0_SHIFT, FTM_FMS_FAULTF0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF1[1] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF1
 * by reading the FMS register while FAULTF1 is set and then writing a 0 to
 * FAULTF1 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF1 has no effect. FAULTF1 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF1 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0 - No fault condition was detected at the fault input.
 * - 1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF1 field. */
#define FTM_RD_FMS_FAULTF1(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF1_MASK) >> FTM_FMS_FAULTF1_SHIFT)
#define FTM_BRD_FMS_FAULTF1(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_FAULTF1_SHIFT, FTM_FMS_FAULTF1_WIDTH))

/*! @brief Set the FAULTF1 field to a new value. */
#define FTM_WR_FMS_FAULTF1(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF1_MASK, FTM_FMS_FAULTF1(value)))
#define FTM_BWR_FMS_FAULTF1(base, value) (BME_BFI32(&FTM_FMS_REG(base), ((uint32_t)(value) << FTM_FMS_FAULTF1_SHIFT), FTM_FMS_FAULTF1_SHIFT, FTM_FMS_FAULTF1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF2[2] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF2
 * by reading the FMS register while FAULTF2 is set and then writing a 0 to
 * FAULTF2 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF2 has no effect. FAULTF2 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF2 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0 - No fault condition was detected at the fault input.
 * - 1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF2 field. */
#define FTM_RD_FMS_FAULTF2(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF2_MASK) >> FTM_FMS_FAULTF2_SHIFT)
#define FTM_BRD_FMS_FAULTF2(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_FAULTF2_SHIFT, FTM_FMS_FAULTF2_WIDTH))

/*! @brief Set the FAULTF2 field to a new value. */
#define FTM_WR_FMS_FAULTF2(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF2_MASK, FTM_FMS_FAULTF2(value)))
#define FTM_BWR_FMS_FAULTF2(base, value) (BME_BFI32(&FTM_FMS_REG(base), ((uint32_t)(value) << FTM_FMS_FAULTF2_SHIFT), FTM_FMS_FAULTF2_SHIFT, FTM_FMS_FAULTF2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF3[3] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF3
 * by reading the FMS register while FAULTF3 is set and then writing a 0 to
 * FAULTF3 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF3 has no effect. FAULTF3 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF3 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0 - No fault condition was detected at the fault input.
 * - 1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF3 field. */
#define FTM_RD_FMS_FAULTF3(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF3_MASK) >> FTM_FMS_FAULTF3_SHIFT)
#define FTM_BRD_FMS_FAULTF3(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_FAULTF3_SHIFT, FTM_FMS_FAULTF3_WIDTH))

/*! @brief Set the FAULTF3 field to a new value. */
#define FTM_WR_FMS_FAULTF3(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF3_MASK, FTM_FMS_FAULTF3(value)))
#define FTM_BWR_FMS_FAULTF3(base, value) (BME_BFI32(&FTM_FMS_REG(base), ((uint32_t)(value) << FTM_FMS_FAULTF3_SHIFT), FTM_FMS_FAULTF3_SHIFT, FTM_FMS_FAULTF3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTIN[5] (RO)
 *
 * Represents the logic OR of the enabled fault inputs after their filter (if
 * their filter is enabled) when fault control is enabled.
 *
 * Values:
 * - 0 - The logic OR of the enabled fault inputs is 0.
 * - 1 - The logic OR of the enabled fault inputs is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTIN field. */
#define FTM_RD_FMS_FAULTIN(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTIN_MASK) >> FTM_FMS_FAULTIN_SHIFT)
#define FTM_BRD_FMS_FAULTIN(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_FAULTIN_SHIFT, FTM_FMS_FAULTIN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FMS, field WPEN[6] (RW)
 *
 * The WPEN bit is the negation of the WPDIS bit. WPEN is set when 1 is written
 * to it. WPEN is cleared when WPEN bit is read as a 1 and then 1 is written to
 * WPDIS. Writing 0 to WPEN has no effect.
 *
 * Values:
 * - 0 - Write protection is disabled. Write protected bits can be written.
 * - 1 - Write protection is enabled. Write protected bits cannot be written.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_WPEN field. */
#define FTM_RD_FMS_WPEN(base) ((FTM_FMS_REG(base) & FTM_FMS_WPEN_MASK) >> FTM_FMS_WPEN_SHIFT)
#define FTM_BRD_FMS_WPEN(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_WPEN_SHIFT, FTM_FMS_WPEN_WIDTH))

/*! @brief Set the WPEN field to a new value. */
#define FTM_WR_FMS_WPEN(base, value) (FTM_RMW_FMS(base, FTM_FMS_WPEN_MASK, FTM_FMS_WPEN(value)))
#define FTM_BWR_FMS_WPEN(base, value) (BME_BFI32(&FTM_FMS_REG(base), ((uint32_t)(value) << FTM_FMS_WPEN_SHIFT), FTM_FMS_WPEN_SHIFT, FTM_FMS_WPEN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF[7] (ROWZ)
 *
 * Represents the logic OR of the individual FAULTFj bits where j = 3, 2, 1, 0.
 * Clear FAULTF by reading the FMS register while FAULTF is set and then writing
 * a 0 to FAULTF while there is no existing fault condition at the enabled fault
 * inputs. Writing a 1 to FAULTF has no effect. If another fault condition is
 * detected in an enabled fault input before the clearing sequence is completed, the
 * sequence is reset so FAULTF remains set after the clearing sequence is
 * completed for the earlier fault condition. FAULTF is also cleared when FAULTFj bits
 * are cleared individually.
 *
 * Values:
 * - 0 - No fault condition was detected.
 * - 1 - A fault condition was detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF field. */
#define FTM_RD_FMS_FAULTF(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF_MASK) >> FTM_FMS_FAULTF_SHIFT)
#define FTM_BRD_FMS_FAULTF(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_FAULTF_SHIFT, FTM_FMS_FAULTF_WIDTH))

/*! @brief Set the FAULTF field to a new value. */
#define FTM_WR_FMS_FAULTF(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF_MASK, FTM_FMS_FAULTF(value)))
#define FTM_BWR_FMS_FAULTF(base, value) (BME_BFI32(&FTM_FMS_REG(base), ((uint32_t)(value) << FTM_FMS_FAULTF_SHIFT), FTM_FMS_FAULTF_SHIFT, FTM_FMS_FAULTF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_FILTER - Input Capture Filter Control
 ******************************************************************************/

/*!
 * @brief FTM_FILTER - Input Capture Filter Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value for the inputs of channels. Channels
 * 4, 5, 6 and 7 do not have an input filter. Writing to the FILTER register has
 * immediate effect and must be done only when the channels 0, 1, 2, and 3 are not
 * in input modes. Failure to do this could result in a missing valid signal.
 */
/*!
 * @name Constants and macros for entire FTM_FILTER register
 */
/*@{*/
#define FTM_RD_FILTER(base)      (FTM_FILTER_REG(base))
#define FTM_WR_FILTER(base, value) (FTM_FILTER_REG(base) = (value))
#define FTM_RMW_FILTER(base, mask, value) (FTM_WR_FILTER(base, (FTM_RD_FILTER(base) & ~(mask)) | (value)))
#define FTM_SET_FILTER(base, value) (BME_OR32(&FTM_FILTER_REG(base), (uint32_t)(value)))
#define FTM_CLR_FILTER(base, value) (BME_AND32(&FTM_FILTER_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_FILTER(base, value) (BME_XOR32(&FTM_FILTER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FILTER bitfields
 */

/*!
 * @name Register FTM_FILTER, field CH0FVAL[3:0] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH0FVAL field. */
#define FTM_RD_FILTER_CH0FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH0FVAL_MASK) >> FTM_FILTER_CH0FVAL_SHIFT)
#define FTM_BRD_FILTER_CH0FVAL(base) (BME_UBFX32(&FTM_FILTER_REG(base), FTM_FILTER_CH0FVAL_SHIFT, FTM_FILTER_CH0FVAL_WIDTH))

/*! @brief Set the CH0FVAL field to a new value. */
#define FTM_WR_FILTER_CH0FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH0FVAL_MASK, FTM_FILTER_CH0FVAL(value)))
#define FTM_BWR_FILTER_CH0FVAL(base, value) (BME_BFI32(&FTM_FILTER_REG(base), ((uint32_t)(value) << FTM_FILTER_CH0FVAL_SHIFT), FTM_FILTER_CH0FVAL_SHIFT, FTM_FILTER_CH0FVAL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH1FVAL[7:4] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH1FVAL field. */
#define FTM_RD_FILTER_CH1FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH1FVAL_MASK) >> FTM_FILTER_CH1FVAL_SHIFT)
#define FTM_BRD_FILTER_CH1FVAL(base) (BME_UBFX32(&FTM_FILTER_REG(base), FTM_FILTER_CH1FVAL_SHIFT, FTM_FILTER_CH1FVAL_WIDTH))

/*! @brief Set the CH1FVAL field to a new value. */
#define FTM_WR_FILTER_CH1FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH1FVAL_MASK, FTM_FILTER_CH1FVAL(value)))
#define FTM_BWR_FILTER_CH1FVAL(base, value) (BME_BFI32(&FTM_FILTER_REG(base), ((uint32_t)(value) << FTM_FILTER_CH1FVAL_SHIFT), FTM_FILTER_CH1FVAL_SHIFT, FTM_FILTER_CH1FVAL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH2FVAL[11:8] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH2FVAL field. */
#define FTM_RD_FILTER_CH2FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH2FVAL_MASK) >> FTM_FILTER_CH2FVAL_SHIFT)
#define FTM_BRD_FILTER_CH2FVAL(base) (BME_UBFX32(&FTM_FILTER_REG(base), FTM_FILTER_CH2FVAL_SHIFT, FTM_FILTER_CH2FVAL_WIDTH))

/*! @brief Set the CH2FVAL field to a new value. */
#define FTM_WR_FILTER_CH2FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH2FVAL_MASK, FTM_FILTER_CH2FVAL(value)))
#define FTM_BWR_FILTER_CH2FVAL(base, value) (BME_BFI32(&FTM_FILTER_REG(base), ((uint32_t)(value) << FTM_FILTER_CH2FVAL_SHIFT), FTM_FILTER_CH2FVAL_SHIFT, FTM_FILTER_CH2FVAL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH3FVAL[15:12] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH3FVAL field. */
#define FTM_RD_FILTER_CH3FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH3FVAL_MASK) >> FTM_FILTER_CH3FVAL_SHIFT)
#define FTM_BRD_FILTER_CH3FVAL(base) (BME_UBFX32(&FTM_FILTER_REG(base), FTM_FILTER_CH3FVAL_SHIFT, FTM_FILTER_CH3FVAL_WIDTH))

/*! @brief Set the CH3FVAL field to a new value. */
#define FTM_WR_FILTER_CH3FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH3FVAL_MASK, FTM_FILTER_CH3FVAL(value)))
#define FTM_BWR_FILTER_CH3FVAL(base, value) (BME_BFI32(&FTM_FILTER_REG(base), ((uint32_t)(value) << FTM_FILTER_CH3FVAL_SHIFT), FTM_FILTER_CH3FVAL_SHIFT, FTM_FILTER_CH3FVAL_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_FLTCTRL - Fault Control
 ******************************************************************************/

/*!
 * @brief FTM_FLTCTRL - Fault Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value for the fault inputs, enables the
 * fault inputs and the fault inputs filter.
 */
/*!
 * @name Constants and macros for entire FTM_FLTCTRL register
 */
/*@{*/
#define FTM_RD_FLTCTRL(base)     (FTM_FLTCTRL_REG(base))
#define FTM_WR_FLTCTRL(base, value) (FTM_FLTCTRL_REG(base) = (value))
#define FTM_RMW_FLTCTRL(base, mask, value) (FTM_WR_FLTCTRL(base, (FTM_RD_FLTCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_FLTCTRL(base, value) (BME_OR32(&FTM_FLTCTRL_REG(base), (uint32_t)(value)))
#define FTM_CLR_FLTCTRL(base, value) (BME_AND32(&FTM_FLTCTRL_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_FLTCTRL(base, value) (BME_XOR32(&FTM_FLTCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FLTCTRL bitfields
 */

/*!
 * @name Register FTM_FLTCTRL, field FAULT0EN[0] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input is disabled.
 * - 1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT0EN field. */
#define FTM_RD_FLTCTRL_FAULT0EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT0EN_MASK) >> FTM_FLTCTRL_FAULT0EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT0EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT0EN_SHIFT, FTM_FLTCTRL_FAULT0EN_WIDTH))

/*! @brief Set the FAULT0EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT0EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT0EN_MASK, FTM_FLTCTRL_FAULT0EN(value)))
#define FTM_BWR_FLTCTRL_FAULT0EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FAULT0EN_SHIFT), FTM_FLTCTRL_FAULT0EN_SHIFT, FTM_FLTCTRL_FAULT0EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT1EN[1] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input is disabled.
 * - 1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT1EN field. */
#define FTM_RD_FLTCTRL_FAULT1EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT1EN_MASK) >> FTM_FLTCTRL_FAULT1EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT1EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT1EN_SHIFT, FTM_FLTCTRL_FAULT1EN_WIDTH))

/*! @brief Set the FAULT1EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT1EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT1EN_MASK, FTM_FLTCTRL_FAULT1EN(value)))
#define FTM_BWR_FLTCTRL_FAULT1EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FAULT1EN_SHIFT), FTM_FLTCTRL_FAULT1EN_SHIFT, FTM_FLTCTRL_FAULT1EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT2EN[2] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input is disabled.
 * - 1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT2EN field. */
#define FTM_RD_FLTCTRL_FAULT2EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT2EN_MASK) >> FTM_FLTCTRL_FAULT2EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT2EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT2EN_SHIFT, FTM_FLTCTRL_FAULT2EN_WIDTH))

/*! @brief Set the FAULT2EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT2EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT2EN_MASK, FTM_FLTCTRL_FAULT2EN(value)))
#define FTM_BWR_FLTCTRL_FAULT2EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FAULT2EN_SHIFT), FTM_FLTCTRL_FAULT2EN_SHIFT, FTM_FLTCTRL_FAULT2EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT3EN[3] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input is disabled.
 * - 1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT3EN field. */
#define FTM_RD_FLTCTRL_FAULT3EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT3EN_MASK) >> FTM_FLTCTRL_FAULT3EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT3EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT3EN_SHIFT, FTM_FLTCTRL_FAULT3EN_WIDTH))

/*! @brief Set the FAULT3EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT3EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT3EN_MASK, FTM_FLTCTRL_FAULT3EN(value)))
#define FTM_BWR_FLTCTRL_FAULT3EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FAULT3EN_SHIFT), FTM_FLTCTRL_FAULT3EN_SHIFT, FTM_FLTCTRL_FAULT3EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR0EN[4] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input filter is disabled.
 * - 1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR0EN field. */
#define FTM_RD_FLTCTRL_FFLTR0EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR0EN_MASK) >> FTM_FLTCTRL_FFLTR0EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR0EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR0EN_SHIFT, FTM_FLTCTRL_FFLTR0EN_WIDTH))

/*! @brief Set the FFLTR0EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR0EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR0EN_MASK, FTM_FLTCTRL_FFLTR0EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR0EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FFLTR0EN_SHIFT), FTM_FLTCTRL_FFLTR0EN_SHIFT, FTM_FLTCTRL_FFLTR0EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR1EN[5] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input filter is disabled.
 * - 1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR1EN field. */
#define FTM_RD_FLTCTRL_FFLTR1EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR1EN_MASK) >> FTM_FLTCTRL_FFLTR1EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR1EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR1EN_SHIFT, FTM_FLTCTRL_FFLTR1EN_WIDTH))

/*! @brief Set the FFLTR1EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR1EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR1EN_MASK, FTM_FLTCTRL_FFLTR1EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR1EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FFLTR1EN_SHIFT), FTM_FLTCTRL_FFLTR1EN_SHIFT, FTM_FLTCTRL_FFLTR1EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR2EN[6] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input filter is disabled.
 * - 1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR2EN field. */
#define FTM_RD_FLTCTRL_FFLTR2EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR2EN_MASK) >> FTM_FLTCTRL_FFLTR2EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR2EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR2EN_SHIFT, FTM_FLTCTRL_FFLTR2EN_WIDTH))

/*! @brief Set the FFLTR2EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR2EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR2EN_MASK, FTM_FLTCTRL_FFLTR2EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR2EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FFLTR2EN_SHIFT), FTM_FLTCTRL_FFLTR2EN_SHIFT, FTM_FLTCTRL_FFLTR2EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR3EN[7] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input filter is disabled.
 * - 1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR3EN field. */
#define FTM_RD_FLTCTRL_FFLTR3EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR3EN_MASK) >> FTM_FLTCTRL_FFLTR3EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR3EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR3EN_SHIFT, FTM_FLTCTRL_FFLTR3EN_WIDTH))

/*! @brief Set the FFLTR3EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR3EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR3EN_MASK, FTM_FLTCTRL_FFLTR3EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR3EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FFLTR3EN_SHIFT), FTM_FLTCTRL_FFLTR3EN_SHIFT, FTM_FLTCTRL_FFLTR3EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFVAL[11:8] (RW)
 *
 * Selects the filter value for the fault inputs. The fault filter is disabled
 * when the value is zero. Writing to this field has immediate effect and must be
 * done only when the fault control or all fault inputs are disabled. Failure to
 * do this could result in a missing fault detection.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFVAL field. */
#define FTM_RD_FLTCTRL_FFVAL(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFVAL_MASK) >> FTM_FLTCTRL_FFVAL_SHIFT)
#define FTM_BRD_FLTCTRL_FFVAL(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFVAL_SHIFT, FTM_FLTCTRL_FFVAL_WIDTH))

/*! @brief Set the FFVAL field to a new value. */
#define FTM_WR_FLTCTRL_FFVAL(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFVAL_MASK, FTM_FLTCTRL_FFVAL(value)))
#define FTM_BWR_FLTCTRL_FFVAL(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FFVAL_SHIFT), FTM_FLTCTRL_FFVAL_SHIFT, FTM_FLTCTRL_FFVAL_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_QDCTRL - Quadrature Decoder Control And Status
 ******************************************************************************/

/*!
 * @brief FTM_QDCTRL - Quadrature Decoder Control And Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has the control and status bits for the Quadrature Decoder mode.
 */
/*!
 * @name Constants and macros for entire FTM_QDCTRL register
 */
/*@{*/
#define FTM_RD_QDCTRL(base)      (FTM_QDCTRL_REG(base))
#define FTM_WR_QDCTRL(base, value) (FTM_QDCTRL_REG(base) = (value))
#define FTM_RMW_QDCTRL(base, mask, value) (FTM_WR_QDCTRL(base, (FTM_RD_QDCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_QDCTRL(base, value) (BME_OR32(&FTM_QDCTRL_REG(base), (uint32_t)(value)))
#define FTM_CLR_QDCTRL(base, value) (BME_AND32(&FTM_QDCTRL_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_QDCTRL(base, value) (BME_XOR32(&FTM_QDCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_QDCTRL bitfields
 */

/*!
 * @name Register FTM_QDCTRL, field QUADEN[0] (RW)
 *
 * Enables the Quadrature Decoder mode. In this mode, the phase A and B input
 * signals control the FTM counter direction. The Quadrature Decoder mode has
 * precedence over the other modes. See #ModeSel1Table. This field is write protected.
 * It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Quadrature Decoder mode is disabled.
 * - 1 - Quadrature Decoder mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_QUADEN field. */
#define FTM_RD_QDCTRL_QUADEN(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_QUADEN_MASK) >> FTM_QDCTRL_QUADEN_SHIFT)
#define FTM_BRD_QDCTRL_QUADEN(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADEN_SHIFT, FTM_QDCTRL_QUADEN_WIDTH))

/*! @brief Set the QUADEN field to a new value. */
#define FTM_WR_QDCTRL_QUADEN(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_QUADEN_MASK, FTM_QDCTRL_QUADEN(value)))
#define FTM_BWR_QDCTRL_QUADEN(base, value) (BME_BFI32(&FTM_QDCTRL_REG(base), ((uint32_t)(value) << FTM_QDCTRL_QUADEN_SHIFT), FTM_QDCTRL_QUADEN_SHIFT, FTM_QDCTRL_QUADEN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field TOFDIR[1] (RO)
 *
 * Indicates if the TOF bit was set on the top or the bottom of counting.
 *
 * Values:
 * - 0 - TOF bit was set on the bottom of counting. There was an FTM counter
 *     decrement and FTM counter changes from its minimum value (CNTIN register) to
 *     its maximum value (MOD register).
 * - 1 - TOF bit was set on the top of counting. There was an FTM counter
 *     increment and FTM counter changes from its maximum value (MOD register) to its
 *     minimum value (CNTIN register).
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_TOFDIR field. */
#define FTM_RD_QDCTRL_TOFDIR(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_TOFDIR_MASK) >> FTM_QDCTRL_TOFDIR_SHIFT)
#define FTM_BRD_QDCTRL_TOFDIR(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_TOFDIR_SHIFT, FTM_QDCTRL_TOFDIR_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field QUADIR[2] (RO)
 *
 * Indicates the counting direction.
 *
 * Values:
 * - 0 - Counting direction is decreasing (FTM counter decrement).
 * - 1 - Counting direction is increasing (FTM counter increment).
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_QUADIR field. */
#define FTM_RD_QDCTRL_QUADIR(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_QUADIR_MASK) >> FTM_QDCTRL_QUADIR_SHIFT)
#define FTM_BRD_QDCTRL_QUADIR(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADIR_SHIFT, FTM_QDCTRL_QUADIR_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field QUADMODE[3] (RW)
 *
 * Selects the encoding mode used in the Quadrature Decoder mode.
 *
 * Values:
 * - 0 - Phase A and phase B encoding mode.
 * - 1 - Count and direction encoding mode.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_QUADMODE field. */
#define FTM_RD_QDCTRL_QUADMODE(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_QUADMODE_MASK) >> FTM_QDCTRL_QUADMODE_SHIFT)
#define FTM_BRD_QDCTRL_QUADMODE(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADMODE_SHIFT, FTM_QDCTRL_QUADMODE_WIDTH))

/*! @brief Set the QUADMODE field to a new value. */
#define FTM_WR_QDCTRL_QUADMODE(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_QUADMODE_MASK, FTM_QDCTRL_QUADMODE(value)))
#define FTM_BWR_QDCTRL_QUADMODE(base, value) (BME_BFI32(&FTM_QDCTRL_REG(base), ((uint32_t)(value) << FTM_QDCTRL_QUADMODE_SHIFT), FTM_QDCTRL_QUADMODE_SHIFT, FTM_QDCTRL_QUADMODE_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHBPOL[4] (RW)
 *
 * Selects the polarity for the quadrature decoder phase B input.
 *
 * Values:
 * - 0 - Normal polarity. Phase B input signal is not inverted before
 *     identifying the rising and falling edges of this signal.
 * - 1 - Inverted polarity. Phase B input signal is inverted before identifying
 *     the rising and falling edges of this signal.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHBPOL field. */
#define FTM_RD_QDCTRL_PHBPOL(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHBPOL_MASK) >> FTM_QDCTRL_PHBPOL_SHIFT)
#define FTM_BRD_QDCTRL_PHBPOL(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHBPOL_SHIFT, FTM_QDCTRL_PHBPOL_WIDTH))

/*! @brief Set the PHBPOL field to a new value. */
#define FTM_WR_QDCTRL_PHBPOL(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHBPOL_MASK, FTM_QDCTRL_PHBPOL(value)))
#define FTM_BWR_QDCTRL_PHBPOL(base, value) (BME_BFI32(&FTM_QDCTRL_REG(base), ((uint32_t)(value) << FTM_QDCTRL_PHBPOL_SHIFT), FTM_QDCTRL_PHBPOL_SHIFT, FTM_QDCTRL_PHBPOL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHAPOL[5] (RW)
 *
 * Selects the polarity for the quadrature decoder phase A input.
 *
 * Values:
 * - 0 - Normal polarity. Phase A input signal is not inverted before
 *     identifying the rising and falling edges of this signal.
 * - 1 - Inverted polarity. Phase A input signal is inverted before identifying
 *     the rising and falling edges of this signal.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHAPOL field. */
#define FTM_RD_QDCTRL_PHAPOL(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHAPOL_MASK) >> FTM_QDCTRL_PHAPOL_SHIFT)
#define FTM_BRD_QDCTRL_PHAPOL(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHAPOL_SHIFT, FTM_QDCTRL_PHAPOL_WIDTH))

/*! @brief Set the PHAPOL field to a new value. */
#define FTM_WR_QDCTRL_PHAPOL(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHAPOL_MASK, FTM_QDCTRL_PHAPOL(value)))
#define FTM_BWR_QDCTRL_PHAPOL(base, value) (BME_BFI32(&FTM_QDCTRL_REG(base), ((uint32_t)(value) << FTM_QDCTRL_PHAPOL_SHIFT), FTM_QDCTRL_PHAPOL_SHIFT, FTM_QDCTRL_PHAPOL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHBFLTREN[6] (RW)
 *
 * Enables the filter for the quadrature decoder phase B input. The filter value
 * for the phase B input is defined by the CH1FVAL field of FILTER. The phase B
 * filter is also disabled when CH1FVAL is zero.
 *
 * Values:
 * - 0 - Phase B input filter is disabled.
 * - 1 - Phase B input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHBFLTREN field. */
#define FTM_RD_QDCTRL_PHBFLTREN(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHBFLTREN_MASK) >> FTM_QDCTRL_PHBFLTREN_SHIFT)
#define FTM_BRD_QDCTRL_PHBFLTREN(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHBFLTREN_SHIFT, FTM_QDCTRL_PHBFLTREN_WIDTH))

/*! @brief Set the PHBFLTREN field to a new value. */
#define FTM_WR_QDCTRL_PHBFLTREN(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHBFLTREN_MASK, FTM_QDCTRL_PHBFLTREN(value)))
#define FTM_BWR_QDCTRL_PHBFLTREN(base, value) (BME_BFI32(&FTM_QDCTRL_REG(base), ((uint32_t)(value) << FTM_QDCTRL_PHBFLTREN_SHIFT), FTM_QDCTRL_PHBFLTREN_SHIFT, FTM_QDCTRL_PHBFLTREN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHAFLTREN[7] (RW)
 *
 * Enables the filter for the quadrature decoder phase A input. The filter value
 * for the phase A input is defined by the CH0FVAL field of FILTER. The phase A
 * filter is also disabled when CH0FVAL is zero.
 *
 * Values:
 * - 0 - Phase A input filter is disabled.
 * - 1 - Phase A input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHAFLTREN field. */
#define FTM_RD_QDCTRL_PHAFLTREN(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHAFLTREN_MASK) >> FTM_QDCTRL_PHAFLTREN_SHIFT)
#define FTM_BRD_QDCTRL_PHAFLTREN(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHAFLTREN_SHIFT, FTM_QDCTRL_PHAFLTREN_WIDTH))

/*! @brief Set the PHAFLTREN field to a new value. */
#define FTM_WR_QDCTRL_PHAFLTREN(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHAFLTREN_MASK, FTM_QDCTRL_PHAFLTREN(value)))
#define FTM_BWR_QDCTRL_PHAFLTREN(base, value) (BME_BFI32(&FTM_QDCTRL_REG(base), ((uint32_t)(value) << FTM_QDCTRL_PHAFLTREN_SHIFT), FTM_QDCTRL_PHAFLTREN_SHIFT, FTM_QDCTRL_PHAFLTREN_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_CONF - Configuration
 ******************************************************************************/

/*!
 * @brief FTM_CONF - Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the number of times that the FTM counter overflow
 * should occur before the TOF bit to be set, the FTM behavior in BDM modes, the use
 * of an external global time base, and the global time base signal generation.
 */
/*!
 * @name Constants and macros for entire FTM_CONF register
 */
/*@{*/
#define FTM_RD_CONF(base)        (FTM_CONF_REG(base))
#define FTM_WR_CONF(base, value) (FTM_CONF_REG(base) = (value))
#define FTM_RMW_CONF(base, mask, value) (FTM_WR_CONF(base, (FTM_RD_CONF(base) & ~(mask)) | (value)))
#define FTM_SET_CONF(base, value) (BME_OR32(&FTM_CONF_REG(base), (uint32_t)(value)))
#define FTM_CLR_CONF(base, value) (BME_AND32(&FTM_CONF_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_CONF(base, value) (BME_XOR32(&FTM_CONF_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CONF bitfields
 */

/*!
 * @name Register FTM_CONF, field NUMTOF[4:0] (RW)
 *
 * Selects the ratio between the number of counter overflows to the number of
 * times the TOF bit is set. NUMTOF = 0: The TOF bit is set for each counter
 * overflow. NUMTOF = 1: The TOF bit is set for the first counter overflow but not for
 * the next overflow. NUMTOF = 2: The TOF bit is set for the first counter
 * overflow but not for the next 2 overflows. NUMTOF = 3: The TOF bit is set for the
 * first counter overflow but not for the next 3 overflows. This pattern continues
 * up to a maximum of 31.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_NUMTOF field. */
#define FTM_RD_CONF_NUMTOF(base) ((FTM_CONF_REG(base) & FTM_CONF_NUMTOF_MASK) >> FTM_CONF_NUMTOF_SHIFT)
#define FTM_BRD_CONF_NUMTOF(base) (BME_UBFX32(&FTM_CONF_REG(base), FTM_CONF_NUMTOF_SHIFT, FTM_CONF_NUMTOF_WIDTH))

/*! @brief Set the NUMTOF field to a new value. */
#define FTM_WR_CONF_NUMTOF(base, value) (FTM_RMW_CONF(base, FTM_CONF_NUMTOF_MASK, FTM_CONF_NUMTOF(value)))
#define FTM_BWR_CONF_NUMTOF(base, value) (BME_BFI32(&FTM_CONF_REG(base), ((uint32_t)(value) << FTM_CONF_NUMTOF_SHIFT), FTM_CONF_NUMTOF_SHIFT, FTM_CONF_NUMTOF_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CONF, field BDMMODE[7:6] (RW)
 *
 * Selects the FTM behavior in BDM mode. See BDM mode.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_BDMMODE field. */
#define FTM_RD_CONF_BDMMODE(base) ((FTM_CONF_REG(base) & FTM_CONF_BDMMODE_MASK) >> FTM_CONF_BDMMODE_SHIFT)
#define FTM_BRD_CONF_BDMMODE(base) (BME_UBFX32(&FTM_CONF_REG(base), FTM_CONF_BDMMODE_SHIFT, FTM_CONF_BDMMODE_WIDTH))

/*! @brief Set the BDMMODE field to a new value. */
#define FTM_WR_CONF_BDMMODE(base, value) (FTM_RMW_CONF(base, FTM_CONF_BDMMODE_MASK, FTM_CONF_BDMMODE(value)))
#define FTM_BWR_CONF_BDMMODE(base, value) (BME_BFI32(&FTM_CONF_REG(base), ((uint32_t)(value) << FTM_CONF_BDMMODE_SHIFT), FTM_CONF_BDMMODE_SHIFT, FTM_CONF_BDMMODE_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CONF, field GTBEEN[9] (RW)
 *
 * Configures the FTM to use an external global time base signal that is
 * generated by another FTM.
 *
 * Values:
 * - 0 - Use of an external global time base is disabled.
 * - 1 - Use of an external global time base is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_GTBEEN field. */
#define FTM_RD_CONF_GTBEEN(base) ((FTM_CONF_REG(base) & FTM_CONF_GTBEEN_MASK) >> FTM_CONF_GTBEEN_SHIFT)
#define FTM_BRD_CONF_GTBEEN(base) (BME_UBFX32(&FTM_CONF_REG(base), FTM_CONF_GTBEEN_SHIFT, FTM_CONF_GTBEEN_WIDTH))

/*! @brief Set the GTBEEN field to a new value. */
#define FTM_WR_CONF_GTBEEN(base, value) (FTM_RMW_CONF(base, FTM_CONF_GTBEEN_MASK, FTM_CONF_GTBEEN(value)))
#define FTM_BWR_CONF_GTBEEN(base, value) (BME_BFI32(&FTM_CONF_REG(base), ((uint32_t)(value) << FTM_CONF_GTBEEN_SHIFT), FTM_CONF_GTBEEN_SHIFT, FTM_CONF_GTBEEN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CONF, field GTBEOUT[10] (RW)
 *
 * Enables the global time base signal generation to other FTMs.
 *
 * Values:
 * - 0 - A global time base signal generation is disabled.
 * - 1 - A global time base signal generation is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_GTBEOUT field. */
#define FTM_RD_CONF_GTBEOUT(base) ((FTM_CONF_REG(base) & FTM_CONF_GTBEOUT_MASK) >> FTM_CONF_GTBEOUT_SHIFT)
#define FTM_BRD_CONF_GTBEOUT(base) (BME_UBFX32(&FTM_CONF_REG(base), FTM_CONF_GTBEOUT_SHIFT, FTM_CONF_GTBEOUT_WIDTH))

/*! @brief Set the GTBEOUT field to a new value. */
#define FTM_WR_CONF_GTBEOUT(base, value) (FTM_RMW_CONF(base, FTM_CONF_GTBEOUT_MASK, FTM_CONF_GTBEOUT(value)))
#define FTM_BWR_CONF_GTBEOUT(base, value) (BME_BFI32(&FTM_CONF_REG(base), ((uint32_t)(value) << FTM_CONF_GTBEOUT_SHIFT), FTM_CONF_GTBEOUT_SHIFT, FTM_CONF_GTBEOUT_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_FLTPOL - FTM Fault Input Polarity
 ******************************************************************************/

/*!
 * @brief FTM_FLTPOL - FTM Fault Input Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the fault inputs polarity.
 */
/*!
 * @name Constants and macros for entire FTM_FLTPOL register
 */
/*@{*/
#define FTM_RD_FLTPOL(base)      (FTM_FLTPOL_REG(base))
#define FTM_WR_FLTPOL(base, value) (FTM_FLTPOL_REG(base) = (value))
#define FTM_RMW_FLTPOL(base, mask, value) (FTM_WR_FLTPOL(base, (FTM_RD_FLTPOL(base) & ~(mask)) | (value)))
#define FTM_SET_FLTPOL(base, value) (BME_OR32(&FTM_FLTPOL_REG(base), (uint32_t)(value)))
#define FTM_CLR_FLTPOL(base, value) (BME_AND32(&FTM_FLTPOL_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_FLTPOL(base, value) (BME_XOR32(&FTM_FLTPOL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FLTPOL bitfields
 */

/*!
 * @name Register FTM_FLTPOL, field FLT0POL[0] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT0POL field. */
#define FTM_RD_FLTPOL_FLT0POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT0POL_MASK) >> FTM_FLTPOL_FLT0POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT0POL(base) (BME_UBFX32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT0POL_SHIFT, FTM_FLTPOL_FLT0POL_WIDTH))

/*! @brief Set the FLT0POL field to a new value. */
#define FTM_WR_FLTPOL_FLT0POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT0POL_MASK, FTM_FLTPOL_FLT0POL(value)))
#define FTM_BWR_FLTPOL_FLT0POL(base, value) (BME_BFI32(&FTM_FLTPOL_REG(base), ((uint32_t)(value) << FTM_FLTPOL_FLT0POL_SHIFT), FTM_FLTPOL_FLT0POL_SHIFT, FTM_FLTPOL_FLT0POL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT1POL[1] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT1POL field. */
#define FTM_RD_FLTPOL_FLT1POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT1POL_MASK) >> FTM_FLTPOL_FLT1POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT1POL(base) (BME_UBFX32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT1POL_SHIFT, FTM_FLTPOL_FLT1POL_WIDTH))

/*! @brief Set the FLT1POL field to a new value. */
#define FTM_WR_FLTPOL_FLT1POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT1POL_MASK, FTM_FLTPOL_FLT1POL(value)))
#define FTM_BWR_FLTPOL_FLT1POL(base, value) (BME_BFI32(&FTM_FLTPOL_REG(base), ((uint32_t)(value) << FTM_FLTPOL_FLT1POL_SHIFT), FTM_FLTPOL_FLT1POL_SHIFT, FTM_FLTPOL_FLT1POL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT2POL[2] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT2POL field. */
#define FTM_RD_FLTPOL_FLT2POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT2POL_MASK) >> FTM_FLTPOL_FLT2POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT2POL(base) (BME_UBFX32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT2POL_SHIFT, FTM_FLTPOL_FLT2POL_WIDTH))

/*! @brief Set the FLT2POL field to a new value. */
#define FTM_WR_FLTPOL_FLT2POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT2POL_MASK, FTM_FLTPOL_FLT2POL(value)))
#define FTM_BWR_FLTPOL_FLT2POL(base, value) (BME_BFI32(&FTM_FLTPOL_REG(base), ((uint32_t)(value) << FTM_FLTPOL_FLT2POL_SHIFT), FTM_FLTPOL_FLT2POL_SHIFT, FTM_FLTPOL_FLT2POL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT3POL[3] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT3POL field. */
#define FTM_RD_FLTPOL_FLT3POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT3POL_MASK) >> FTM_FLTPOL_FLT3POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT3POL(base) (BME_UBFX32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT3POL_SHIFT, FTM_FLTPOL_FLT3POL_WIDTH))

/*! @brief Set the FLT3POL field to a new value. */
#define FTM_WR_FLTPOL_FLT3POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT3POL_MASK, FTM_FLTPOL_FLT3POL(value)))
#define FTM_BWR_FLTPOL_FLT3POL(base, value) (BME_BFI32(&FTM_FLTPOL_REG(base), ((uint32_t)(value) << FTM_FLTPOL_FLT3POL_SHIFT), FTM_FLTPOL_FLT3POL_SHIFT, FTM_FLTPOL_FLT3POL_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_SYNCONF - Synchronization Configuration
 ******************************************************************************/

/*!
 * @brief FTM_SYNCONF - Synchronization Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the PWM synchronization configuration, SWOCTRL, INVCTRL
 * and CNTIN registers synchronization, if FTM clears the TRIGj bit, where j =
 * 0, 1, 2, when the hardware trigger j is detected.
 */
/*!
 * @name Constants and macros for entire FTM_SYNCONF register
 */
/*@{*/
#define FTM_RD_SYNCONF(base)     (FTM_SYNCONF_REG(base))
#define FTM_WR_SYNCONF(base, value) (FTM_SYNCONF_REG(base) = (value))
#define FTM_RMW_SYNCONF(base, mask, value) (FTM_WR_SYNCONF(base, (FTM_RD_SYNCONF(base) & ~(mask)) | (value)))
#define FTM_SET_SYNCONF(base, value) (BME_OR32(&FTM_SYNCONF_REG(base), (uint32_t)(value)))
#define FTM_CLR_SYNCONF(base, value) (BME_AND32(&FTM_SYNCONF_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_SYNCONF(base, value) (BME_XOR32(&FTM_SYNCONF_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SYNCONF bitfields
 */

/*!
 * @name Register FTM_SYNCONF, field HWTRIGMODE[0] (RW)
 *
 * Values:
 * - 0 - FTM clears the TRIGj bit when the hardware trigger j is detected, where
 *     j = 0, 1,2.
 * - 1 - FTM does not clear the TRIGj bit when the hardware trigger j is
 *     detected, where j = 0, 1,2.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWTRIGMODE field. */
#define FTM_RD_SYNCONF_HWTRIGMODE(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWTRIGMODE_MASK) >> FTM_SYNCONF_HWTRIGMODE_SHIFT)
#define FTM_BRD_SYNCONF_HWTRIGMODE(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWTRIGMODE_SHIFT, FTM_SYNCONF_HWTRIGMODE_WIDTH))

/*! @brief Set the HWTRIGMODE field to a new value. */
#define FTM_WR_SYNCONF_HWTRIGMODE(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWTRIGMODE_MASK, FTM_SYNCONF_HWTRIGMODE(value)))
#define FTM_BWR_SYNCONF_HWTRIGMODE(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_HWTRIGMODE_SHIFT), FTM_SYNCONF_HWTRIGMODE_SHIFT, FTM_SYNCONF_HWTRIGMODE_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field CNTINC[2] (RW)
 *
 * Values:
 * - 0 - CNTIN register is updated with its buffer value at all rising edges of
 *     system clock.
 * - 1 - CNTIN register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_CNTINC field. */
#define FTM_RD_SYNCONF_CNTINC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_CNTINC_MASK) >> FTM_SYNCONF_CNTINC_SHIFT)
#define FTM_BRD_SYNCONF_CNTINC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_CNTINC_SHIFT, FTM_SYNCONF_CNTINC_WIDTH))

/*! @brief Set the CNTINC field to a new value. */
#define FTM_WR_SYNCONF_CNTINC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_CNTINC_MASK, FTM_SYNCONF_CNTINC(value)))
#define FTM_BWR_SYNCONF_CNTINC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_CNTINC_SHIFT), FTM_SYNCONF_CNTINC_SHIFT, FTM_SYNCONF_CNTINC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field INVC[4] (RW)
 *
 * Values:
 * - 0 - INVCTRL register is updated with its buffer value at all rising edges
 *     of system clock.
 * - 1 - INVCTRL register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_INVC field. */
#define FTM_RD_SYNCONF_INVC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_INVC_MASK) >> FTM_SYNCONF_INVC_SHIFT)
#define FTM_BRD_SYNCONF_INVC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_INVC_SHIFT, FTM_SYNCONF_INVC_WIDTH))

/*! @brief Set the INVC field to a new value. */
#define FTM_WR_SYNCONF_INVC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_INVC_MASK, FTM_SYNCONF_INVC(value)))
#define FTM_BWR_SYNCONF_INVC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_INVC_SHIFT), FTM_SYNCONF_INVC_SHIFT, FTM_SYNCONF_INVC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWOC[5] (RW)
 *
 * Values:
 * - 0 - SWOCTRL register is updated with its buffer value at all rising edges
 *     of system clock.
 * - 1 - SWOCTRL register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWOC field. */
#define FTM_RD_SYNCONF_SWOC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWOC_MASK) >> FTM_SYNCONF_SWOC_SHIFT)
#define FTM_BRD_SYNCONF_SWOC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWOC_SHIFT, FTM_SYNCONF_SWOC_WIDTH))

/*! @brief Set the SWOC field to a new value. */
#define FTM_WR_SYNCONF_SWOC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWOC_MASK, FTM_SYNCONF_SWOC(value)))
#define FTM_BWR_SYNCONF_SWOC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SWOC_SHIFT), FTM_SYNCONF_SWOC_SHIFT, FTM_SYNCONF_SWOC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SYNCMODE[7] (RW)
 *
 * Selects the PWM Synchronization mode.
 *
 * Values:
 * - 0 - Legacy PWM synchronization is selected.
 * - 1 - Enhanced PWM synchronization is selected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SYNCMODE field. */
#define FTM_RD_SYNCONF_SYNCMODE(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SYNCMODE_MASK) >> FTM_SYNCONF_SYNCMODE_SHIFT)
#define FTM_BRD_SYNCONF_SYNCMODE(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SYNCMODE_SHIFT, FTM_SYNCONF_SYNCMODE_WIDTH))

/*! @brief Set the SYNCMODE field to a new value. */
#define FTM_WR_SYNCONF_SYNCMODE(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SYNCMODE_MASK, FTM_SYNCONF_SYNCMODE(value)))
#define FTM_BWR_SYNCONF_SYNCMODE(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SYNCMODE_SHIFT), FTM_SYNCONF_SYNCMODE_SHIFT, FTM_SYNCONF_SYNCMODE_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWRSTCNT[8] (RW)
 *
 * FTM counter synchronization is activated by the software trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate the FTM counter synchronization.
 * - 1 - The software trigger activates the FTM counter synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWRSTCNT field. */
#define FTM_RD_SYNCONF_SWRSTCNT(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWRSTCNT_MASK) >> FTM_SYNCONF_SWRSTCNT_SHIFT)
#define FTM_BRD_SYNCONF_SWRSTCNT(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWRSTCNT_SHIFT, FTM_SYNCONF_SWRSTCNT_WIDTH))

/*! @brief Set the SWRSTCNT field to a new value. */
#define FTM_WR_SYNCONF_SWRSTCNT(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWRSTCNT_MASK, FTM_SYNCONF_SWRSTCNT(value)))
#define FTM_BWR_SYNCONF_SWRSTCNT(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SWRSTCNT_SHIFT), FTM_SYNCONF_SWRSTCNT_SHIFT, FTM_SYNCONF_SWRSTCNT_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWWRBUF[9] (RW)
 *
 * MOD, CNTIN, and CV registers synchronization is activated by the software
 * trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate MOD, CNTIN, and CV registers
 *     synchronization.
 * - 1 - The software trigger activates MOD, CNTIN, and CV registers
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWWRBUF field. */
#define FTM_RD_SYNCONF_SWWRBUF(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWWRBUF_MASK) >> FTM_SYNCONF_SWWRBUF_SHIFT)
#define FTM_BRD_SYNCONF_SWWRBUF(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWWRBUF_SHIFT, FTM_SYNCONF_SWWRBUF_WIDTH))

/*! @brief Set the SWWRBUF field to a new value. */
#define FTM_WR_SYNCONF_SWWRBUF(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWWRBUF_MASK, FTM_SYNCONF_SWWRBUF(value)))
#define FTM_BWR_SYNCONF_SWWRBUF(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SWWRBUF_SHIFT), FTM_SYNCONF_SWWRBUF_SHIFT, FTM_SYNCONF_SWWRBUF_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWOM[10] (RW)
 *
 * Output mask synchronization is activated by the software trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate the OUTMASK register
 *     synchronization.
 * - 1 - The software trigger activates the OUTMASK register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWOM field. */
#define FTM_RD_SYNCONF_SWOM(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWOM_MASK) >> FTM_SYNCONF_SWOM_SHIFT)
#define FTM_BRD_SYNCONF_SWOM(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWOM_SHIFT, FTM_SYNCONF_SWOM_WIDTH))

/*! @brief Set the SWOM field to a new value. */
#define FTM_WR_SYNCONF_SWOM(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWOM_MASK, FTM_SYNCONF_SWOM(value)))
#define FTM_BWR_SYNCONF_SWOM(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SWOM_SHIFT), FTM_SYNCONF_SWOM_SHIFT, FTM_SYNCONF_SWOM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWINVC[11] (RW)
 *
 * Inverting control synchronization is activated by the software trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate the INVCTRL register
 *     synchronization.
 * - 1 - The software trigger activates the INVCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWINVC field. */
#define FTM_RD_SYNCONF_SWINVC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWINVC_MASK) >> FTM_SYNCONF_SWINVC_SHIFT)
#define FTM_BRD_SYNCONF_SWINVC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWINVC_SHIFT, FTM_SYNCONF_SWINVC_WIDTH))

/*! @brief Set the SWINVC field to a new value. */
#define FTM_WR_SYNCONF_SWINVC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWINVC_MASK, FTM_SYNCONF_SWINVC(value)))
#define FTM_BWR_SYNCONF_SWINVC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SWINVC_SHIFT), FTM_SYNCONF_SWINVC_SHIFT, FTM_SYNCONF_SWINVC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWSOC[12] (RW)
 *
 * Software output control synchronization is activated by the software trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate the SWOCTRL register
 *     synchronization.
 * - 1 - The software trigger activates the SWOCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWSOC field. */
#define FTM_RD_SYNCONF_SWSOC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWSOC_MASK) >> FTM_SYNCONF_SWSOC_SHIFT)
#define FTM_BRD_SYNCONF_SWSOC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWSOC_SHIFT, FTM_SYNCONF_SWSOC_WIDTH))

/*! @brief Set the SWSOC field to a new value. */
#define FTM_WR_SYNCONF_SWSOC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWSOC_MASK, FTM_SYNCONF_SWSOC(value)))
#define FTM_BWR_SYNCONF_SWSOC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SWSOC_SHIFT), FTM_SYNCONF_SWSOC_SHIFT, FTM_SYNCONF_SWSOC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWRSTCNT[16] (RW)
 *
 * FTM counter synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate the FTM counter synchronization.
 * - 1 - A hardware trigger activates the FTM counter synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWRSTCNT field. */
#define FTM_RD_SYNCONF_HWRSTCNT(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWRSTCNT_MASK) >> FTM_SYNCONF_HWRSTCNT_SHIFT)
#define FTM_BRD_SYNCONF_HWRSTCNT(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWRSTCNT_SHIFT, FTM_SYNCONF_HWRSTCNT_WIDTH))

/*! @brief Set the HWRSTCNT field to a new value. */
#define FTM_WR_SYNCONF_HWRSTCNT(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWRSTCNT_MASK, FTM_SYNCONF_HWRSTCNT(value)))
#define FTM_BWR_SYNCONF_HWRSTCNT(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_HWRSTCNT_SHIFT), FTM_SYNCONF_HWRSTCNT_SHIFT, FTM_SYNCONF_HWRSTCNT_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWWRBUF[17] (RW)
 *
 * MOD, CNTIN, and CV registers synchronization is activated by a hardware
 * trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate MOD, CNTIN, and CV registers
 *     synchronization.
 * - 1 - A hardware trigger activates MOD, CNTIN, and CV registers
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWWRBUF field. */
#define FTM_RD_SYNCONF_HWWRBUF(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWWRBUF_MASK) >> FTM_SYNCONF_HWWRBUF_SHIFT)
#define FTM_BRD_SYNCONF_HWWRBUF(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWWRBUF_SHIFT, FTM_SYNCONF_HWWRBUF_WIDTH))

/*! @brief Set the HWWRBUF field to a new value. */
#define FTM_WR_SYNCONF_HWWRBUF(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWWRBUF_MASK, FTM_SYNCONF_HWWRBUF(value)))
#define FTM_BWR_SYNCONF_HWWRBUF(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_HWWRBUF_SHIFT), FTM_SYNCONF_HWWRBUF_SHIFT, FTM_SYNCONF_HWWRBUF_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWOM[18] (RW)
 *
 * Output mask synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate the OUTMASK register
 *     synchronization.
 * - 1 - A hardware trigger activates the OUTMASK register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWOM field. */
#define FTM_RD_SYNCONF_HWOM(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWOM_MASK) >> FTM_SYNCONF_HWOM_SHIFT)
#define FTM_BRD_SYNCONF_HWOM(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWOM_SHIFT, FTM_SYNCONF_HWOM_WIDTH))

/*! @brief Set the HWOM field to a new value. */
#define FTM_WR_SYNCONF_HWOM(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWOM_MASK, FTM_SYNCONF_HWOM(value)))
#define FTM_BWR_SYNCONF_HWOM(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_HWOM_SHIFT), FTM_SYNCONF_HWOM_SHIFT, FTM_SYNCONF_HWOM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWINVC[19] (RW)
 *
 * Inverting control synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate the INVCTRL register
 *     synchronization.
 * - 1 - A hardware trigger activates the INVCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWINVC field. */
#define FTM_RD_SYNCONF_HWINVC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWINVC_MASK) >> FTM_SYNCONF_HWINVC_SHIFT)
#define FTM_BRD_SYNCONF_HWINVC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWINVC_SHIFT, FTM_SYNCONF_HWINVC_WIDTH))

/*! @brief Set the HWINVC field to a new value. */
#define FTM_WR_SYNCONF_HWINVC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWINVC_MASK, FTM_SYNCONF_HWINVC(value)))
#define FTM_BWR_SYNCONF_HWINVC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_HWINVC_SHIFT), FTM_SYNCONF_HWINVC_SHIFT, FTM_SYNCONF_HWINVC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWSOC[20] (RW)
 *
 * Software output control synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate the SWOCTRL register
 *     synchronization.
 * - 1 - A hardware trigger activates the SWOCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWSOC field. */
#define FTM_RD_SYNCONF_HWSOC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWSOC_MASK) >> FTM_SYNCONF_HWSOC_SHIFT)
#define FTM_BRD_SYNCONF_HWSOC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWSOC_SHIFT, FTM_SYNCONF_HWSOC_WIDTH))

/*! @brief Set the HWSOC field to a new value. */
#define FTM_WR_SYNCONF_HWSOC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWSOC_MASK, FTM_SYNCONF_HWSOC(value)))
#define FTM_BWR_SYNCONF_HWSOC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_HWSOC_SHIFT), FTM_SYNCONF_HWSOC_SHIFT, FTM_SYNCONF_HWSOC_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_INVCTRL - FTM Inverting Control
 ******************************************************************************/

/*!
 * @brief FTM_INVCTRL - FTM Inverting Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls when the channel (n) output becomes the channel (n+1)
 * output, and channel (n+1) output becomes the channel (n) output. Each INVmEN
 * bit enables the inverting operation for the corresponding pair channels m. This
 * register has a write buffer. The INVmEN bit is updated by the INVCTRL
 * register synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_INVCTRL register
 */
/*@{*/
#define FTM_RD_INVCTRL(base)     (FTM_INVCTRL_REG(base))
#define FTM_WR_INVCTRL(base, value) (FTM_INVCTRL_REG(base) = (value))
#define FTM_RMW_INVCTRL(base, mask, value) (FTM_WR_INVCTRL(base, (FTM_RD_INVCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_INVCTRL(base, value) (BME_OR32(&FTM_INVCTRL_REG(base), (uint32_t)(value)))
#define FTM_CLR_INVCTRL(base, value) (BME_AND32(&FTM_INVCTRL_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_INVCTRL(base, value) (BME_XOR32(&FTM_INVCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_INVCTRL bitfields
 */

/*!
 * @name Register FTM_INVCTRL, field INV0EN[0] (RW)
 *
 * Values:
 * - 0 - Inverting is disabled.
 * - 1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV0EN field. */
#define FTM_RD_INVCTRL_INV0EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV0EN_MASK) >> FTM_INVCTRL_INV0EN_SHIFT)
#define FTM_BRD_INVCTRL_INV0EN(base) (BME_UBFX32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV0EN_SHIFT, FTM_INVCTRL_INV0EN_WIDTH))

/*! @brief Set the INV0EN field to a new value. */
#define FTM_WR_INVCTRL_INV0EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV0EN_MASK, FTM_INVCTRL_INV0EN(value)))
#define FTM_BWR_INVCTRL_INV0EN(base, value) (BME_BFI32(&FTM_INVCTRL_REG(base), ((uint32_t)(value) << FTM_INVCTRL_INV0EN_SHIFT), FTM_INVCTRL_INV0EN_SHIFT, FTM_INVCTRL_INV0EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV1EN[1] (RW)
 *
 * Values:
 * - 0 - Inverting is disabled.
 * - 1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV1EN field. */
#define FTM_RD_INVCTRL_INV1EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV1EN_MASK) >> FTM_INVCTRL_INV1EN_SHIFT)
#define FTM_BRD_INVCTRL_INV1EN(base) (BME_UBFX32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV1EN_SHIFT, FTM_INVCTRL_INV1EN_WIDTH))

/*! @brief Set the INV1EN field to a new value. */
#define FTM_WR_INVCTRL_INV1EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV1EN_MASK, FTM_INVCTRL_INV1EN(value)))
#define FTM_BWR_INVCTRL_INV1EN(base, value) (BME_BFI32(&FTM_INVCTRL_REG(base), ((uint32_t)(value) << FTM_INVCTRL_INV1EN_SHIFT), FTM_INVCTRL_INV1EN_SHIFT, FTM_INVCTRL_INV1EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV2EN[2] (RW)
 *
 * Values:
 * - 0 - Inverting is disabled.
 * - 1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV2EN field. */
#define FTM_RD_INVCTRL_INV2EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV2EN_MASK) >> FTM_INVCTRL_INV2EN_SHIFT)
#define FTM_BRD_INVCTRL_INV2EN(base) (BME_UBFX32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV2EN_SHIFT, FTM_INVCTRL_INV2EN_WIDTH))

/*! @brief Set the INV2EN field to a new value. */
#define FTM_WR_INVCTRL_INV2EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV2EN_MASK, FTM_INVCTRL_INV2EN(value)))
#define FTM_BWR_INVCTRL_INV2EN(base, value) (BME_BFI32(&FTM_INVCTRL_REG(base), ((uint32_t)(value) << FTM_INVCTRL_INV2EN_SHIFT), FTM_INVCTRL_INV2EN_SHIFT, FTM_INVCTRL_INV2EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV3EN[3] (RW)
 *
 * Values:
 * - 0 - Inverting is disabled.
 * - 1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV3EN field. */
#define FTM_RD_INVCTRL_INV3EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV3EN_MASK) >> FTM_INVCTRL_INV3EN_SHIFT)
#define FTM_BRD_INVCTRL_INV3EN(base) (BME_UBFX32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV3EN_SHIFT, FTM_INVCTRL_INV3EN_WIDTH))

/*! @brief Set the INV3EN field to a new value. */
#define FTM_WR_INVCTRL_INV3EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV3EN_MASK, FTM_INVCTRL_INV3EN(value)))
#define FTM_BWR_INVCTRL_INV3EN(base, value) (BME_BFI32(&FTM_INVCTRL_REG(base), ((uint32_t)(value) << FTM_INVCTRL_INV3EN_SHIFT), FTM_INVCTRL_INV3EN_SHIFT, FTM_INVCTRL_INV3EN_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_SWOCTRL - FTM Software Output Control
 ******************************************************************************/

/*!
 * @brief FTM_SWOCTRL - FTM Software Output Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register enables software control of channel (n) output and defines the
 * value forced to the channel (n) output: The CHnOC bits enable the control of
 * the corresponding channel (n) output by software. The CHnOCV bits select the
 * value that is forced at the corresponding channel (n) output. This register has
 * a write buffer. The fields are updated by the SWOCTRL register synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_SWOCTRL register
 */
/*@{*/
#define FTM_RD_SWOCTRL(base)     (FTM_SWOCTRL_REG(base))
#define FTM_WR_SWOCTRL(base, value) (FTM_SWOCTRL_REG(base) = (value))
#define FTM_RMW_SWOCTRL(base, mask, value) (FTM_WR_SWOCTRL(base, (FTM_RD_SWOCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_SWOCTRL(base, value) (BME_OR32(&FTM_SWOCTRL_REG(base), (uint32_t)(value)))
#define FTM_CLR_SWOCTRL(base, value) (BME_AND32(&FTM_SWOCTRL_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_SWOCTRL(base, value) (BME_XOR32(&FTM_SWOCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SWOCTRL bitfields
 */

/*!
 * @name Register FTM_SWOCTRL, field CH0OC[0] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH0OC field. */
#define FTM_RD_SWOCTRL_CH0OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH0OC_MASK) >> FTM_SWOCTRL_CH0OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH0OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH0OC_SHIFT, FTM_SWOCTRL_CH0OC_WIDTH))

/*! @brief Set the CH0OC field to a new value. */
#define FTM_WR_SWOCTRL_CH0OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH0OC_MASK, FTM_SWOCTRL_CH0OC(value)))
#define FTM_BWR_SWOCTRL_CH0OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH0OC_SHIFT), FTM_SWOCTRL_CH0OC_SHIFT, FTM_SWOCTRL_CH0OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH1OC[1] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH1OC field. */
#define FTM_RD_SWOCTRL_CH1OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH1OC_MASK) >> FTM_SWOCTRL_CH1OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH1OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH1OC_SHIFT, FTM_SWOCTRL_CH1OC_WIDTH))

/*! @brief Set the CH1OC field to a new value. */
#define FTM_WR_SWOCTRL_CH1OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH1OC_MASK, FTM_SWOCTRL_CH1OC(value)))
#define FTM_BWR_SWOCTRL_CH1OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH1OC_SHIFT), FTM_SWOCTRL_CH1OC_SHIFT, FTM_SWOCTRL_CH1OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH2OC[2] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH2OC field. */
#define FTM_RD_SWOCTRL_CH2OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH2OC_MASK) >> FTM_SWOCTRL_CH2OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH2OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH2OC_SHIFT, FTM_SWOCTRL_CH2OC_WIDTH))

/*! @brief Set the CH2OC field to a new value. */
#define FTM_WR_SWOCTRL_CH2OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH2OC_MASK, FTM_SWOCTRL_CH2OC(value)))
#define FTM_BWR_SWOCTRL_CH2OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH2OC_SHIFT), FTM_SWOCTRL_CH2OC_SHIFT, FTM_SWOCTRL_CH2OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH3OC[3] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH3OC field. */
#define FTM_RD_SWOCTRL_CH3OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH3OC_MASK) >> FTM_SWOCTRL_CH3OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH3OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH3OC_SHIFT, FTM_SWOCTRL_CH3OC_WIDTH))

/*! @brief Set the CH3OC field to a new value. */
#define FTM_WR_SWOCTRL_CH3OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH3OC_MASK, FTM_SWOCTRL_CH3OC(value)))
#define FTM_BWR_SWOCTRL_CH3OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH3OC_SHIFT), FTM_SWOCTRL_CH3OC_SHIFT, FTM_SWOCTRL_CH3OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH4OC[4] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH4OC field. */
#define FTM_RD_SWOCTRL_CH4OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH4OC_MASK) >> FTM_SWOCTRL_CH4OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH4OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH4OC_SHIFT, FTM_SWOCTRL_CH4OC_WIDTH))

/*! @brief Set the CH4OC field to a new value. */
#define FTM_WR_SWOCTRL_CH4OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH4OC_MASK, FTM_SWOCTRL_CH4OC(value)))
#define FTM_BWR_SWOCTRL_CH4OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH4OC_SHIFT), FTM_SWOCTRL_CH4OC_SHIFT, FTM_SWOCTRL_CH4OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH5OC[5] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH5OC field. */
#define FTM_RD_SWOCTRL_CH5OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH5OC_MASK) >> FTM_SWOCTRL_CH5OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH5OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH5OC_SHIFT, FTM_SWOCTRL_CH5OC_WIDTH))

/*! @brief Set the CH5OC field to a new value. */
#define FTM_WR_SWOCTRL_CH5OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH5OC_MASK, FTM_SWOCTRL_CH5OC(value)))
#define FTM_BWR_SWOCTRL_CH5OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH5OC_SHIFT), FTM_SWOCTRL_CH5OC_SHIFT, FTM_SWOCTRL_CH5OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH6OC[6] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH6OC field. */
#define FTM_RD_SWOCTRL_CH6OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH6OC_MASK) >> FTM_SWOCTRL_CH6OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH6OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH6OC_SHIFT, FTM_SWOCTRL_CH6OC_WIDTH))

/*! @brief Set the CH6OC field to a new value. */
#define FTM_WR_SWOCTRL_CH6OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH6OC_MASK, FTM_SWOCTRL_CH6OC(value)))
#define FTM_BWR_SWOCTRL_CH6OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH6OC_SHIFT), FTM_SWOCTRL_CH6OC_SHIFT, FTM_SWOCTRL_CH6OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH7OC[7] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH7OC field. */
#define FTM_RD_SWOCTRL_CH7OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH7OC_MASK) >> FTM_SWOCTRL_CH7OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH7OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH7OC_SHIFT, FTM_SWOCTRL_CH7OC_WIDTH))

/*! @brief Set the CH7OC field to a new value. */
#define FTM_WR_SWOCTRL_CH7OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH7OC_MASK, FTM_SWOCTRL_CH7OC(value)))
#define FTM_BWR_SWOCTRL_CH7OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH7OC_SHIFT), FTM_SWOCTRL_CH7OC_SHIFT, FTM_SWOCTRL_CH7OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH0OCV[8] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH0OCV field. */
#define FTM_RD_SWOCTRL_CH0OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH0OCV_MASK) >> FTM_SWOCTRL_CH0OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH0OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH0OCV_SHIFT, FTM_SWOCTRL_CH0OCV_WIDTH))

/*! @brief Set the CH0OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH0OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH0OCV_MASK, FTM_SWOCTRL_CH0OCV(value)))
#define FTM_BWR_SWOCTRL_CH0OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH0OCV_SHIFT), FTM_SWOCTRL_CH0OCV_SHIFT, FTM_SWOCTRL_CH0OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH1OCV[9] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH1OCV field. */
#define FTM_RD_SWOCTRL_CH1OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH1OCV_MASK) >> FTM_SWOCTRL_CH1OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH1OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH1OCV_SHIFT, FTM_SWOCTRL_CH1OCV_WIDTH))

/*! @brief Set the CH1OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH1OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH1OCV_MASK, FTM_SWOCTRL_CH1OCV(value)))
#define FTM_BWR_SWOCTRL_CH1OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH1OCV_SHIFT), FTM_SWOCTRL_CH1OCV_SHIFT, FTM_SWOCTRL_CH1OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH2OCV[10] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH2OCV field. */
#define FTM_RD_SWOCTRL_CH2OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH2OCV_MASK) >> FTM_SWOCTRL_CH2OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH2OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH2OCV_SHIFT, FTM_SWOCTRL_CH2OCV_WIDTH))

/*! @brief Set the CH2OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH2OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH2OCV_MASK, FTM_SWOCTRL_CH2OCV(value)))
#define FTM_BWR_SWOCTRL_CH2OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH2OCV_SHIFT), FTM_SWOCTRL_CH2OCV_SHIFT, FTM_SWOCTRL_CH2OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH3OCV[11] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH3OCV field. */
#define FTM_RD_SWOCTRL_CH3OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH3OCV_MASK) >> FTM_SWOCTRL_CH3OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH3OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH3OCV_SHIFT, FTM_SWOCTRL_CH3OCV_WIDTH))

/*! @brief Set the CH3OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH3OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH3OCV_MASK, FTM_SWOCTRL_CH3OCV(value)))
#define FTM_BWR_SWOCTRL_CH3OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH3OCV_SHIFT), FTM_SWOCTRL_CH3OCV_SHIFT, FTM_SWOCTRL_CH3OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH4OCV[12] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH4OCV field. */
#define FTM_RD_SWOCTRL_CH4OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH4OCV_MASK) >> FTM_SWOCTRL_CH4OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH4OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH4OCV_SHIFT, FTM_SWOCTRL_CH4OCV_WIDTH))

/*! @brief Set the CH4OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH4OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH4OCV_MASK, FTM_SWOCTRL_CH4OCV(value)))
#define FTM_BWR_SWOCTRL_CH4OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH4OCV_SHIFT), FTM_SWOCTRL_CH4OCV_SHIFT, FTM_SWOCTRL_CH4OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH5OCV[13] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH5OCV field. */
#define FTM_RD_SWOCTRL_CH5OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH5OCV_MASK) >> FTM_SWOCTRL_CH5OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH5OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH5OCV_SHIFT, FTM_SWOCTRL_CH5OCV_WIDTH))

/*! @brief Set the CH5OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH5OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH5OCV_MASK, FTM_SWOCTRL_CH5OCV(value)))
#define FTM_BWR_SWOCTRL_CH5OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH5OCV_SHIFT), FTM_SWOCTRL_CH5OCV_SHIFT, FTM_SWOCTRL_CH5OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH6OCV[14] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH6OCV field. */
#define FTM_RD_SWOCTRL_CH6OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH6OCV_MASK) >> FTM_SWOCTRL_CH6OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH6OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH6OCV_SHIFT, FTM_SWOCTRL_CH6OCV_WIDTH))

/*! @brief Set the CH6OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH6OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH6OCV_MASK, FTM_SWOCTRL_CH6OCV(value)))
#define FTM_BWR_SWOCTRL_CH6OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH6OCV_SHIFT), FTM_SWOCTRL_CH6OCV_SHIFT, FTM_SWOCTRL_CH6OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH7OCV[15] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH7OCV field. */
#define FTM_RD_SWOCTRL_CH7OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH7OCV_MASK) >> FTM_SWOCTRL_CH7OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH7OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH7OCV_SHIFT, FTM_SWOCTRL_CH7OCV_WIDTH))

/*! @brief Set the CH7OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH7OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH7OCV_MASK, FTM_SWOCTRL_CH7OCV(value)))
#define FTM_BWR_SWOCTRL_CH7OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH7OCV_SHIFT), FTM_SWOCTRL_CH7OCV_SHIFT, FTM_SWOCTRL_CH7OCV_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_PWMLOAD - FTM PWM Load
 ******************************************************************************/

/*!
 * @brief FTM_PWMLOAD - FTM PWM Load (RW)
 *
 * Reset value: 0x00000000U
 *
 * Enables the loading of the MOD, CNTIN, C(n)V, and C(n+1)V registers with the
 * values of their write buffers when the FTM counter changes from the MOD
 * register value to its next value or when a channel (j) match occurs. A match occurs
 * for the channel (j) when FTM counter = C(j)V.
 */
/*!
 * @name Constants and macros for entire FTM_PWMLOAD register
 */
/*@{*/
#define FTM_RD_PWMLOAD(base)     (FTM_PWMLOAD_REG(base))
#define FTM_WR_PWMLOAD(base, value) (FTM_PWMLOAD_REG(base) = (value))
#define FTM_RMW_PWMLOAD(base, mask, value) (FTM_WR_PWMLOAD(base, (FTM_RD_PWMLOAD(base) & ~(mask)) | (value)))
#define FTM_SET_PWMLOAD(base, value) (BME_OR32(&FTM_PWMLOAD_REG(base), (uint32_t)(value)))
#define FTM_CLR_PWMLOAD(base, value) (BME_AND32(&FTM_PWMLOAD_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_PWMLOAD(base, value) (BME_XOR32(&FTM_PWMLOAD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_PWMLOAD bitfields
 */

/*!
 * @name Register FTM_PWMLOAD, field CH0SEL[0] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH0SEL field. */
#define FTM_RD_PWMLOAD_CH0SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH0SEL_MASK) >> FTM_PWMLOAD_CH0SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH0SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH0SEL_SHIFT, FTM_PWMLOAD_CH0SEL_WIDTH))

/*! @brief Set the CH0SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH0SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH0SEL_MASK, FTM_PWMLOAD_CH0SEL(value)))
#define FTM_BWR_PWMLOAD_CH0SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH0SEL_SHIFT), FTM_PWMLOAD_CH0SEL_SHIFT, FTM_PWMLOAD_CH0SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH1SEL[1] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH1SEL field. */
#define FTM_RD_PWMLOAD_CH1SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH1SEL_MASK) >> FTM_PWMLOAD_CH1SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH1SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH1SEL_SHIFT, FTM_PWMLOAD_CH1SEL_WIDTH))

/*! @brief Set the CH1SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH1SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH1SEL_MASK, FTM_PWMLOAD_CH1SEL(value)))
#define FTM_BWR_PWMLOAD_CH1SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH1SEL_SHIFT), FTM_PWMLOAD_CH1SEL_SHIFT, FTM_PWMLOAD_CH1SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH2SEL[2] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH2SEL field. */
#define FTM_RD_PWMLOAD_CH2SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH2SEL_MASK) >> FTM_PWMLOAD_CH2SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH2SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH2SEL_SHIFT, FTM_PWMLOAD_CH2SEL_WIDTH))

/*! @brief Set the CH2SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH2SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH2SEL_MASK, FTM_PWMLOAD_CH2SEL(value)))
#define FTM_BWR_PWMLOAD_CH2SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH2SEL_SHIFT), FTM_PWMLOAD_CH2SEL_SHIFT, FTM_PWMLOAD_CH2SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH3SEL[3] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH3SEL field. */
#define FTM_RD_PWMLOAD_CH3SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH3SEL_MASK) >> FTM_PWMLOAD_CH3SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH3SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH3SEL_SHIFT, FTM_PWMLOAD_CH3SEL_WIDTH))

/*! @brief Set the CH3SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH3SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH3SEL_MASK, FTM_PWMLOAD_CH3SEL(value)))
#define FTM_BWR_PWMLOAD_CH3SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH3SEL_SHIFT), FTM_PWMLOAD_CH3SEL_SHIFT, FTM_PWMLOAD_CH3SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH4SEL[4] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH4SEL field. */
#define FTM_RD_PWMLOAD_CH4SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH4SEL_MASK) >> FTM_PWMLOAD_CH4SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH4SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH4SEL_SHIFT, FTM_PWMLOAD_CH4SEL_WIDTH))

/*! @brief Set the CH4SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH4SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH4SEL_MASK, FTM_PWMLOAD_CH4SEL(value)))
#define FTM_BWR_PWMLOAD_CH4SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH4SEL_SHIFT), FTM_PWMLOAD_CH4SEL_SHIFT, FTM_PWMLOAD_CH4SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH5SEL[5] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH5SEL field. */
#define FTM_RD_PWMLOAD_CH5SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH5SEL_MASK) >> FTM_PWMLOAD_CH5SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH5SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH5SEL_SHIFT, FTM_PWMLOAD_CH5SEL_WIDTH))

/*! @brief Set the CH5SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH5SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH5SEL_MASK, FTM_PWMLOAD_CH5SEL(value)))
#define FTM_BWR_PWMLOAD_CH5SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH5SEL_SHIFT), FTM_PWMLOAD_CH5SEL_SHIFT, FTM_PWMLOAD_CH5SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH6SEL[6] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH6SEL field. */
#define FTM_RD_PWMLOAD_CH6SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH6SEL_MASK) >> FTM_PWMLOAD_CH6SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH6SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH6SEL_SHIFT, FTM_PWMLOAD_CH6SEL_WIDTH))

/*! @brief Set the CH6SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH6SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH6SEL_MASK, FTM_PWMLOAD_CH6SEL(value)))
#define FTM_BWR_PWMLOAD_CH6SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH6SEL_SHIFT), FTM_PWMLOAD_CH6SEL_SHIFT, FTM_PWMLOAD_CH6SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH7SEL[7] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH7SEL field. */
#define FTM_RD_PWMLOAD_CH7SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH7SEL_MASK) >> FTM_PWMLOAD_CH7SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH7SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH7SEL_SHIFT, FTM_PWMLOAD_CH7SEL_WIDTH))

/*! @brief Set the CH7SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH7SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH7SEL_MASK, FTM_PWMLOAD_CH7SEL(value)))
#define FTM_BWR_PWMLOAD_CH7SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH7SEL_SHIFT), FTM_PWMLOAD_CH7SEL_SHIFT, FTM_PWMLOAD_CH7SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field LDOK[9] (RW)
 *
 * Enables the loading of the MOD, CNTIN, and CV registers with the values of
 * their write buffers.
 *
 * Values:
 * - 0 - Loading updated values is disabled.
 * - 1 - Loading updated values is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_LDOK field. */
#define FTM_RD_PWMLOAD_LDOK(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_LDOK_MASK) >> FTM_PWMLOAD_LDOK_SHIFT)
#define FTM_BRD_PWMLOAD_LDOK(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_LDOK_SHIFT, FTM_PWMLOAD_LDOK_WIDTH))

/*! @brief Set the LDOK field to a new value. */
#define FTM_WR_PWMLOAD_LDOK(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_LDOK_MASK, FTM_PWMLOAD_LDOK(value)))
#define FTM_BWR_PWMLOAD_LDOK(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_LDOK_SHIFT), FTM_PWMLOAD_LDOK_SHIFT, FTM_PWMLOAD_LDOK_WIDTH))
/*@}*/

/*
 * MKV10Z7 GPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - GPIO_PDOR - Port Data Output Register
 * - GPIO_PSOR - Port Set Output Register
 * - GPIO_PCOR - Port Clear Output Register
 * - GPIO_PTOR - Port Toggle Output Register
 * - GPIO_PDIR - Port Data Input Register
 * - GPIO_PDDR - Port Data Direction Register
 */

#define GPIO_INSTANCE_COUNT (5U) /*!< Number of instances of the GPIO module. */
#define GPIOA_IDX (0U) /*!< Instance number for GPIOA. */
#define GPIOB_IDX (1U) /*!< Instance number for GPIOB. */
#define GPIOC_IDX (2U) /*!< Instance number for GPIOC. */
#define GPIOD_IDX (3U) /*!< Instance number for GPIOD. */
#define GPIOE_IDX (4U) /*!< Instance number for GPIOE. */

/*******************************************************************************
 * GPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the logic levels that are driven on each
 * general-purpose output pins. Do not modify pin configuration registers associated with
 * pins not available in your selected package. All unbonded pins not available in
 * your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDOR register
 */
/*@{*/
#define GPIO_RD_PDOR(base)       (GPIO_PDOR_REG(base))
#define GPIO_WR_PDOR(base, value) (GPIO_PDOR_REG(base) = (value))
#define GPIO_RMW_PDOR(base, mask, value) (GPIO_WR_PDOR(base, (GPIO_RD_PDOR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDOR(base, value) (BME_OR32(&GPIO_PDOR_REG(base), (uint32_t)(value)))
#define GPIO_CLR_PDOR(base, value) (BME_AND32(&GPIO_PDOR_REG(base), (uint32_t)(~(value))))
#define GPIO_TOG_PDOR(base, value) (BME_XOR32(&GPIO_PDOR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * GPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to set the fields of the PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PSOR register
 */
/*@{*/
#define GPIO_RD_PSOR(base)       (GPIO_PSOR_REG(base))
#define GPIO_WR_PSOR(base, value) (GPIO_PSOR_REG(base) = (value))
#define GPIO_RMW_PSOR(base, mask, value) (GPIO_WR_PSOR(base, (GPIO_RD_PSOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to clear the fields of PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PCOR register
 */
/*@{*/
#define GPIO_RD_PCOR(base)       (GPIO_PCOR_REG(base))
#define GPIO_WR_PCOR(base, value) (GPIO_PCOR_REG(base) = (value))
#define GPIO_RMW_PCOR(base, mask, value) (GPIO_WR_PCOR(base, (GPIO_RD_PCOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire GPIO_PTOR register
 */
/*@{*/
#define GPIO_RD_PTOR(base)       (GPIO_PTOR_REG(base))
#define GPIO_WR_PTOR(base, value) (GPIO_PTOR_REG(base) = (value))
#define GPIO_RMW_PTOR(base, mask, value) (GPIO_WR_PTOR(base, (GPIO_RD_PTOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Do not modify pin configuration registers associated with pins not available
 * in your selected package. All unbonded pins not available in your package will
 * default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDIR register
 */
/*@{*/
#define GPIO_RD_PDIR(base)       (GPIO_PDIR_REG(base))
/*@}*/

/*******************************************************************************
 * GPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDDR configures the individual port pins for input or output.
 */
/*!
 * @name Constants and macros for entire GPIO_PDDR register
 */
/*@{*/
#define GPIO_RD_PDDR(base)       (GPIO_PDDR_REG(base))
#define GPIO_WR_PDDR(base, value) (GPIO_PDDR_REG(base) = (value))
#define GPIO_RMW_PDDR(base, mask, value) (GPIO_WR_PDDR(base, (GPIO_RD_PDDR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDDR(base, value) (BME_OR32(&GPIO_PDDR_REG(base), (uint32_t)(value)))
#define GPIO_CLR_PDDR(base, value) (BME_AND32(&GPIO_PDDR_REG(base), (uint32_t)(~(value))))
#define GPIO_TOG_PDDR(base, value) (BME_XOR32(&GPIO_PDDR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * MKV10Z7 I2C
 *
 * Inter-Integrated Circuit
 *
 * Registers defined in this header file:
 * - I2C_A1 - I2C Address Register 1
 * - I2C_F - I2C Frequency Divider register
 * - I2C_C1 - I2C Control Register 1
 * - I2C_S - I2C Status register
 * - I2C_D - I2C Data I/O register
 * - I2C_C2 - I2C Control Register 2
 * - I2C_FLT - I2C Programmable Input Glitch Filter Register
 * - I2C_RA - I2C Range Address register
 * - I2C_SMB - I2C SMBus Control and Status register
 * - I2C_A2 - I2C Address Register 2
 * - I2C_SLTH - I2C SCL Low Timeout Register High
 * - I2C_SLTL - I2C SCL Low Timeout Register Low
 */

#define I2C_INSTANCE_COUNT (1U) /*!< Number of instances of the I2C module. */
#define I2C0_IDX (0U) /*!< Instance number for I2C0. */

/*******************************************************************************
 * I2C_A1 - I2C Address Register 1
 ******************************************************************************/

/*!
 * @brief I2C_A1 - I2C Address Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the slave address to be used by the I2C module.
 */
/*!
 * @name Constants and macros for entire I2C_A1 register
 */
/*@{*/
#define I2C_RD_A1(base)          (I2C_A1_REG(base))
#define I2C_WR_A1(base, value)   (I2C_A1_REG(base) = (value))
#define I2C_RMW_A1(base, mask, value) (I2C_WR_A1(base, (I2C_RD_A1(base) & ~(mask)) | (value)))
#define I2C_SET_A1(base, value)  (BME_OR8(&I2C_A1_REG(base), (uint8_t)(value)))
#define I2C_CLR_A1(base, value)  (BME_AND8(&I2C_A1_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_A1(base, value)  (BME_XOR8(&I2C_A1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_A1 bitfields
 */

/*!
 * @name Register I2C_A1, field AD[7:1] (RW)
 *
 * Contains the primary slave address used by the I2C module when it is
 * addressed as a slave. This field is used in the 7-bit address scheme and the lower
 * seven bits in the 10-bit address scheme.
 */
/*@{*/
/*! @brief Read current value of the I2C_A1_AD field. */
#define I2C_RD_A1_AD(base)   ((I2C_A1_REG(base) & I2C_A1_AD_MASK) >> I2C_A1_AD_SHIFT)
#define I2C_BRD_A1_AD(base)  (BME_UBFX8(&I2C_A1_REG(base), I2C_A1_AD_SHIFT, I2C_A1_AD_WIDTH))

/*! @brief Set the AD field to a new value. */
#define I2C_WR_A1_AD(base, value) (I2C_RMW_A1(base, I2C_A1_AD_MASK, I2C_A1_AD(value)))
#define I2C_BWR_A1_AD(base, value) (BME_BFI8(&I2C_A1_REG(base), ((uint8_t)(value) << I2C_A1_AD_SHIFT), I2C_A1_AD_SHIFT, I2C_A1_AD_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_F - I2C Frequency Divider register
 ******************************************************************************/

/*!
 * @brief I2C_F - I2C Frequency Divider register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_F register
 */
/*@{*/
#define I2C_RD_F(base)           (I2C_F_REG(base))
#define I2C_WR_F(base, value)    (I2C_F_REG(base) = (value))
#define I2C_RMW_F(base, mask, value) (I2C_WR_F(base, (I2C_RD_F(base) & ~(mask)) | (value)))
#define I2C_SET_F(base, value)   (BME_OR8(&I2C_F_REG(base), (uint8_t)(value)))
#define I2C_CLR_F(base, value)   (BME_AND8(&I2C_F_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_F(base, value)   (BME_XOR8(&I2C_F_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_F bitfields
 */

/*!
 * @name Register I2C_F, field ICR[5:0] (RW)
 *
 * Prescales the I2C module clock for bit rate selection. This field and the
 * MULT field determine the I2C baud rate, the SDA hold time, the SCL start hold
 * time, and the SCL stop hold time. For a list of values corresponding to each ICR
 * setting, see I2C divider and hold values. The SCL divider multiplied by
 * multiplier factor (mul) determines the I2C baud rate. I2C baud rate = I2C module
 * clock speed (Hz)/(mul * SCL divider) The SDA hold time is the delay from the
 * falling edge of SCL (I2C clock) to the changing of SDA (I2C data). SDA hold time =
 * I2C module clock period (s) * mul * SDA hold value The SCL start hold time is
 * the delay from the falling edge of SDA (I2C data) while SCL is high (start
 * condition) to the falling edge of SCL (I2C clock). SCL start hold time = I2C
 * module clock period (s) * mul * SCL start hold value The SCL stop hold time is
 * the delay from the rising edge of SCL (I2C clock) to the rising edge of SDA (I2C
 * data) while SCL is high (stop condition). SCL stop hold time = I2C module
 * clock period (s) * mul * SCL stop hold value For example, if the I2C module clock
 * speed is 8 MHz, the following table shows the possible hold time values with
 * different ICR and MULT selections to achieve an I2C baud rate of 100 kbit/s.
 * MULT ICR Hold times (us) SDA SCL Start SCL Stop 2h 00h 3.500 3.000 5.500 1h 07h
 * 2.500 4.000 5.250 1h 0Bh 2.250 4.000 5.250 0h 14h 2.125 4.250 5.125 0h 18h
 * 1.125 4.750 5.125
 */
/*@{*/
/*! @brief Read current value of the I2C_F_ICR field. */
#define I2C_RD_F_ICR(base)   ((I2C_F_REG(base) & I2C_F_ICR_MASK) >> I2C_F_ICR_SHIFT)
#define I2C_BRD_F_ICR(base)  (BME_UBFX8(&I2C_F_REG(base), I2C_F_ICR_SHIFT, I2C_F_ICR_WIDTH))

/*! @brief Set the ICR field to a new value. */
#define I2C_WR_F_ICR(base, value) (I2C_RMW_F(base, I2C_F_ICR_MASK, I2C_F_ICR(value)))
#define I2C_BWR_F_ICR(base, value) (BME_BFI8(&I2C_F_REG(base), ((uint8_t)(value) << I2C_F_ICR_SHIFT), I2C_F_ICR_SHIFT, I2C_F_ICR_WIDTH))
/*@}*/

/*!
 * @name Register I2C_F, field MULT[7:6] (RW)
 *
 * Defines the multiplier factor (mul). This factor is used along with the SCL
 * divider to generate the I2C baud rate.
 *
 * Values:
 * - 00 - mul = 1
 * - 01 - mul = 2
 * - 10 - mul = 4
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the I2C_F_MULT field. */
#define I2C_RD_F_MULT(base)  ((I2C_F_REG(base) & I2C_F_MULT_MASK) >> I2C_F_MULT_SHIFT)
#define I2C_BRD_F_MULT(base) (BME_UBFX8(&I2C_F_REG(base), I2C_F_MULT_SHIFT, I2C_F_MULT_WIDTH))

/*! @brief Set the MULT field to a new value. */
#define I2C_WR_F_MULT(base, value) (I2C_RMW_F(base, I2C_F_MULT_MASK, I2C_F_MULT(value)))
#define I2C_BWR_F_MULT(base, value) (BME_BFI8(&I2C_F_REG(base), ((uint8_t)(value) << I2C_F_MULT_SHIFT), I2C_F_MULT_SHIFT, I2C_F_MULT_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_C1 - I2C Control Register 1
 ******************************************************************************/

/*!
 * @brief I2C_C1 - I2C Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_C1 register
 */
/*@{*/
#define I2C_RD_C1(base)          (I2C_C1_REG(base))
#define I2C_WR_C1(base, value)   (I2C_C1_REG(base) = (value))
#define I2C_RMW_C1(base, mask, value) (I2C_WR_C1(base, (I2C_RD_C1(base) & ~(mask)) | (value)))
#define I2C_SET_C1(base, value)  (BME_OR8(&I2C_C1_REG(base), (uint8_t)(value)))
#define I2C_CLR_C1(base, value)  (BME_AND8(&I2C_C1_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_C1(base, value)  (BME_XOR8(&I2C_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_C1 bitfields
 */

/*!
 * @name Register I2C_C1, field DMAEN[0] (RW)
 *
 * Enables or disables the DMA function.
 *
 * Values:
 * - 0 - All DMA signalling disabled.
 * - 1 - DMA transfer is enabled. While SMB[FACK] = 0, the following conditions
 *     trigger the DMA request: a data byte is received, and either address or
 *     data is transmitted. (ACK/NACK is automatic) the first byte received matches
 *     the A1 register or is a general call address. If any address matching
 *     occurs, S[IAAS] and S[TCF] are set. If the direction of transfer is known
 *     from master to slave, then it is not required to check S[SRW]. With this
 *     assumption, DMA can also be used in this case. In other cases, if the master
 *     reads data from the slave, then it is required to rewrite the C1 register
 *     operation. With this assumption, DMA cannot be used. When FACK = 1, an
 *     address or a data byte is transmitted.
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_DMAEN field. */
#define I2C_RD_C1_DMAEN(base) ((I2C_C1_REG(base) & I2C_C1_DMAEN_MASK) >> I2C_C1_DMAEN_SHIFT)
#define I2C_BRD_C1_DMAEN(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_DMAEN_SHIFT, I2C_C1_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define I2C_WR_C1_DMAEN(base, value) (I2C_RMW_C1(base, I2C_C1_DMAEN_MASK, I2C_C1_DMAEN(value)))
#define I2C_BWR_C1_DMAEN(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_DMAEN_SHIFT), I2C_C1_DMAEN_SHIFT, I2C_C1_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field WUEN[1] (RW)
 *
 * The I2C module can wake the MCU from low power mode with no peripheral bus
 * running when slave address matching occurs.
 *
 * Values:
 * - 0 - Normal operation. No interrupt generated when address matching in low
 *     power mode.
 * - 1 - Enables the wakeup function in low power mode.
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_WUEN field. */
#define I2C_RD_C1_WUEN(base) ((I2C_C1_REG(base) & I2C_C1_WUEN_MASK) >> I2C_C1_WUEN_SHIFT)
#define I2C_BRD_C1_WUEN(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_WUEN_SHIFT, I2C_C1_WUEN_WIDTH))

/*! @brief Set the WUEN field to a new value. */
#define I2C_WR_C1_WUEN(base, value) (I2C_RMW_C1(base, I2C_C1_WUEN_MASK, I2C_C1_WUEN(value)))
#define I2C_BWR_C1_WUEN(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_WUEN_SHIFT), I2C_C1_WUEN_SHIFT, I2C_C1_WUEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field RSTA[2] (WORZ)
 *
 * Writing 1 to this bit generates a repeated START condition provided it is the
 * current master. This bit will always be read as 0. Attempting a repeat at the
 * wrong time results in loss of arbitration.
 */
/*@{*/
/*! @brief Set the RSTA field to a new value. */
#define I2C_WR_C1_RSTA(base, value) (I2C_RMW_C1(base, I2C_C1_RSTA_MASK, I2C_C1_RSTA(value)))
#define I2C_BWR_C1_RSTA(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_RSTA_SHIFT), I2C_C1_RSTA_SHIFT, I2C_C1_RSTA_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field TXAK[3] (RW)
 *
 * Specifies the value driven onto the SDA during data acknowledge cycles for
 * both master and slave receivers. The value of SMB[FACK] affects NACK/ACK
 * generation. SCL is held low until TXAK is written.
 *
 * Values:
 * - 0 - An acknowledge signal is sent to the bus on the following receiving
 *     byte (if FACK is cleared) or the current receiving byte (if FACK is set).
 * - 1 - No acknowledge signal is sent to the bus on the following receiving
 *     data byte (if FACK is cleared) or the current receiving data byte (if FACK is
 *     set).
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_TXAK field. */
#define I2C_RD_C1_TXAK(base) ((I2C_C1_REG(base) & I2C_C1_TXAK_MASK) >> I2C_C1_TXAK_SHIFT)
#define I2C_BRD_C1_TXAK(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_TXAK_SHIFT, I2C_C1_TXAK_WIDTH))

/*! @brief Set the TXAK field to a new value. */
#define I2C_WR_C1_TXAK(base, value) (I2C_RMW_C1(base, I2C_C1_TXAK_MASK, I2C_C1_TXAK(value)))
#define I2C_BWR_C1_TXAK(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_TXAK_SHIFT), I2C_C1_TXAK_SHIFT, I2C_C1_TXAK_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field TX[4] (RW)
 *
 * Selects the direction of master and slave transfers. In master mode this bit
 * must be set according to the type of transfer required. Therefore, for address
 * cycles, this bit is always set. When addressed as a slave this bit must be
 * set by software according to the SRW bit in the status register.
 *
 * Values:
 * - 0 - Receive
 * - 1 - Transmit
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_TX field. */
#define I2C_RD_C1_TX(base)   ((I2C_C1_REG(base) & I2C_C1_TX_MASK) >> I2C_C1_TX_SHIFT)
#define I2C_BRD_C1_TX(base)  (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_TX_SHIFT, I2C_C1_TX_WIDTH))

/*! @brief Set the TX field to a new value. */
#define I2C_WR_C1_TX(base, value) (I2C_RMW_C1(base, I2C_C1_TX_MASK, I2C_C1_TX(value)))
#define I2C_BWR_C1_TX(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_TX_SHIFT), I2C_C1_TX_SHIFT, I2C_C1_TX_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field MST[5] (RW)
 *
 * When MST is changed from 0 to 1, a START signal is generated on the bus and
 * master mode is selected. When this bit changes from 1 to 0, a STOP signal is
 * generated and the mode of operation changes from master to slave.
 *
 * Values:
 * - 0 - Slave mode
 * - 1 - Master mode
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_MST field. */
#define I2C_RD_C1_MST(base)  ((I2C_C1_REG(base) & I2C_C1_MST_MASK) >> I2C_C1_MST_SHIFT)
#define I2C_BRD_C1_MST(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_MST_SHIFT, I2C_C1_MST_WIDTH))

/*! @brief Set the MST field to a new value. */
#define I2C_WR_C1_MST(base, value) (I2C_RMW_C1(base, I2C_C1_MST_MASK, I2C_C1_MST(value)))
#define I2C_BWR_C1_MST(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_MST_SHIFT), I2C_C1_MST_SHIFT, I2C_C1_MST_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field IICIE[6] (RW)
 *
 * Enables I2C interrupt requests.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_IICIE field. */
#define I2C_RD_C1_IICIE(base) ((I2C_C1_REG(base) & I2C_C1_IICIE_MASK) >> I2C_C1_IICIE_SHIFT)
#define I2C_BRD_C1_IICIE(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_IICIE_SHIFT, I2C_C1_IICIE_WIDTH))

/*! @brief Set the IICIE field to a new value. */
#define I2C_WR_C1_IICIE(base, value) (I2C_RMW_C1(base, I2C_C1_IICIE_MASK, I2C_C1_IICIE(value)))
#define I2C_BWR_C1_IICIE(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_IICIE_SHIFT), I2C_C1_IICIE_SHIFT, I2C_C1_IICIE_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field IICEN[7] (RW)
 *
 * Enables I2C module operation.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_IICEN field. */
#define I2C_RD_C1_IICEN(base) ((I2C_C1_REG(base) & I2C_C1_IICEN_MASK) >> I2C_C1_IICEN_SHIFT)
#define I2C_BRD_C1_IICEN(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_IICEN_SHIFT, I2C_C1_IICEN_WIDTH))

/*! @brief Set the IICEN field to a new value. */
#define I2C_WR_C1_IICEN(base, value) (I2C_RMW_C1(base, I2C_C1_IICEN_MASK, I2C_C1_IICEN(value)))
#define I2C_BWR_C1_IICEN(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_IICEN_SHIFT), I2C_C1_IICEN_SHIFT, I2C_C1_IICEN_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_S - I2C Status register
 ******************************************************************************/

/*!
 * @brief I2C_S - I2C Status register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire I2C_S register
 */
/*@{*/
#define I2C_RD_S(base)           (I2C_S_REG(base))
#define I2C_WR_S(base, value)    (I2C_S_REG(base) = (value))
#define I2C_RMW_S(base, mask, value) (I2C_WR_S(base, (I2C_RD_S(base) & ~(mask)) | (value)))
#define I2C_SET_S(base, value)   (BME_OR8(&I2C_S_REG(base), (uint8_t)(value)))
#define I2C_CLR_S(base, value)   (BME_AND8(&I2C_S_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_S(base, value)   (BME_XOR8(&I2C_S_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_S bitfields
 */

/*!
 * @name Register I2C_S, field RXAK[0] (RO)
 *
 * Values:
 * - 0 - Acknowledge signal was received after the completion of one byte of
 *     data transmission on the bus
 * - 1 - No acknowledge signal detected
 */
/*@{*/
/*! @brief Read current value of the I2C_S_RXAK field. */
#define I2C_RD_S_RXAK(base)  ((I2C_S_REG(base) & I2C_S_RXAK_MASK) >> I2C_S_RXAK_SHIFT)
#define I2C_BRD_S_RXAK(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_RXAK_SHIFT, I2C_S_RXAK_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field IICIF[1] (W1C)
 *
 * This bit sets when an interrupt is pending. This bit must be cleared by
 * software by writing 1 to it, such as in the interrupt routine. One of the following
 * events can set this bit: One byte transfer, including ACK/NACK bit, completes
 * if FACK is 0. An ACK or NACK is sent on the bus by writing 0 or 1 to TXAK
 * after this bit is set in receive mode. One byte transfer, excluding ACK/NACK bit,
 * completes if FACK is 1. Match of slave address to calling address including
 * primary slave address, range slave address , alert response address, second
 * slave address, or general call address. Arbitration lost In SMBus mode, any
 * timeouts except SCL and SDA high timeouts I2C bus stop or start detection if the
 * SSIE bit in the Input Glitch Filter register is 1 To clear the I2C bus stop or
 * start detection interrupt: In the interrupt service routine, first clear the
 * STOPF or STARTF bit in the Input Glitch Filter register by writing 1 to it, and
 * then clear the IICIF bit. If this sequence is reversed, the IICIF bit is
 * asserted again.
 *
 * Values:
 * - 0 - No interrupt pending
 * - 1 - Interrupt pending
 */
/*@{*/
/*! @brief Read current value of the I2C_S_IICIF field. */
#define I2C_RD_S_IICIF(base) ((I2C_S_REG(base) & I2C_S_IICIF_MASK) >> I2C_S_IICIF_SHIFT)
#define I2C_BRD_S_IICIF(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_IICIF_SHIFT, I2C_S_IICIF_WIDTH))

/*! @brief Set the IICIF field to a new value. */
#define I2C_WR_S_IICIF(base, value) (I2C_RMW_S(base, (I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_IICIF(value)))
#define I2C_BWR_S_IICIF(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_IICIF_SHIFT), I2C_S_IICIF_SHIFT, I2C_S_IICIF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field SRW[2] (RO)
 *
 * When addressed as a slave, SRW indicates the value of the R/W command bit of
 * the calling address sent to the master.
 *
 * Values:
 * - 0 - Slave receive, master writing to slave
 * - 1 - Slave transmit, master reading from slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_SRW field. */
#define I2C_RD_S_SRW(base)   ((I2C_S_REG(base) & I2C_S_SRW_MASK) >> I2C_S_SRW_SHIFT)
#define I2C_BRD_S_SRW(base)  (BME_UBFX8(&I2C_S_REG(base), I2C_S_SRW_SHIFT, I2C_S_SRW_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field RAM[3] (RW)
 *
 * This bit is set to 1 by any of the following conditions, if I2C_C2[RMEN] = 1:
 * Any nonzero calling address is received that matches the address in the RA
 * register. The calling address is within the range of values of the A1 and RA
 * registers. For the RAM bit to be set to 1 correctly, C1[IICIE] must be set to 1.
 * Writing the C1 register with any value clears this bit to 0.
 *
 * Values:
 * - 0 - Not addressed
 * - 1 - Addressed as a slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_RAM field. */
#define I2C_RD_S_RAM(base)   ((I2C_S_REG(base) & I2C_S_RAM_MASK) >> I2C_S_RAM_SHIFT)
#define I2C_BRD_S_RAM(base)  (BME_UBFX8(&I2C_S_REG(base), I2C_S_RAM_SHIFT, I2C_S_RAM_WIDTH))

/*! @brief Set the RAM field to a new value. */
#define I2C_WR_S_RAM(base, value) (I2C_RMW_S(base, (I2C_S_RAM_MASK | I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_RAM(value)))
#define I2C_BWR_S_RAM(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_RAM_SHIFT), I2C_S_RAM_SHIFT, I2C_S_RAM_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field ARBL[4] (W1C)
 *
 * This bit is set by hardware when the arbitration procedure is lost. The ARBL
 * bit must be cleared by software, by writing 1 to it.
 *
 * Values:
 * - 0 - Standard bus operation.
 * - 1 - Loss of arbitration.
 */
/*@{*/
/*! @brief Read current value of the I2C_S_ARBL field. */
#define I2C_RD_S_ARBL(base)  ((I2C_S_REG(base) & I2C_S_ARBL_MASK) >> I2C_S_ARBL_SHIFT)
#define I2C_BRD_S_ARBL(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_ARBL_SHIFT, I2C_S_ARBL_WIDTH))

/*! @brief Set the ARBL field to a new value. */
#define I2C_WR_S_ARBL(base, value) (I2C_RMW_S(base, (I2C_S_ARBL_MASK | I2C_S_IICIF_MASK), I2C_S_ARBL(value)))
#define I2C_BWR_S_ARBL(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_ARBL_SHIFT), I2C_S_ARBL_SHIFT, I2C_S_ARBL_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field BUSY[5] (RO)
 *
 * Indicates the status of the bus regardless of slave or master mode. This bit
 * is set when a START signal is detected and cleared when a STOP signal is
 * detected.
 *
 * Values:
 * - 0 - Bus is idle
 * - 1 - Bus is busy
 */
/*@{*/
/*! @brief Read current value of the I2C_S_BUSY field. */
#define I2C_RD_S_BUSY(base)  ((I2C_S_REG(base) & I2C_S_BUSY_MASK) >> I2C_S_BUSY_SHIFT)
#define I2C_BRD_S_BUSY(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_BUSY_SHIFT, I2C_S_BUSY_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field IAAS[6] (RW)
 *
 * This bit is set by one of the following conditions: The calling address
 * matches the programmed primary slave address in the A1 register, or matches the
 * range address in the RA register (which must be set to a nonzero value and under
 * the condition I2C_C2[RMEN] = 1). C2[GCAEN] is set and a general call is
 * received. SMB[SIICAEN] is set and the calling address matches the second programmed
 * slave address. ALERTEN is set and an SMBus alert response address is received
 * RMEN is set and an address is received that is within the range between the
 * values of the A1 and RA registers. IAAS sets before the ACK bit. The CPU must
 * check the SRW bit and set TX/RX accordingly. Writing the C1 register with any
 * value clears this bit.
 *
 * Values:
 * - 0 - Not addressed
 * - 1 - Addressed as a slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_IAAS field. */
#define I2C_RD_S_IAAS(base)  ((I2C_S_REG(base) & I2C_S_IAAS_MASK) >> I2C_S_IAAS_SHIFT)
#define I2C_BRD_S_IAAS(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_IAAS_SHIFT, I2C_S_IAAS_WIDTH))

/*! @brief Set the IAAS field to a new value. */
#define I2C_WR_S_IAAS(base, value) (I2C_RMW_S(base, (I2C_S_IAAS_MASK | I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_IAAS(value)))
#define I2C_BWR_S_IAAS(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_IAAS_SHIFT), I2C_S_IAAS_SHIFT, I2C_S_IAAS_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field TCF[7] (RO)
 *
 * Acknowledges a byte transfer; TCF is set on the completion of a byte
 * transfer. This bit is valid only during or immediately following a transfer to or from
 * the I2C module. TCF is cleared by reading the I2C data register in receive
 * mode or by writing to the I2C data register in transmit mode.
 *
 * Values:
 * - 0 - Transfer in progress
 * - 1 - Transfer complete
 */
/*@{*/
/*! @brief Read current value of the I2C_S_TCF field. */
#define I2C_RD_S_TCF(base)   ((I2C_S_REG(base) & I2C_S_TCF_MASK) >> I2C_S_TCF_SHIFT)
#define I2C_BRD_S_TCF(base)  (BME_UBFX8(&I2C_S_REG(base), I2C_S_TCF_SHIFT, I2C_S_TCF_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_D - I2C Data I/O register
 ******************************************************************************/

/*!
 * @brief I2C_D - I2C Data I/O register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_D register
 */
/*@{*/
#define I2C_RD_D(base)           (I2C_D_REG(base))
#define I2C_WR_D(base, value)    (I2C_D_REG(base) = (value))
#define I2C_RMW_D(base, mask, value) (I2C_WR_D(base, (I2C_RD_D(base) & ~(mask)) | (value)))
#define I2C_SET_D(base, value)   (BME_OR8(&I2C_D_REG(base), (uint8_t)(value)))
#define I2C_CLR_D(base, value)   (BME_AND8(&I2C_D_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_D(base, value)   (BME_XOR8(&I2C_D_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * I2C_C2 - I2C Control Register 2
 ******************************************************************************/

/*!
 * @brief I2C_C2 - I2C Control Register 2 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_C2 register
 */
/*@{*/
#define I2C_RD_C2(base)          (I2C_C2_REG(base))
#define I2C_WR_C2(base, value)   (I2C_C2_REG(base) = (value))
#define I2C_RMW_C2(base, mask, value) (I2C_WR_C2(base, (I2C_RD_C2(base) & ~(mask)) | (value)))
#define I2C_SET_C2(base, value)  (BME_OR8(&I2C_C2_REG(base), (uint8_t)(value)))
#define I2C_CLR_C2(base, value)  (BME_AND8(&I2C_C2_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_C2(base, value)  (BME_XOR8(&I2C_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_C2 bitfields
 */

/*!
 * @name Register I2C_C2, field AD[2:0] (RW)
 *
 * Contains the upper three bits of the slave address in the 10-bit address
 * scheme. This field is valid only while the ADEXT bit is set.
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_AD field. */
#define I2C_RD_C2_AD(base)   ((I2C_C2_REG(base) & I2C_C2_AD_MASK) >> I2C_C2_AD_SHIFT)
#define I2C_BRD_C2_AD(base)  (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_AD_SHIFT, I2C_C2_AD_WIDTH))

/*! @brief Set the AD field to a new value. */
#define I2C_WR_C2_AD(base, value) (I2C_RMW_C2(base, I2C_C2_AD_MASK, I2C_C2_AD(value)))
#define I2C_BWR_C2_AD(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_AD_SHIFT), I2C_C2_AD_SHIFT, I2C_C2_AD_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field RMEN[3] (RW)
 *
 * This bit controls the slave address matching for addresses between the values
 * of the A1 and RA registers. When this bit is set, a slave address matching
 * occurs for any address greater than the value of the A1 register and less than
 * or equal to the value of the RA register.
 *
 * Values:
 * - 0 - Range mode disabled. No address matching occurs for an address within
 *     the range of values of the A1 and RA registers.
 * - 1 - Range mode enabled. Address matching occurs when a slave receives an
 *     address within the range of values of the A1 and RA registers.
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_RMEN field. */
#define I2C_RD_C2_RMEN(base) ((I2C_C2_REG(base) & I2C_C2_RMEN_MASK) >> I2C_C2_RMEN_SHIFT)
#define I2C_BRD_C2_RMEN(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_RMEN_SHIFT, I2C_C2_RMEN_WIDTH))

/*! @brief Set the RMEN field to a new value. */
#define I2C_WR_C2_RMEN(base, value) (I2C_RMW_C2(base, I2C_C2_RMEN_MASK, I2C_C2_RMEN(value)))
#define I2C_BWR_C2_RMEN(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_RMEN_SHIFT), I2C_C2_RMEN_SHIFT, I2C_C2_RMEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field SBRC[4] (RW)
 *
 * Enables independent slave mode baud rate at maximum frequency, which forces
 * clock stretching on SCL in very fast I2C modes. To a slave, an example of a
 * "very fast" mode is when the master transfers at 40 kbit/s but the slave can
 * capture the master's data at only 10 kbit/s.
 *
 * Values:
 * - 0 - The slave baud rate follows the master baud rate and clock stretching
 *     may occur
 * - 1 - Slave baud rate is independent of the master baud rate
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_SBRC field. */
#define I2C_RD_C2_SBRC(base) ((I2C_C2_REG(base) & I2C_C2_SBRC_MASK) >> I2C_C2_SBRC_SHIFT)
#define I2C_BRD_C2_SBRC(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_SBRC_SHIFT, I2C_C2_SBRC_WIDTH))

/*! @brief Set the SBRC field to a new value. */
#define I2C_WR_C2_SBRC(base, value) (I2C_RMW_C2(base, I2C_C2_SBRC_MASK, I2C_C2_SBRC(value)))
#define I2C_BWR_C2_SBRC(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_SBRC_SHIFT), I2C_C2_SBRC_SHIFT, I2C_C2_SBRC_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field HDRS[5] (RW)
 *
 * Controls the drive capability of the I2C pads.
 *
 * Values:
 * - 0 - Normal drive mode
 * - 1 - High drive mode
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_HDRS field. */
#define I2C_RD_C2_HDRS(base) ((I2C_C2_REG(base) & I2C_C2_HDRS_MASK) >> I2C_C2_HDRS_SHIFT)
#define I2C_BRD_C2_HDRS(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_HDRS_SHIFT, I2C_C2_HDRS_WIDTH))

/*! @brief Set the HDRS field to a new value. */
#define I2C_WR_C2_HDRS(base, value) (I2C_RMW_C2(base, I2C_C2_HDRS_MASK, I2C_C2_HDRS(value)))
#define I2C_BWR_C2_HDRS(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_HDRS_SHIFT), I2C_C2_HDRS_SHIFT, I2C_C2_HDRS_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field ADEXT[6] (RW)
 *
 * Controls the number of bits used for the slave address.
 *
 * Values:
 * - 0 - 7-bit address scheme
 * - 1 - 10-bit address scheme
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_ADEXT field. */
#define I2C_RD_C2_ADEXT(base) ((I2C_C2_REG(base) & I2C_C2_ADEXT_MASK) >> I2C_C2_ADEXT_SHIFT)
#define I2C_BRD_C2_ADEXT(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_ADEXT_SHIFT, I2C_C2_ADEXT_WIDTH))

/*! @brief Set the ADEXT field to a new value. */
#define I2C_WR_C2_ADEXT(base, value) (I2C_RMW_C2(base, I2C_C2_ADEXT_MASK, I2C_C2_ADEXT(value)))
#define I2C_BWR_C2_ADEXT(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_ADEXT_SHIFT), I2C_C2_ADEXT_SHIFT, I2C_C2_ADEXT_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field GCAEN[7] (RW)
 *
 * Enables general call address.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_GCAEN field. */
#define I2C_RD_C2_GCAEN(base) ((I2C_C2_REG(base) & I2C_C2_GCAEN_MASK) >> I2C_C2_GCAEN_SHIFT)
#define I2C_BRD_C2_GCAEN(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_GCAEN_SHIFT, I2C_C2_GCAEN_WIDTH))

/*! @brief Set the GCAEN field to a new value. */
#define I2C_WR_C2_GCAEN(base, value) (I2C_RMW_C2(base, I2C_C2_GCAEN_MASK, I2C_C2_GCAEN(value)))
#define I2C_BWR_C2_GCAEN(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_GCAEN_SHIFT), I2C_C2_GCAEN_SHIFT, I2C_C2_GCAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_FLT - I2C Programmable Input Glitch Filter Register
 ******************************************************************************/

/*!
 * @brief I2C_FLT - I2C Programmable Input Glitch Filter Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_FLT register
 */
/*@{*/
#define I2C_RD_FLT(base)         (I2C_FLT_REG(base))
#define I2C_WR_FLT(base, value)  (I2C_FLT_REG(base) = (value))
#define I2C_RMW_FLT(base, mask, value) (I2C_WR_FLT(base, (I2C_RD_FLT(base) & ~(mask)) | (value)))
#define I2C_SET_FLT(base, value) (BME_OR8(&I2C_FLT_REG(base), (uint8_t)(value)))
#define I2C_CLR_FLT(base, value) (BME_AND8(&I2C_FLT_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_FLT(base, value) (BME_XOR8(&I2C_FLT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_FLT bitfields
 */

/*!
 * @name Register I2C_FLT, field FLT[3:0] (RW)
 *
 * Controls the width of the glitch, in terms of I2C module clock cycles, that
 * the filter must absorb. For any glitch whose size is less than or equal to this
 * width setting, the filter does not allow the glitch to pass.
 *
 * Values:
 * - 0 - No filter/bypass
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_FLT field. */
#define I2C_RD_FLT_FLT(base) ((I2C_FLT_REG(base) & I2C_FLT_FLT_MASK) >> I2C_FLT_FLT_SHIFT)
#define I2C_BRD_FLT_FLT(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_FLT_SHIFT, I2C_FLT_FLT_WIDTH))

/*! @brief Set the FLT field to a new value. */
#define I2C_WR_FLT_FLT(base, value) (I2C_RMW_FLT(base, (I2C_FLT_FLT_MASK | I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_FLT(value)))
#define I2C_BWR_FLT_FLT(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_FLT_SHIFT), I2C_FLT_FLT_SHIFT, I2C_FLT_FLT_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field STARTF[4] (W1C)
 *
 * Hardware sets this bit when the I2C bus's start status is detected. The
 * STARTF bit must be cleared by writing 1 to it.
 *
 * Values:
 * - 0 - No start happens on I2C bus
 * - 1 - Start detected on I2C bus
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_STARTF field. */
#define I2C_RD_FLT_STARTF(base) ((I2C_FLT_REG(base) & I2C_FLT_STARTF_MASK) >> I2C_FLT_STARTF_SHIFT)
#define I2C_BRD_FLT_STARTF(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_STARTF_SHIFT, I2C_FLT_STARTF_WIDTH))

/*! @brief Set the STARTF field to a new value. */
#define I2C_WR_FLT_STARTF(base, value) (I2C_RMW_FLT(base, (I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_STARTF(value)))
#define I2C_BWR_FLT_STARTF(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_STARTF_SHIFT), I2C_FLT_STARTF_SHIFT, I2C_FLT_STARTF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field SSIE[5] (RW)
 *
 * This bit enables the interrupt for I2C bus stop or start detection. To clear
 * the I2C bus stop or start detection interrupt: In the interrupt service
 * routine, first clear the STOPF or STARTF bit by writing 1 to it, and then clear the
 * IICIF bit in the status register. If this sequence is reversed, the IICIF bit
 * is asserted again.
 *
 * Values:
 * - 0 - Stop or start detection interrupt is disabled
 * - 1 - Stop or start detection interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_SSIE field. */
#define I2C_RD_FLT_SSIE(base) ((I2C_FLT_REG(base) & I2C_FLT_SSIE_MASK) >> I2C_FLT_SSIE_SHIFT)
#define I2C_BRD_FLT_SSIE(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_SSIE_SHIFT, I2C_FLT_SSIE_WIDTH))

/*! @brief Set the SSIE field to a new value. */
#define I2C_WR_FLT_SSIE(base, value) (I2C_RMW_FLT(base, (I2C_FLT_SSIE_MASK | I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_SSIE(value)))
#define I2C_BWR_FLT_SSIE(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_SSIE_SHIFT), I2C_FLT_SSIE_SHIFT, I2C_FLT_SSIE_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field STOPF[6] (W1C)
 *
 * Hardware sets this bit when the I2C bus's stop status is detected. The STOPF
 * bit must be cleared by writing 1 to it.
 *
 * Values:
 * - 0 - No stop happens on I2C bus
 * - 1 - Stop detected on I2C bus
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_STOPF field. */
#define I2C_RD_FLT_STOPF(base) ((I2C_FLT_REG(base) & I2C_FLT_STOPF_MASK) >> I2C_FLT_STOPF_SHIFT)
#define I2C_BRD_FLT_STOPF(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_STOPF_SHIFT, I2C_FLT_STOPF_WIDTH))

/*! @brief Set the STOPF field to a new value. */
#define I2C_WR_FLT_STOPF(base, value) (I2C_RMW_FLT(base, (I2C_FLT_STOPF_MASK | I2C_FLT_STARTF_MASK), I2C_FLT_STOPF(value)))
#define I2C_BWR_FLT_STOPF(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_STOPF_SHIFT), I2C_FLT_STOPF_SHIFT, I2C_FLT_STOPF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field SHEN[7] (RW)
 *
 * Set this bit to hold off entry to stop mode when any data transmission or
 * reception is occurring. The following scenario explains the holdoff
 * functionality: The I2C module is configured for a basic transfer, and the SHEN bit is set
 * to 1. A transfer begins. The MCU signals the I2C module to enter stop mode. The
 * byte currently being transferred, including both address and data, completes
 * its transfer. The I2C slave or master acknowledges that the in-transfer byte
 * completed its transfer and acknowledges the request to enter stop mode. After
 * receiving the I2C module's acknowledgment of the request to enter stop mode,
 * the MCU determines whether to shut off the I2C module's clock. If the SHEN bit
 * is set to 1 and the I2C module is in an idle or disabled state when the MCU
 * signals to enter stop mode, the module immediately acknowledges the request to
 * enter stop mode. If SHEN is cleared to 0 and the overall data transmission or
 * reception that was suspended by stop mode entry was incomplete: To resume the
 * overall transmission or reception after the MCU exits stop mode, software must
 * reinitialize the transfer by resending the address of the slave. If the I2C
 * Control Register 1's IICIE bit was set to 1 before the MCU entered stop mode,
 * system software will receive the interrupt triggered by the I2C Status Register's
 * TCF bit after the MCU wakes from the stop mode.
 *
 * Values:
 * - 0 - Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
 * - 1 - Stop holdoff is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_SHEN field. */
#define I2C_RD_FLT_SHEN(base) ((I2C_FLT_REG(base) & I2C_FLT_SHEN_MASK) >> I2C_FLT_SHEN_SHIFT)
#define I2C_BRD_FLT_SHEN(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_SHEN_SHIFT, I2C_FLT_SHEN_WIDTH))

/*! @brief Set the SHEN field to a new value. */
#define I2C_WR_FLT_SHEN(base, value) (I2C_RMW_FLT(base, (I2C_FLT_SHEN_MASK | I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_SHEN(value)))
#define I2C_BWR_FLT_SHEN(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_SHEN_SHIFT), I2C_FLT_SHEN_SHIFT, I2C_FLT_SHEN_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_RA - I2C Range Address register
 ******************************************************************************/

/*!
 * @brief I2C_RA - I2C Range Address register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_RA register
 */
/*@{*/
#define I2C_RD_RA(base)          (I2C_RA_REG(base))
#define I2C_WR_RA(base, value)   (I2C_RA_REG(base) = (value))
#define I2C_RMW_RA(base, mask, value) (I2C_WR_RA(base, (I2C_RD_RA(base) & ~(mask)) | (value)))
#define I2C_SET_RA(base, value)  (BME_OR8(&I2C_RA_REG(base), (uint8_t)(value)))
#define I2C_CLR_RA(base, value)  (BME_AND8(&I2C_RA_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_RA(base, value)  (BME_XOR8(&I2C_RA_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_RA bitfields
 */

/*!
 * @name Register I2C_RA, field RAD[7:1] (RW)
 *
 * This field contains the slave address to be used by the I2C module. The field
 * is used in the 7-bit address scheme. If I2C_C2[RMEN] is set to 1, any nonzero
 * value write enables this register. This register value can be considered as a
 * maximum boundary in the range matching mode.
 */
/*@{*/
/*! @brief Read current value of the I2C_RA_RAD field. */
#define I2C_RD_RA_RAD(base)  ((I2C_RA_REG(base) & I2C_RA_RAD_MASK) >> I2C_RA_RAD_SHIFT)
#define I2C_BRD_RA_RAD(base) (BME_UBFX8(&I2C_RA_REG(base), I2C_RA_RAD_SHIFT, I2C_RA_RAD_WIDTH))

/*! @brief Set the RAD field to a new value. */
#define I2C_WR_RA_RAD(base, value) (I2C_RMW_RA(base, I2C_RA_RAD_MASK, I2C_RA_RAD(value)))
#define I2C_BWR_RA_RAD(base, value) (BME_BFI8(&I2C_RA_REG(base), ((uint8_t)(value) << I2C_RA_RAD_SHIFT), I2C_RA_RAD_SHIFT, I2C_RA_RAD_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_SMB - I2C SMBus Control and Status register
 ******************************************************************************/

/*!
 * @brief I2C_SMB - I2C SMBus Control and Status register (RW)
 *
 * Reset value: 0x00U
 *
 * When the SCL and SDA signals are held high for a length of time greater than
 * the high timeout period, the SHTF1 flag sets. Before reaching this threshold,
 * while the system is detecting how long these signals are being held high, a
 * master assumes that the bus is free. However, the SHTF1 bit is set to 1 in the
 * bus transmission process with the idle bus state. When the TCKSEL bit is set,
 * there is no need to monitor the SHTF1 bit because the bus speed is too high to
 * match the protocol of SMBus.
 */
/*!
 * @name Constants and macros for entire I2C_SMB register
 */
/*@{*/
#define I2C_RD_SMB(base)         (I2C_SMB_REG(base))
#define I2C_WR_SMB(base, value)  (I2C_SMB_REG(base) = (value))
#define I2C_RMW_SMB(base, mask, value) (I2C_WR_SMB(base, (I2C_RD_SMB(base) & ~(mask)) | (value)))
#define I2C_SET_SMB(base, value) (BME_OR8(&I2C_SMB_REG(base), (uint8_t)(value)))
#define I2C_CLR_SMB(base, value) (BME_AND8(&I2C_SMB_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_SMB(base, value) (BME_XOR8(&I2C_SMB_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_SMB bitfields
 */

/*!
 * @name Register I2C_SMB, field SHTF2IE[0] (RW)
 *
 * Enables SCL high and SDA low timeout interrupt.
 *
 * Values:
 * - 0 - SHTF2 interrupt is disabled
 * - 1 - SHTF2 interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF2IE field. */
#define I2C_RD_SMB_SHTF2IE(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF2IE_MASK) >> I2C_SMB_SHTF2IE_SHIFT)
#define I2C_BRD_SMB_SHTF2IE(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SHTF2IE_SHIFT, I2C_SMB_SHTF2IE_WIDTH))

/*! @brief Set the SHTF2IE field to a new value. */
#define I2C_WR_SMB_SHTF2IE(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SHTF2IE_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SHTF2IE(value)))
#define I2C_BWR_SMB_SHTF2IE(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SHTF2IE_SHIFT), I2C_SMB_SHTF2IE_SHIFT, I2C_SMB_SHTF2IE_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF2[1] (W1C)
 *
 * This bit sets when SCL is held high and SDA is held low more than clock *
 * LoValue / 512. Software clears this bit by writing 1 to it.
 *
 * Values:
 * - 0 - No SCL high and SDA low timeout occurs
 * - 1 - SCL high and SDA low timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF2 field. */
#define I2C_RD_SMB_SHTF2(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF2_MASK) >> I2C_SMB_SHTF2_SHIFT)
#define I2C_BRD_SMB_SHTF2(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SHTF2_SHIFT, I2C_SMB_SHTF2_WIDTH))

/*! @brief Set the SHTF2 field to a new value. */
#define I2C_WR_SMB_SHTF2(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SHTF2(value)))
#define I2C_BWR_SMB_SHTF2(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SHTF2_SHIFT), I2C_SMB_SHTF2_SHIFT, I2C_SMB_SHTF2_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF1[2] (RO)
 *
 * This read-only bit sets when SCL and SDA are held high more than clock *
 * LoValue / 512, which indicates the bus is free. This bit is cleared automatically.
 *
 * Values:
 * - 0 - No SCL high and SDA high timeout occurs
 * - 1 - SCL high and SDA high timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF1 field. */
#define I2C_RD_SMB_SHTF1(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF1_MASK) >> I2C_SMB_SHTF1_SHIFT)
#define I2C_BRD_SMB_SHTF1(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SHTF1_SHIFT, I2C_SMB_SHTF1_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SLTF[3] (W1C)
 *
 * This bit is set when the SLT register (consisting of the SLTH and SLTL
 * registers) is loaded with a non-zero value (LoValue) and an SCL low timeout occurs.
 * Software clears this bit by writing a logic 1 to it. The low timeout function
 * is disabled when the SLT register's value is 0.
 *
 * Values:
 * - 0 - No low timeout occurs
 * - 1 - Low timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SLTF field. */
#define I2C_RD_SMB_SLTF(base) ((I2C_SMB_REG(base) & I2C_SMB_SLTF_MASK) >> I2C_SMB_SLTF_SHIFT)
#define I2C_BRD_SMB_SLTF(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SLTF_SHIFT, I2C_SMB_SLTF_WIDTH))

/*! @brief Set the SLTF field to a new value. */
#define I2C_WR_SMB_SLTF(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SLTF_MASK | I2C_SMB_SHTF2_MASK), I2C_SMB_SLTF(value)))
#define I2C_BWR_SMB_SLTF(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SLTF_SHIFT), I2C_SMB_SLTF_SHIFT, I2C_SMB_SLTF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field TCKSEL[4] (RW)
 *
 * Selects the clock source of the timeout counter.
 *
 * Values:
 * - 0 - Timeout counter counts at the frequency of the I2C module clock / 64
 * - 1 - Timeout counter counts at the frequency of the I2C module clock
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_TCKSEL field. */
#define I2C_RD_SMB_TCKSEL(base) ((I2C_SMB_REG(base) & I2C_SMB_TCKSEL_MASK) >> I2C_SMB_TCKSEL_SHIFT)
#define I2C_BRD_SMB_TCKSEL(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_TCKSEL_SHIFT, I2C_SMB_TCKSEL_WIDTH))

/*! @brief Set the TCKSEL field to a new value. */
#define I2C_WR_SMB_TCKSEL(base, value) (I2C_RMW_SMB(base, (I2C_SMB_TCKSEL_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_TCKSEL(value)))
#define I2C_BWR_SMB_TCKSEL(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_TCKSEL_SHIFT), I2C_SMB_TCKSEL_SHIFT, I2C_SMB_TCKSEL_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SIICAEN[5] (RW)
 *
 * Enables or disables SMBus device default address.
 *
 * Values:
 * - 0 - I2C address register 2 matching is disabled
 * - 1 - I2C address register 2 matching is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SIICAEN field. */
#define I2C_RD_SMB_SIICAEN(base) ((I2C_SMB_REG(base) & I2C_SMB_SIICAEN_MASK) >> I2C_SMB_SIICAEN_SHIFT)
#define I2C_BRD_SMB_SIICAEN(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SIICAEN_SHIFT, I2C_SMB_SIICAEN_WIDTH))

/*! @brief Set the SIICAEN field to a new value. */
#define I2C_WR_SMB_SIICAEN(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SIICAEN_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SIICAEN(value)))
#define I2C_BWR_SMB_SIICAEN(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SIICAEN_SHIFT), I2C_SMB_SIICAEN_SHIFT, I2C_SMB_SIICAEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field ALERTEN[6] (RW)
 *
 * Enables or disables SMBus alert response address matching. After the host
 * responds to a device that used the alert response address, you must use software
 * to put the device's address on the bus. The alert protocol is described in the
 * SMBus specification.
 *
 * Values:
 * - 0 - SMBus alert response address matching is disabled
 * - 1 - SMBus alert response address matching is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_ALERTEN field. */
#define I2C_RD_SMB_ALERTEN(base) ((I2C_SMB_REG(base) & I2C_SMB_ALERTEN_MASK) >> I2C_SMB_ALERTEN_SHIFT)
#define I2C_BRD_SMB_ALERTEN(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_ALERTEN_SHIFT, I2C_SMB_ALERTEN_WIDTH))

/*! @brief Set the ALERTEN field to a new value. */
#define I2C_WR_SMB_ALERTEN(base, value) (I2C_RMW_SMB(base, (I2C_SMB_ALERTEN_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_ALERTEN(value)))
#define I2C_BWR_SMB_ALERTEN(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_ALERTEN_SHIFT), I2C_SMB_ALERTEN_SHIFT, I2C_SMB_ALERTEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field FACK[7] (RW)
 *
 * For SMBus packet error checking, the CPU must be able to issue an ACK or NACK
 * according to the result of receiving data byte.
 *
 * Values:
 * - 0 - An ACK or NACK is sent on the following receiving data byte
 * - 1 - Writing 0 to TXAK after receiving a data byte generates an ACK. Writing
 *     1 to TXAK after receiving a data byte generates a NACK.
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_FACK field. */
#define I2C_RD_SMB_FACK(base) ((I2C_SMB_REG(base) & I2C_SMB_FACK_MASK) >> I2C_SMB_FACK_SHIFT)
#define I2C_BRD_SMB_FACK(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_FACK_SHIFT, I2C_SMB_FACK_WIDTH))

/*! @brief Set the FACK field to a new value. */
#define I2C_WR_SMB_FACK(base, value) (I2C_RMW_SMB(base, (I2C_SMB_FACK_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_FACK(value)))
#define I2C_BWR_SMB_FACK(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_FACK_SHIFT), I2C_SMB_FACK_SHIFT, I2C_SMB_FACK_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_A2 - I2C Address Register 2
 ******************************************************************************/

/*!
 * @brief I2C_A2 - I2C Address Register 2 (RW)
 *
 * Reset value: 0xC2U
 */
/*!
 * @name Constants and macros for entire I2C_A2 register
 */
/*@{*/
#define I2C_RD_A2(base)          (I2C_A2_REG(base))
#define I2C_WR_A2(base, value)   (I2C_A2_REG(base) = (value))
#define I2C_RMW_A2(base, mask, value) (I2C_WR_A2(base, (I2C_RD_A2(base) & ~(mask)) | (value)))
#define I2C_SET_A2(base, value)  (BME_OR8(&I2C_A2_REG(base), (uint8_t)(value)))
#define I2C_CLR_A2(base, value)  (BME_AND8(&I2C_A2_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_A2(base, value)  (BME_XOR8(&I2C_A2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_A2 bitfields
 */

/*!
 * @name Register I2C_A2, field SAD[7:1] (RW)
 *
 * Contains the slave address used by the SMBus. This field is used on the
 * device default address or other related addresses.
 */
/*@{*/
/*! @brief Read current value of the I2C_A2_SAD field. */
#define I2C_RD_A2_SAD(base)  ((I2C_A2_REG(base) & I2C_A2_SAD_MASK) >> I2C_A2_SAD_SHIFT)
#define I2C_BRD_A2_SAD(base) (BME_UBFX8(&I2C_A2_REG(base), I2C_A2_SAD_SHIFT, I2C_A2_SAD_WIDTH))

/*! @brief Set the SAD field to a new value. */
#define I2C_WR_A2_SAD(base, value) (I2C_RMW_A2(base, I2C_A2_SAD_MASK, I2C_A2_SAD(value)))
#define I2C_BWR_A2_SAD(base, value) (BME_BFI8(&I2C_A2_REG(base), ((uint8_t)(value) << I2C_A2_SAD_SHIFT), I2C_A2_SAD_SHIFT, I2C_A2_SAD_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_SLTH - I2C SCL Low Timeout Register High
 ******************************************************************************/

/*!
 * @brief I2C_SLTH - I2C SCL Low Timeout Register High (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_SLTH register
 */
/*@{*/
#define I2C_RD_SLTH(base)        (I2C_SLTH_REG(base))
#define I2C_WR_SLTH(base, value) (I2C_SLTH_REG(base) = (value))
#define I2C_RMW_SLTH(base, mask, value) (I2C_WR_SLTH(base, (I2C_RD_SLTH(base) & ~(mask)) | (value)))
#define I2C_SET_SLTH(base, value) (BME_OR8(&I2C_SLTH_REG(base), (uint8_t)(value)))
#define I2C_CLR_SLTH(base, value) (BME_AND8(&I2C_SLTH_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_SLTH(base, value) (BME_XOR8(&I2C_SLTH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * I2C_SLTL - I2C SCL Low Timeout Register Low
 ******************************************************************************/

/*!
 * @brief I2C_SLTL - I2C SCL Low Timeout Register Low (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_SLTL register
 */
/*@{*/
#define I2C_RD_SLTL(base)        (I2C_SLTL_REG(base))
#define I2C_WR_SLTL(base, value) (I2C_SLTL_REG(base) = (value))
#define I2C_RMW_SLTL(base, mask, value) (I2C_WR_SLTL(base, (I2C_RD_SLTL(base) & ~(mask)) | (value)))
#define I2C_SET_SLTL(base, value) (BME_OR8(&I2C_SLTL_REG(base), (uint8_t)(value)))
#define I2C_CLR_SLTL(base, value) (BME_AND8(&I2C_SLTL_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_SLTL(base, value) (BME_XOR8(&I2C_SLTL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * MKV10Z7 LLWU
 *
 * Low leakage wakeup unit
 *
 * Registers defined in this header file:
 * - LLWU_PE1 - LLWU Pin Enable 1 register
 * - LLWU_PE2 - LLWU Pin Enable 2 register
 * - LLWU_PE3 - LLWU Pin Enable 3 register
 * - LLWU_PE4 - LLWU Pin Enable 4 register
 * - LLWU_ME - LLWU Module Enable register
 * - LLWU_F1 - LLWU Flag 1 register
 * - LLWU_F2 - LLWU Flag 2 register
 * - LLWU_F3 - LLWU Flag 3 register
 * - LLWU_FILT1 - LLWU Pin Filter 1 register
 * - LLWU_FILT2 - LLWU Pin Filter 2 register
 */

#define LLWU_INSTANCE_COUNT (1U) /*!< Number of instances of the LLWU module. */
#define LLWU_IDX (0U) /*!< Instance number for LLWU. */

/*******************************************************************************
 * LLWU_PE1 - LLWU Pin Enable 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE1 - LLWU Pin Enable 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE1 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P3-LLWU_P0. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE1 register
 */
/*@{*/
#define LLWU_RD_PE1(base)        (LLWU_PE1_REG(base))
#define LLWU_WR_PE1(base, value) (LLWU_PE1_REG(base) = (value))
#define LLWU_RMW_PE1(base, mask, value) (LLWU_WR_PE1(base, (LLWU_RD_PE1(base) & ~(mask)) | (value)))
#define LLWU_SET_PE1(base, value) (BME_OR8(&LLWU_PE1_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE1(base, value) (BME_AND8(&LLWU_PE1_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE1(base, value) (BME_XOR8(&LLWU_PE1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE1 bitfields
 */

/*!
 * @name Register LLWU_PE1, field WUPE0[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE0 field. */
#define LLWU_RD_PE1_WUPE0(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE0_MASK) >> LLWU_PE1_WUPE0_SHIFT)
#define LLWU_BRD_PE1_WUPE0(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE0_SHIFT, LLWU_PE1_WUPE0_WIDTH))

/*! @brief Set the WUPE0 field to a new value. */
#define LLWU_WR_PE1_WUPE0(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE0_MASK, LLWU_PE1_WUPE0(value)))
#define LLWU_BWR_PE1_WUPE0(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE0_SHIFT), LLWU_PE1_WUPE0_SHIFT, LLWU_PE1_WUPE0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE1[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE1 field. */
#define LLWU_RD_PE1_WUPE1(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE1_MASK) >> LLWU_PE1_WUPE1_SHIFT)
#define LLWU_BRD_PE1_WUPE1(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE1_SHIFT, LLWU_PE1_WUPE1_WIDTH))

/*! @brief Set the WUPE1 field to a new value. */
#define LLWU_WR_PE1_WUPE1(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE1_MASK, LLWU_PE1_WUPE1(value)))
#define LLWU_BWR_PE1_WUPE1(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE1_SHIFT), LLWU_PE1_WUPE1_SHIFT, LLWU_PE1_WUPE1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE2[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE2 field. */
#define LLWU_RD_PE1_WUPE2(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE2_MASK) >> LLWU_PE1_WUPE2_SHIFT)
#define LLWU_BRD_PE1_WUPE2(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE2_SHIFT, LLWU_PE1_WUPE2_WIDTH))

/*! @brief Set the WUPE2 field to a new value. */
#define LLWU_WR_PE1_WUPE2(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE2_MASK, LLWU_PE1_WUPE2(value)))
#define LLWU_BWR_PE1_WUPE2(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE2_SHIFT), LLWU_PE1_WUPE2_SHIFT, LLWU_PE1_WUPE2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE3[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE3 field. */
#define LLWU_RD_PE1_WUPE3(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE3_MASK) >> LLWU_PE1_WUPE3_SHIFT)
#define LLWU_BRD_PE1_WUPE3(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE3_SHIFT, LLWU_PE1_WUPE3_WIDTH))

/*! @brief Set the WUPE3 field to a new value. */
#define LLWU_WR_PE1_WUPE3(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE3_MASK, LLWU_PE1_WUPE3(value)))
#define LLWU_BWR_PE1_WUPE3(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE3_SHIFT), LLWU_PE1_WUPE3_SHIFT, LLWU_PE1_WUPE3_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE2 - LLWU Pin Enable 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE2 - LLWU Pin Enable 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE2 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P7-LLWU_P4. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE2 register
 */
/*@{*/
#define LLWU_RD_PE2(base)        (LLWU_PE2_REG(base))
#define LLWU_WR_PE2(base, value) (LLWU_PE2_REG(base) = (value))
#define LLWU_RMW_PE2(base, mask, value) (LLWU_WR_PE2(base, (LLWU_RD_PE2(base) & ~(mask)) | (value)))
#define LLWU_SET_PE2(base, value) (BME_OR8(&LLWU_PE2_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE2(base, value) (BME_AND8(&LLWU_PE2_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE2(base, value) (BME_XOR8(&LLWU_PE2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE2 bitfields
 */

/*!
 * @name Register LLWU_PE2, field WUPE4[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE4 field. */
#define LLWU_RD_PE2_WUPE4(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE4_MASK) >> LLWU_PE2_WUPE4_SHIFT)
#define LLWU_BRD_PE2_WUPE4(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE4_SHIFT, LLWU_PE2_WUPE4_WIDTH))

/*! @brief Set the WUPE4 field to a new value. */
#define LLWU_WR_PE2_WUPE4(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE4_MASK, LLWU_PE2_WUPE4(value)))
#define LLWU_BWR_PE2_WUPE4(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE4_SHIFT), LLWU_PE2_WUPE4_SHIFT, LLWU_PE2_WUPE4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE5[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE5 field. */
#define LLWU_RD_PE2_WUPE5(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE5_MASK) >> LLWU_PE2_WUPE5_SHIFT)
#define LLWU_BRD_PE2_WUPE5(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE5_SHIFT, LLWU_PE2_WUPE5_WIDTH))

/*! @brief Set the WUPE5 field to a new value. */
#define LLWU_WR_PE2_WUPE5(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE5_MASK, LLWU_PE2_WUPE5(value)))
#define LLWU_BWR_PE2_WUPE5(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE5_SHIFT), LLWU_PE2_WUPE5_SHIFT, LLWU_PE2_WUPE5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE6[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE6 field. */
#define LLWU_RD_PE2_WUPE6(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE6_MASK) >> LLWU_PE2_WUPE6_SHIFT)
#define LLWU_BRD_PE2_WUPE6(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE6_SHIFT, LLWU_PE2_WUPE6_WIDTH))

/*! @brief Set the WUPE6 field to a new value. */
#define LLWU_WR_PE2_WUPE6(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE6_MASK, LLWU_PE2_WUPE6(value)))
#define LLWU_BWR_PE2_WUPE6(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE6_SHIFT), LLWU_PE2_WUPE6_SHIFT, LLWU_PE2_WUPE6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE7[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE7 field. */
#define LLWU_RD_PE2_WUPE7(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE7_MASK) >> LLWU_PE2_WUPE7_SHIFT)
#define LLWU_BRD_PE2_WUPE7(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE7_SHIFT, LLWU_PE2_WUPE7_WIDTH))

/*! @brief Set the WUPE7 field to a new value. */
#define LLWU_WR_PE2_WUPE7(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE7_MASK, LLWU_PE2_WUPE7(value)))
#define LLWU_BWR_PE2_WUPE7(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE7_SHIFT), LLWU_PE2_WUPE7_SHIFT, LLWU_PE2_WUPE7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE3 - LLWU Pin Enable 3 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE3 - LLWU Pin Enable 3 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE3 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P11-LLWU_P8. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE3 register
 */
/*@{*/
#define LLWU_RD_PE3(base)        (LLWU_PE3_REG(base))
#define LLWU_WR_PE3(base, value) (LLWU_PE3_REG(base) = (value))
#define LLWU_RMW_PE3(base, mask, value) (LLWU_WR_PE3(base, (LLWU_RD_PE3(base) & ~(mask)) | (value)))
#define LLWU_SET_PE3(base, value) (BME_OR8(&LLWU_PE3_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE3(base, value) (BME_AND8(&LLWU_PE3_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE3(base, value) (BME_XOR8(&LLWU_PE3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE3 bitfields
 */

/*!
 * @name Register LLWU_PE3, field WUPE8[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE8 field. */
#define LLWU_RD_PE3_WUPE8(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE8_MASK) >> LLWU_PE3_WUPE8_SHIFT)
#define LLWU_BRD_PE3_WUPE8(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE8_SHIFT, LLWU_PE3_WUPE8_WIDTH))

/*! @brief Set the WUPE8 field to a new value. */
#define LLWU_WR_PE3_WUPE8(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE8_MASK, LLWU_PE3_WUPE8(value)))
#define LLWU_BWR_PE3_WUPE8(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE8_SHIFT), LLWU_PE3_WUPE8_SHIFT, LLWU_PE3_WUPE8_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE9[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE9 field. */
#define LLWU_RD_PE3_WUPE9(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE9_MASK) >> LLWU_PE3_WUPE9_SHIFT)
#define LLWU_BRD_PE3_WUPE9(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE9_SHIFT, LLWU_PE3_WUPE9_WIDTH))

/*! @brief Set the WUPE9 field to a new value. */
#define LLWU_WR_PE3_WUPE9(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE9_MASK, LLWU_PE3_WUPE9(value)))
#define LLWU_BWR_PE3_WUPE9(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE9_SHIFT), LLWU_PE3_WUPE9_SHIFT, LLWU_PE3_WUPE9_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE10[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE10 field. */
#define LLWU_RD_PE3_WUPE10(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE10_MASK) >> LLWU_PE3_WUPE10_SHIFT)
#define LLWU_BRD_PE3_WUPE10(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE10_SHIFT, LLWU_PE3_WUPE10_WIDTH))

/*! @brief Set the WUPE10 field to a new value. */
#define LLWU_WR_PE3_WUPE10(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE10_MASK, LLWU_PE3_WUPE10(value)))
#define LLWU_BWR_PE3_WUPE10(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE10_SHIFT), LLWU_PE3_WUPE10_SHIFT, LLWU_PE3_WUPE10_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE11[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE11 field. */
#define LLWU_RD_PE3_WUPE11(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE11_MASK) >> LLWU_PE3_WUPE11_SHIFT)
#define LLWU_BRD_PE3_WUPE11(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE11_SHIFT, LLWU_PE3_WUPE11_WIDTH))

/*! @brief Set the WUPE11 field to a new value. */
#define LLWU_WR_PE3_WUPE11(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE11_MASK, LLWU_PE3_WUPE11(value)))
#define LLWU_BWR_PE3_WUPE11(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE11_SHIFT), LLWU_PE3_WUPE11_SHIFT, LLWU_PE3_WUPE11_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE4 - LLWU Pin Enable 4 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE4 - LLWU Pin Enable 4 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE4 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P15-LLWU_P12. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE4 register
 */
/*@{*/
#define LLWU_RD_PE4(base)        (LLWU_PE4_REG(base))
#define LLWU_WR_PE4(base, value) (LLWU_PE4_REG(base) = (value))
#define LLWU_RMW_PE4(base, mask, value) (LLWU_WR_PE4(base, (LLWU_RD_PE4(base) & ~(mask)) | (value)))
#define LLWU_SET_PE4(base, value) (BME_OR8(&LLWU_PE4_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE4(base, value) (BME_AND8(&LLWU_PE4_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE4(base, value) (BME_XOR8(&LLWU_PE4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE4 bitfields
 */

/*!
 * @name Register LLWU_PE4, field WUPE12[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE12 field. */
#define LLWU_RD_PE4_WUPE12(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE12_MASK) >> LLWU_PE4_WUPE12_SHIFT)
#define LLWU_BRD_PE4_WUPE12(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE12_SHIFT, LLWU_PE4_WUPE12_WIDTH))

/*! @brief Set the WUPE12 field to a new value. */
#define LLWU_WR_PE4_WUPE12(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE12_MASK, LLWU_PE4_WUPE12(value)))
#define LLWU_BWR_PE4_WUPE12(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE12_SHIFT), LLWU_PE4_WUPE12_SHIFT, LLWU_PE4_WUPE12_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE13[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE13 field. */
#define LLWU_RD_PE4_WUPE13(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE13_MASK) >> LLWU_PE4_WUPE13_SHIFT)
#define LLWU_BRD_PE4_WUPE13(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE13_SHIFT, LLWU_PE4_WUPE13_WIDTH))

/*! @brief Set the WUPE13 field to a new value. */
#define LLWU_WR_PE4_WUPE13(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE13_MASK, LLWU_PE4_WUPE13(value)))
#define LLWU_BWR_PE4_WUPE13(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE13_SHIFT), LLWU_PE4_WUPE13_SHIFT, LLWU_PE4_WUPE13_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE14[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE14 field. */
#define LLWU_RD_PE4_WUPE14(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE14_MASK) >> LLWU_PE4_WUPE14_SHIFT)
#define LLWU_BRD_PE4_WUPE14(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE14_SHIFT, LLWU_PE4_WUPE14_WIDTH))

/*! @brief Set the WUPE14 field to a new value. */
#define LLWU_WR_PE4_WUPE14(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE14_MASK, LLWU_PE4_WUPE14(value)))
#define LLWU_BWR_PE4_WUPE14(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE14_SHIFT), LLWU_PE4_WUPE14_SHIFT, LLWU_PE4_WUPE14_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE15[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE15 field. */
#define LLWU_RD_PE4_WUPE15(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE15_MASK) >> LLWU_PE4_WUPE15_SHIFT)
#define LLWU_BRD_PE4_WUPE15(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE15_SHIFT, LLWU_PE4_WUPE15_WIDTH))

/*! @brief Set the WUPE15 field to a new value. */
#define LLWU_WR_PE4_WUPE15(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE15_MASK, LLWU_PE4_WUPE15(value)))
#define LLWU_BWR_PE4_WUPE15(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE15_SHIFT), LLWU_PE4_WUPE15_SHIFT, LLWU_PE4_WUPE15_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_ME - LLWU Module Enable register
 ******************************************************************************/

/*!
 * @brief LLWU_ME - LLWU Module Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_ME contains the bits to enable the internal module flag as a wakeup
 * input source for inputs MWUF7-MWUF0. This register is reset on Chip Reset not VLLS
 * and by reset types that trigger Chip Reset not VLLS. It is unaffected by
 * reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module (RCM). The
 * RCM implements many of the reset functions for the chip. See the chip's reset
 * chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_ME register
 */
/*@{*/
#define LLWU_RD_ME(base)         (LLWU_ME_REG(base))
#define LLWU_WR_ME(base, value)  (LLWU_ME_REG(base) = (value))
#define LLWU_RMW_ME(base, mask, value) (LLWU_WR_ME(base, (LLWU_RD_ME(base) & ~(mask)) | (value)))
#define LLWU_SET_ME(base, value) (BME_OR8(&LLWU_ME_REG(base), (uint8_t)(value)))
#define LLWU_CLR_ME(base, value) (BME_AND8(&LLWU_ME_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_ME(base, value) (BME_XOR8(&LLWU_ME_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_ME bitfields
 */

/*!
 * @name Register LLWU_ME, field WUME0[0] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME0 field. */
#define LLWU_RD_ME_WUME0(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME0_MASK) >> LLWU_ME_WUME0_SHIFT)
#define LLWU_BRD_ME_WUME0(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME0_SHIFT, LLWU_ME_WUME0_WIDTH))

/*! @brief Set the WUME0 field to a new value. */
#define LLWU_WR_ME_WUME0(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME0_MASK, LLWU_ME_WUME0(value)))
#define LLWU_BWR_ME_WUME0(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME0_SHIFT), LLWU_ME_WUME0_SHIFT, LLWU_ME_WUME0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME1[1] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME1 field. */
#define LLWU_RD_ME_WUME1(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME1_MASK) >> LLWU_ME_WUME1_SHIFT)
#define LLWU_BRD_ME_WUME1(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME1_SHIFT, LLWU_ME_WUME1_WIDTH))

/*! @brief Set the WUME1 field to a new value. */
#define LLWU_WR_ME_WUME1(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME1_MASK, LLWU_ME_WUME1(value)))
#define LLWU_BWR_ME_WUME1(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME1_SHIFT), LLWU_ME_WUME1_SHIFT, LLWU_ME_WUME1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME2[2] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME2 field. */
#define LLWU_RD_ME_WUME2(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME2_MASK) >> LLWU_ME_WUME2_SHIFT)
#define LLWU_BRD_ME_WUME2(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME2_SHIFT, LLWU_ME_WUME2_WIDTH))

/*! @brief Set the WUME2 field to a new value. */
#define LLWU_WR_ME_WUME2(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME2_MASK, LLWU_ME_WUME2(value)))
#define LLWU_BWR_ME_WUME2(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME2_SHIFT), LLWU_ME_WUME2_SHIFT, LLWU_ME_WUME2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME3[3] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME3 field. */
#define LLWU_RD_ME_WUME3(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME3_MASK) >> LLWU_ME_WUME3_SHIFT)
#define LLWU_BRD_ME_WUME3(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME3_SHIFT, LLWU_ME_WUME3_WIDTH))

/*! @brief Set the WUME3 field to a new value. */
#define LLWU_WR_ME_WUME3(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME3_MASK, LLWU_ME_WUME3(value)))
#define LLWU_BWR_ME_WUME3(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME3_SHIFT), LLWU_ME_WUME3_SHIFT, LLWU_ME_WUME3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME4[4] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME4 field. */
#define LLWU_RD_ME_WUME4(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME4_MASK) >> LLWU_ME_WUME4_SHIFT)
#define LLWU_BRD_ME_WUME4(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME4_SHIFT, LLWU_ME_WUME4_WIDTH))

/*! @brief Set the WUME4 field to a new value. */
#define LLWU_WR_ME_WUME4(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME4_MASK, LLWU_ME_WUME4(value)))
#define LLWU_BWR_ME_WUME4(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME4_SHIFT), LLWU_ME_WUME4_SHIFT, LLWU_ME_WUME4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME5[5] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME5 field. */
#define LLWU_RD_ME_WUME5(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME5_MASK) >> LLWU_ME_WUME5_SHIFT)
#define LLWU_BRD_ME_WUME5(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME5_SHIFT, LLWU_ME_WUME5_WIDTH))

/*! @brief Set the WUME5 field to a new value. */
#define LLWU_WR_ME_WUME5(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME5_MASK, LLWU_ME_WUME5(value)))
#define LLWU_BWR_ME_WUME5(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME5_SHIFT), LLWU_ME_WUME5_SHIFT, LLWU_ME_WUME5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME6[6] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME6 field. */
#define LLWU_RD_ME_WUME6(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME6_MASK) >> LLWU_ME_WUME6_SHIFT)
#define LLWU_BRD_ME_WUME6(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME6_SHIFT, LLWU_ME_WUME6_WIDTH))

/*! @brief Set the WUME6 field to a new value. */
#define LLWU_WR_ME_WUME6(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME6_MASK, LLWU_ME_WUME6(value)))
#define LLWU_BWR_ME_WUME6(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME6_SHIFT), LLWU_ME_WUME6_SHIFT, LLWU_ME_WUME6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME7[7] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME7 field. */
#define LLWU_RD_ME_WUME7(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME7_MASK) >> LLWU_ME_WUME7_SHIFT)
#define LLWU_BRD_ME_WUME7(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME7_SHIFT, LLWU_ME_WUME7_WIDTH))

/*! @brief Set the WUME7 field to a new value. */
#define LLWU_WR_ME_WUME7(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME7_MASK, LLWU_ME_WUME7(value)))
#define LLWU_BWR_ME_WUME7(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME7_SHIFT), LLWU_ME_WUME7_SHIFT, LLWU_ME_WUME7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_F1 - LLWU Flag 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_F1 - LLWU Flag 1 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_F1 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit VLLS mode. For VLLS, this is the source causing the MCU reset flow.
 * The external wakeup flags are read-only and clearing a flag is accomplished
 * by a write of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if
 * set, will remain set if the associated WUPEx bit is cleared. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS.
 * It is unaffected by reset types that do not trigger Chip Reset not VLLS. See
 * the IntroductionInformation found here describes the registers of the Reset
 * Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
/*!
 * @name Constants and macros for entire LLWU_F1 register
 */
/*@{*/
#define LLWU_RD_F1(base)         (LLWU_F1_REG(base))
#define LLWU_WR_F1(base, value)  (LLWU_F1_REG(base) = (value))
#define LLWU_RMW_F1(base, mask, value) (LLWU_WR_F1(base, (LLWU_RD_F1(base) & ~(mask)) | (value)))
#define LLWU_SET_F1(base, value) (BME_OR8(&LLWU_F1_REG(base), (uint8_t)(value)))
#define LLWU_CLR_F1(base, value) (BME_AND8(&LLWU_F1_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_F1(base, value) (BME_XOR8(&LLWU_F1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_F1 bitfields
 */

/*!
 * @name Register LLWU_F1, field WUF0[0] (W1C)
 *
 * Indicates that an enabled external wake-up pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF0.
 *
 * Values:
 * - 0 - LLWU_P0 input was not a wakeup source
 * - 1 - LLWU_P0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF0 field. */
#define LLWU_RD_F1_WUF0(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF0_MASK) >> LLWU_F1_WUF0_SHIFT)
#define LLWU_BRD_F1_WUF0(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF0_SHIFT, LLWU_F1_WUF0_WIDTH))

/*! @brief Set the WUF0 field to a new value. */
#define LLWU_WR_F1_WUF0(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF0(value)))
#define LLWU_BWR_F1_WUF0(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF0_SHIFT), LLWU_F1_WUF0_SHIFT, LLWU_F1_WUF0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF1[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF1.
 *
 * Values:
 * - 0 - LLWU_P1 input was not a wakeup source
 * - 1 - LLWU_P1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF1 field. */
#define LLWU_RD_F1_WUF1(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF1_MASK) >> LLWU_F1_WUF1_SHIFT)
#define LLWU_BRD_F1_WUF1(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF1_SHIFT, LLWU_F1_WUF1_WIDTH))

/*! @brief Set the WUF1 field to a new value. */
#define LLWU_WR_F1_WUF1(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF1_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF1(value)))
#define LLWU_BWR_F1_WUF1(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF1_SHIFT), LLWU_F1_WUF1_SHIFT, LLWU_F1_WUF1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF2[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF2.
 *
 * Values:
 * - 0 - LLWU_P2 input was not a wakeup source
 * - 1 - LLWU_P2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF2 field. */
#define LLWU_RD_F1_WUF2(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF2_MASK) >> LLWU_F1_WUF2_SHIFT)
#define LLWU_BRD_F1_WUF2(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF2_SHIFT, LLWU_F1_WUF2_WIDTH))

/*! @brief Set the WUF2 field to a new value. */
#define LLWU_WR_F1_WUF2(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF2_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF2(value)))
#define LLWU_BWR_F1_WUF2(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF2_SHIFT), LLWU_F1_WUF2_SHIFT, LLWU_F1_WUF2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF3[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF3.
 *
 * Values:
 * - 0 - LLWU_P3 input was not a wake-up source
 * - 1 - LLWU_P3 input was a wake-up source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF3 field. */
#define LLWU_RD_F1_WUF3(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF3_MASK) >> LLWU_F1_WUF3_SHIFT)
#define LLWU_BRD_F1_WUF3(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF3_SHIFT, LLWU_F1_WUF3_WIDTH))

/*! @brief Set the WUF3 field to a new value. */
#define LLWU_WR_F1_WUF3(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF3_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF3(value)))
#define LLWU_BWR_F1_WUF3(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF3_SHIFT), LLWU_F1_WUF3_SHIFT, LLWU_F1_WUF3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF4[4] (W1C)
 *
 * Indicates that an enabled external wake-up pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF4.
 *
 * Values:
 * - 0 - LLWU_P4 input was not a wakeup source
 * - 1 - LLWU_P4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF4 field. */
#define LLWU_RD_F1_WUF4(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF4_MASK) >> LLWU_F1_WUF4_SHIFT)
#define LLWU_BRD_F1_WUF4(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF4_SHIFT, LLWU_F1_WUF4_WIDTH))

/*! @brief Set the WUF4 field to a new value. */
#define LLWU_WR_F1_WUF4(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF4_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF4(value)))
#define LLWU_BWR_F1_WUF4(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF4_SHIFT), LLWU_F1_WUF4_SHIFT, LLWU_F1_WUF4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF5[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF5.
 *
 * Values:
 * - 0 - LLWU_P5 input was not a wakeup source
 * - 1 - LLWU_P5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF5 field. */
#define LLWU_RD_F1_WUF5(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF5_MASK) >> LLWU_F1_WUF5_SHIFT)
#define LLWU_BRD_F1_WUF5(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF5_SHIFT, LLWU_F1_WUF5_WIDTH))

/*! @brief Set the WUF5 field to a new value. */
#define LLWU_WR_F1_WUF5(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF5_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF5(value)))
#define LLWU_BWR_F1_WUF5(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF5_SHIFT), LLWU_F1_WUF5_SHIFT, LLWU_F1_WUF5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF6[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF6.
 *
 * Values:
 * - 0 - LLWU_P6 input was not a wakeup source
 * - 1 - LLWU_P6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF6 field. */
#define LLWU_RD_F1_WUF6(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF6_MASK) >> LLWU_F1_WUF6_SHIFT)
#define LLWU_BRD_F1_WUF6(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF6_SHIFT, LLWU_F1_WUF6_WIDTH))

/*! @brief Set the WUF6 field to a new value. */
#define LLWU_WR_F1_WUF6(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF6_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF6(value)))
#define LLWU_BWR_F1_WUF6(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF6_SHIFT), LLWU_F1_WUF6_SHIFT, LLWU_F1_WUF6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF7[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF7.
 *
 * Values:
 * - 0 - LLWU_P7 input was not a wakeup source
 * - 1 - LLWU_P7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF7 field. */
#define LLWU_RD_F1_WUF7(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF7_MASK) >> LLWU_F1_WUF7_SHIFT)
#define LLWU_BRD_F1_WUF7(base) (BME_UBFX8(&LLWU_F1_REG(base), LLWU_F1_WUF7_SHIFT, LLWU_F1_WUF7_WIDTH))

/*! @brief Set the WUF7 field to a new value. */
#define LLWU_WR_F1_WUF7(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF7_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK), LLWU_F1_WUF7(value)))
#define LLWU_BWR_F1_WUF7(base, value) (BME_BFI8(&LLWU_F1_REG(base), ((uint8_t)(value) << LLWU_F1_WUF7_SHIFT), LLWU_F1_WUF7_SHIFT, LLWU_F1_WUF7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_F2 - LLWU Flag 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_F2 - LLWU Flag 2 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_F2 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit or VLLS mode. For VLLS, this is the source causing the MCU reset
 * flow. The external wakeup flags are read-only and clearing a flag is
 * accomplished by a write of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if
 * set, will remain set if the associated WUPEx bit is cleared. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS.
 * See the IntroductionInformation found here describes the registers of the Reset
 * Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
/*!
 * @name Constants and macros for entire LLWU_F2 register
 */
/*@{*/
#define LLWU_RD_F2(base)         (LLWU_F2_REG(base))
#define LLWU_WR_F2(base, value)  (LLWU_F2_REG(base) = (value))
#define LLWU_RMW_F2(base, mask, value) (LLWU_WR_F2(base, (LLWU_RD_F2(base) & ~(mask)) | (value)))
#define LLWU_SET_F2(base, value) (BME_OR8(&LLWU_F2_REG(base), (uint8_t)(value)))
#define LLWU_CLR_F2(base, value) (BME_AND8(&LLWU_F2_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_F2(base, value) (BME_XOR8(&LLWU_F2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_F2 bitfields
 */

/*!
 * @name Register LLWU_F2, field WUF8[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF8.
 *
 * Values:
 * - 0 - LLWU_P8 input was not a wakeup source
 * - 1 - LLWU_P8 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF8 field. */
#define LLWU_RD_F2_WUF8(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF8_MASK) >> LLWU_F2_WUF8_SHIFT)
#define LLWU_BRD_F2_WUF8(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF8_SHIFT, LLWU_F2_WUF8_WIDTH))

/*! @brief Set the WUF8 field to a new value. */
#define LLWU_WR_F2_WUF8(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF8(value)))
#define LLWU_BWR_F2_WUF8(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF8_SHIFT), LLWU_F2_WUF8_SHIFT, LLWU_F2_WUF8_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF9[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF9.
 *
 * Values:
 * - 0 - LLWU_P9 input was not a wakeup source
 * - 1 - LLWU_P9 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF9 field. */
#define LLWU_RD_F2_WUF9(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF9_MASK) >> LLWU_F2_WUF9_SHIFT)
#define LLWU_BRD_F2_WUF9(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF9_SHIFT, LLWU_F2_WUF9_WIDTH))

/*! @brief Set the WUF9 field to a new value. */
#define LLWU_WR_F2_WUF9(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF9_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF9(value)))
#define LLWU_BWR_F2_WUF9(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF9_SHIFT), LLWU_F2_WUF9_SHIFT, LLWU_F2_WUF9_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF10[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF10.
 *
 * Values:
 * - 0 - LLWU_P10 input was not a wakeup source
 * - 1 - LLWU_P10 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF10 field. */
#define LLWU_RD_F2_WUF10(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF10_MASK) >> LLWU_F2_WUF10_SHIFT)
#define LLWU_BRD_F2_WUF10(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF10_SHIFT, LLWU_F2_WUF10_WIDTH))

/*! @brief Set the WUF10 field to a new value. */
#define LLWU_WR_F2_WUF10(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF10_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF10(value)))
#define LLWU_BWR_F2_WUF10(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF10_SHIFT), LLWU_F2_WUF10_SHIFT, LLWU_F2_WUF10_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF11[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF11.
 *
 * Values:
 * - 0 - LLWU_P11 input was not a wakeup source
 * - 1 - LLWU_P11 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF11 field. */
#define LLWU_RD_F2_WUF11(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF11_MASK) >> LLWU_F2_WUF11_SHIFT)
#define LLWU_BRD_F2_WUF11(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF11_SHIFT, LLWU_F2_WUF11_WIDTH))

/*! @brief Set the WUF11 field to a new value. */
#define LLWU_WR_F2_WUF11(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF11_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF11(value)))
#define LLWU_BWR_F2_WUF11(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF11_SHIFT), LLWU_F2_WUF11_SHIFT, LLWU_F2_WUF11_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF12[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF12.
 *
 * Values:
 * - 0 - LLWU_P12 input was not a wakeup source
 * - 1 - LLWU_P12 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF12 field. */
#define LLWU_RD_F2_WUF12(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF12_MASK) >> LLWU_F2_WUF12_SHIFT)
#define LLWU_BRD_F2_WUF12(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF12_SHIFT, LLWU_F2_WUF12_WIDTH))

/*! @brief Set the WUF12 field to a new value. */
#define LLWU_WR_F2_WUF12(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF12_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF12(value)))
#define LLWU_BWR_F2_WUF12(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF12_SHIFT), LLWU_F2_WUF12_SHIFT, LLWU_F2_WUF12_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF13[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF13.
 *
 * Values:
 * - 0 - LLWU_P13 input was not a wakeup source
 * - 1 - LLWU_P13 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF13 field. */
#define LLWU_RD_F2_WUF13(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF13_MASK) >> LLWU_F2_WUF13_SHIFT)
#define LLWU_BRD_F2_WUF13(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF13_SHIFT, LLWU_F2_WUF13_WIDTH))

/*! @brief Set the WUF13 field to a new value. */
#define LLWU_WR_F2_WUF13(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF13_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF13(value)))
#define LLWU_BWR_F2_WUF13(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF13_SHIFT), LLWU_F2_WUF13_SHIFT, LLWU_F2_WUF13_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF14[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF14.
 *
 * Values:
 * - 0 - LLWU_P14 input was not a wakeup source
 * - 1 - LLWU_P14 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF14 field. */
#define LLWU_RD_F2_WUF14(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF14_MASK) >> LLWU_F2_WUF14_SHIFT)
#define LLWU_BRD_F2_WUF14(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF14_SHIFT, LLWU_F2_WUF14_WIDTH))

/*! @brief Set the WUF14 field to a new value. */
#define LLWU_WR_F2_WUF14(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF14_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF14(value)))
#define LLWU_BWR_F2_WUF14(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF14_SHIFT), LLWU_F2_WUF14_SHIFT, LLWU_F2_WUF14_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF15[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF15.
 *
 * Values:
 * - 0 - LLWU_P15 input was not a wakeup source
 * - 1 - LLWU_P15 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF15 field. */
#define LLWU_RD_F2_WUF15(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF15_MASK) >> LLWU_F2_WUF15_SHIFT)
#define LLWU_BRD_F2_WUF15(base) (BME_UBFX8(&LLWU_F2_REG(base), LLWU_F2_WUF15_SHIFT, LLWU_F2_WUF15_WIDTH))

/*! @brief Set the WUF15 field to a new value. */
#define LLWU_WR_F2_WUF15(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF15_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK), LLWU_F2_WUF15(value)))
#define LLWU_BWR_F2_WUF15(base, value) (BME_BFI8(&LLWU_F2_REG(base), ((uint8_t)(value) << LLWU_F2_WUF15_SHIFT), LLWU_F2_WUF15_SHIFT, LLWU_F2_WUF15_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_F3 - LLWU Flag 3 register
 ******************************************************************************/

/*!
 * @brief LLWU_F3 - LLWU Flag 3 register (RO)
 *
 * Reset value: 0x00U
 *
 * LLWU_F3 contains the wakeup flags indicating which internal wakeup source
 * caused the MCU to exit VLLS mode. For VLLS, this is the source causing the MCU
 * reset flow. For internal peripherals that are capable of running in a
 * low-leakage power mode, such as a real time clock module or CMP module, the flag from
 * the associated peripheral is accessible as the MWUFx bit. The flag will need to
 * be cleared in the peripheral instead of writing a 1 to the MWUFx bit. This
 * register is reset on Chip Reset not VLLS and by reset types that trigger Chip
 * Reset not VLLS. It is unaffected by reset types that do not trigger Chip Reset
 * not VLLS. See the IntroductionInformation found here describes the registers of
 * the Reset Control Module (RCM). The RCM implements many of the reset functions
 * for the chip. See the chip's reset chapter for more information. details for
 * more information.
 */
/*!
 * @name Constants and macros for entire LLWU_F3 register
 */
/*@{*/
#define LLWU_RD_F3(base)         (LLWU_F3_REG(base))
/*@}*/

/*
 * Constants & macros for individual LLWU_F3 bitfields
 */

/*!
 * @name Register LLWU_F3, field MWUF0[0] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 0 input was not a wakeup source
 * - 1 - Module 0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF0 field. */
#define LLWU_RD_F3_MWUF0(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF0_MASK) >> LLWU_F3_MWUF0_SHIFT)
#define LLWU_BRD_F3_MWUF0(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF0_SHIFT, LLWU_F3_MWUF0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF1[1] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 1 input was not a wakeup source
 * - 1 - Module 1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF1 field. */
#define LLWU_RD_F3_MWUF1(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF1_MASK) >> LLWU_F3_MWUF1_SHIFT)
#define LLWU_BRD_F3_MWUF1(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF1_SHIFT, LLWU_F3_MWUF1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF2[2] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 2 input was not a wakeup source
 * - 1 - Module 2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF2 field. */
#define LLWU_RD_F3_MWUF2(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF2_MASK) >> LLWU_F3_MWUF2_SHIFT)
#define LLWU_BRD_F3_MWUF2(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF2_SHIFT, LLWU_F3_MWUF2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF3[3] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 3 input was not a wakeup source
 * - 1 - Module 3 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF3 field. */
#define LLWU_RD_F3_MWUF3(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF3_MASK) >> LLWU_F3_MWUF3_SHIFT)
#define LLWU_BRD_F3_MWUF3(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF3_SHIFT, LLWU_F3_MWUF3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF4[4] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 4 input was not a wakeup source
 * - 1 - Module 4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF4 field. */
#define LLWU_RD_F3_MWUF4(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF4_MASK) >> LLWU_F3_MWUF4_SHIFT)
#define LLWU_BRD_F3_MWUF4(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF4_SHIFT, LLWU_F3_MWUF4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF5[5] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 5 input was not a wakeup source
 * - 1 - Module 5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF5 field. */
#define LLWU_RD_F3_MWUF5(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF5_MASK) >> LLWU_F3_MWUF5_SHIFT)
#define LLWU_BRD_F3_MWUF5(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF5_SHIFT, LLWU_F3_MWUF5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF6[6] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 6 input was not a wakeup source
 * - 1 - Module 6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF6 field. */
#define LLWU_RD_F3_MWUF6(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF6_MASK) >> LLWU_F3_MWUF6_SHIFT)
#define LLWU_BRD_F3_MWUF6(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF6_SHIFT, LLWU_F3_MWUF6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF7[7] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 7 input was not a wakeup source
 * - 1 - Module 7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF7 field. */
#define LLWU_RD_F3_MWUF7(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF7_MASK) >> LLWU_F3_MWUF7_SHIFT)
#define LLWU_BRD_F3_MWUF7(base) (BME_UBFX8(&LLWU_F3_REG(base), LLWU_F3_MWUF7_SHIFT, LLWU_F3_MWUF7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_FILT1 - LLWU Pin Filter 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT1 - LLWU Pin Filter 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT1 is a control and status register that is used to enable/disable
 * the digital filter 1 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT1 register
 */
/*@{*/
#define LLWU_RD_FILT1(base)      (LLWU_FILT1_REG(base))
#define LLWU_WR_FILT1(base, value) (LLWU_FILT1_REG(base) = (value))
#define LLWU_RMW_FILT1(base, mask, value) (LLWU_WR_FILT1(base, (LLWU_RD_FILT1(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT1(base, value) (BME_OR8(&LLWU_FILT1_REG(base), (uint8_t)(value)))
#define LLWU_CLR_FILT1(base, value) (BME_AND8(&LLWU_FILT1_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_FILT1(base, value) (BME_XOR8(&LLWU_FILT1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT1 bitfields
 */

/*!
 * @name Register LLWU_FILT1, field FILTSEL[3:0] (RW)
 *
 * Selects 1 out of the 16 wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0000 - Select LLWU_P0 for filter
 * - 1111 - Select LLWU_P15 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTSEL field. */
#define LLWU_RD_FILT1_FILTSEL(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTSEL_MASK) >> LLWU_FILT1_FILTSEL_SHIFT)
#define LLWU_BRD_FILT1_FILTSEL(base) (BME_UBFX8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTSEL_SHIFT, LLWU_FILT1_FILTSEL_WIDTH))

/*! @brief Set the FILTSEL field to a new value. */
#define LLWU_WR_FILT1_FILTSEL(base, value) (LLWU_RMW_FILT1(base, (LLWU_FILT1_FILTSEL_MASK | LLWU_FILT1_FILTF_MASK), LLWU_FILT1_FILTSEL(value)))
#define LLWU_BWR_FILT1_FILTSEL(base, value) (BME_BFI8(&LLWU_FILT1_REG(base), ((uint8_t)(value) << LLWU_FILT1_FILTSEL_SHIFT), LLWU_FILT1_FILTSEL_SHIFT, LLWU_FILT1_FILTSEL_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 00 - Filter disabled
 * - 01 - Filter posedge detect enabled
 * - 10 - Filter negedge detect enabled
 * - 11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTE field. */
#define LLWU_RD_FILT1_FILTE(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTE_MASK) >> LLWU_FILT1_FILTE_SHIFT)
#define LLWU_BRD_FILT1_FILTE(base) (BME_UBFX8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTE_SHIFT, LLWU_FILT1_FILTE_WIDTH))

/*! @brief Set the FILTE field to a new value. */
#define LLWU_WR_FILT1_FILTE(base, value) (LLWU_RMW_FILT1(base, (LLWU_FILT1_FILTE_MASK | LLWU_FILT1_FILTF_MASK), LLWU_FILT1_FILTE(value)))
#define LLWU_BWR_FILT1_FILTE(base, value) (BME_BFI8(&LLWU_FILT1_REG(base), ((uint8_t)(value) << LLWU_FILT1_FILTE_SHIFT), LLWU_FILT1_FILTE_SHIFT, LLWU_FILT1_FILTE_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0 - Pin Filter 1 was not a wakeup source
 * - 1 - Pin Filter 1 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTF field. */
#define LLWU_RD_FILT1_FILTF(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTF_MASK) >> LLWU_FILT1_FILTF_SHIFT)
#define LLWU_BRD_FILT1_FILTF(base) (BME_UBFX8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTF_SHIFT, LLWU_FILT1_FILTF_WIDTH))

/*! @brief Set the FILTF field to a new value. */
#define LLWU_WR_FILT1_FILTF(base, value) (LLWU_RMW_FILT1(base, LLWU_FILT1_FILTF_MASK, LLWU_FILT1_FILTF(value)))
#define LLWU_BWR_FILT1_FILTF(base, value) (BME_BFI8(&LLWU_FILT1_REG(base), ((uint8_t)(value) << LLWU_FILT1_FILTF_SHIFT), LLWU_FILT1_FILTF_SHIFT, LLWU_FILT1_FILTF_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_FILT2 - LLWU Pin Filter 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT2 - LLWU Pin Filter 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT2 is a control and status register that is used to enable/disable
 * the digital filter 2 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT2 register
 */
/*@{*/
#define LLWU_RD_FILT2(base)      (LLWU_FILT2_REG(base))
#define LLWU_WR_FILT2(base, value) (LLWU_FILT2_REG(base) = (value))
#define LLWU_RMW_FILT2(base, mask, value) (LLWU_WR_FILT2(base, (LLWU_RD_FILT2(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT2(base, value) (BME_OR8(&LLWU_FILT2_REG(base), (uint8_t)(value)))
#define LLWU_CLR_FILT2(base, value) (BME_AND8(&LLWU_FILT2_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_FILT2(base, value) (BME_XOR8(&LLWU_FILT2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT2 bitfields
 */

/*!
 * @name Register LLWU_FILT2, field FILTSEL[3:0] (RW)
 *
 * Selects 1 out of the 16 wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0000 - Select LLWU_P0 for filter
 * - 1111 - Select LLWU_P15 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTSEL field. */
#define LLWU_RD_FILT2_FILTSEL(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTSEL_MASK) >> LLWU_FILT2_FILTSEL_SHIFT)
#define LLWU_BRD_FILT2_FILTSEL(base) (BME_UBFX8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTSEL_SHIFT, LLWU_FILT2_FILTSEL_WIDTH))

/*! @brief Set the FILTSEL field to a new value. */
#define LLWU_WR_FILT2_FILTSEL(base, value) (LLWU_RMW_FILT2(base, (LLWU_FILT2_FILTSEL_MASK | LLWU_FILT2_FILTF_MASK), LLWU_FILT2_FILTSEL(value)))
#define LLWU_BWR_FILT2_FILTSEL(base, value) (BME_BFI8(&LLWU_FILT2_REG(base), ((uint8_t)(value) << LLWU_FILT2_FILTSEL_SHIFT), LLWU_FILT2_FILTSEL_SHIFT, LLWU_FILT2_FILTSEL_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 00 - Filter disabled
 * - 01 - Filter posedge detect enabled
 * - 10 - Filter negedge detect enabled
 * - 11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTE field. */
#define LLWU_RD_FILT2_FILTE(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTE_MASK) >> LLWU_FILT2_FILTE_SHIFT)
#define LLWU_BRD_FILT2_FILTE(base) (BME_UBFX8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTE_SHIFT, LLWU_FILT2_FILTE_WIDTH))

/*! @brief Set the FILTE field to a new value. */
#define LLWU_WR_FILT2_FILTE(base, value) (LLWU_RMW_FILT2(base, (LLWU_FILT2_FILTE_MASK | LLWU_FILT2_FILTF_MASK), LLWU_FILT2_FILTE(value)))
#define LLWU_BWR_FILT2_FILTE(base, value) (BME_BFI8(&LLWU_FILT2_REG(base), ((uint8_t)(value) << LLWU_FILT2_FILTE_SHIFT), LLWU_FILT2_FILTE_SHIFT, LLWU_FILT2_FILTE_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0 - Pin Filter 2 was not a wakeup source
 * - 1 - Pin Filter 2 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTF field. */
#define LLWU_RD_FILT2_FILTF(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTF_MASK) >> LLWU_FILT2_FILTF_SHIFT)
#define LLWU_BRD_FILT2_FILTF(base) (BME_UBFX8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTF_SHIFT, LLWU_FILT2_FILTF_WIDTH))

/*! @brief Set the FILTF field to a new value. */
#define LLWU_WR_FILT2_FILTF(base, value) (LLWU_RMW_FILT2(base, LLWU_FILT2_FILTF_MASK, LLWU_FILT2_FILTF(value)))
#define LLWU_BWR_FILT2_FILTF(base, value) (BME_BFI8(&LLWU_FILT2_REG(base), ((uint8_t)(value) << LLWU_FILT2_FILTF_SHIFT), LLWU_FILT2_FILTF_SHIFT, LLWU_FILT2_FILTF_WIDTH))
/*@}*/

/*
 * MKV10Z7 LPTMR
 *
 * Low Power Timer
 *
 * Registers defined in this header file:
 * - LPTMR_CSR - Low Power Timer Control Status Register
 * - LPTMR_PSR - Low Power Timer Prescale Register
 * - LPTMR_CMR - Low Power Timer Compare Register
 * - LPTMR_CNR - Low Power Timer Counter Register
 */

#define LPTMR_INSTANCE_COUNT (1U) /*!< Number of instances of the LPTMR module. */
#define LPTMR0_IDX (0U) /*!< Instance number for LPTMR0. */

/*******************************************************************************
 * LPTMR_CSR - Low Power Timer Control Status Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CSR - Low Power Timer Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CSR register
 */
/*@{*/
#define LPTMR_RD_CSR(base)       (LPTMR_CSR_REG(base))
#define LPTMR_WR_CSR(base, value) (LPTMR_CSR_REG(base) = (value))
#define LPTMR_RMW_CSR(base, mask, value) (LPTMR_WR_CSR(base, (LPTMR_RD_CSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CSR(base, value) (BME_OR32(&LPTMR_CSR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CSR(base, value) (BME_AND32(&LPTMR_CSR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CSR(base, value) (BME_XOR32(&LPTMR_CSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CSR bitfields
 */

/*!
 * @name Register LPTMR_CSR, field TEN[0] (RW)
 *
 * When TEN is clear, it resets the LPTMR internal logic, including the CNR and
 * TCF. When TEN is set, the LPTMR is enabled. While writing 1 to this field,
 * CSR[5:1] must not be altered.
 *
 * Values:
 * - 0 - LPTMR is disabled and internal logic is reset.
 * - 1 - LPTMR is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TEN field. */
#define LPTMR_RD_CSR_TEN(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TEN_MASK) >> LPTMR_CSR_TEN_SHIFT)
#define LPTMR_BRD_CSR_TEN(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TEN_SHIFT, LPTMR_CSR_TEN_WIDTH))

/*! @brief Set the TEN field to a new value. */
#define LPTMR_WR_CSR_TEN(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TEN_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TEN(value)))
#define LPTMR_BWR_CSR_TEN(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TEN_SHIFT), LPTMR_CSR_TEN_SHIFT, LPTMR_CSR_TEN_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TMS[1] (RW)
 *
 * Configures the mode of the LPTMR. TMS must be altered only when the LPTMR is
 * disabled.
 *
 * Values:
 * - 0 - Time Counter mode.
 * - 1 - Pulse Counter mode.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TMS field. */
#define LPTMR_RD_CSR_TMS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TMS_MASK) >> LPTMR_CSR_TMS_SHIFT)
#define LPTMR_BRD_CSR_TMS(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TMS_SHIFT, LPTMR_CSR_TMS_WIDTH))

/*! @brief Set the TMS field to a new value. */
#define LPTMR_WR_CSR_TMS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TMS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TMS(value)))
#define LPTMR_BWR_CSR_TMS(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TMS_SHIFT), LPTMR_CSR_TMS_SHIFT, LPTMR_CSR_TMS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TFC[2] (RW)
 *
 * When clear, TFC configures the CNR to reset whenever TCF is set. When set,
 * TFC configures the CNR to reset on overflow. TFC must be altered only when the
 * LPTMR is disabled.
 *
 * Values:
 * - 0 - CNR is reset whenever TCF is set.
 * - 1 - CNR is reset on overflow.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TFC field. */
#define LPTMR_RD_CSR_TFC(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TFC_MASK) >> LPTMR_CSR_TFC_SHIFT)
#define LPTMR_BRD_CSR_TFC(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TFC_SHIFT, LPTMR_CSR_TFC_WIDTH))

/*! @brief Set the TFC field to a new value. */
#define LPTMR_WR_CSR_TFC(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TFC_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TFC(value)))
#define LPTMR_BWR_CSR_TFC(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TFC_SHIFT), LPTMR_CSR_TFC_SHIFT, LPTMR_CSR_TFC_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPP[3] (RW)
 *
 * Configures the polarity of the input source in Pulse Counter mode. TPP must
 * be changed only when the LPTMR is disabled.
 *
 * Values:
 * - 0 - Pulse Counter input source is active-high, and the CNR will increment
 *     on the rising-edge.
 * - 1 - Pulse Counter input source is active-low, and the CNR will increment on
 *     the falling-edge.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPP field. */
#define LPTMR_RD_CSR_TPP(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPP_MASK) >> LPTMR_CSR_TPP_SHIFT)
#define LPTMR_BRD_CSR_TPP(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPP_SHIFT, LPTMR_CSR_TPP_WIDTH))

/*! @brief Set the TPP field to a new value. */
#define LPTMR_WR_CSR_TPP(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPP_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPP(value)))
#define LPTMR_BWR_CSR_TPP(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TPP_SHIFT), LPTMR_CSR_TPP_SHIFT, LPTMR_CSR_TPP_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPS[5:4] (RW)
 *
 * Configures the input source to be used in Pulse Counter mode. TPS must be
 * altered only when the LPTMR is disabled. The input connections vary by device.
 * See the chip configuration details for information on the connections to these
 * inputs.
 *
 * Values:
 * - 00 - Pulse counter input 0 is selected.
 * - 01 - Pulse counter input 1 is selected.
 * - 10 - Pulse counter input 2 is selected.
 * - 11 - Pulse counter input 3 is selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPS field. */
#define LPTMR_RD_CSR_TPS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPS_MASK) >> LPTMR_CSR_TPS_SHIFT)
#define LPTMR_BRD_CSR_TPS(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPS_SHIFT, LPTMR_CSR_TPS_WIDTH))

/*! @brief Set the TPS field to a new value. */
#define LPTMR_WR_CSR_TPS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPS(value)))
#define LPTMR_BWR_CSR_TPS(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TPS_SHIFT), LPTMR_CSR_TPS_SHIFT, LPTMR_CSR_TPS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TIE[6] (RW)
 *
 * When TIE is set, the LPTMR Interrupt is generated whenever TCF is also set.
 *
 * Values:
 * - 0 - Timer interrupt disabled.
 * - 1 - Timer interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TIE field. */
#define LPTMR_RD_CSR_TIE(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TIE_MASK) >> LPTMR_CSR_TIE_SHIFT)
#define LPTMR_BRD_CSR_TIE(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TIE_SHIFT, LPTMR_CSR_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define LPTMR_WR_CSR_TIE(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TIE_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TIE(value)))
#define LPTMR_BWR_CSR_TIE(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TIE_SHIFT), LPTMR_CSR_TIE_SHIFT, LPTMR_CSR_TIE_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TCF[7] (W1C)
 *
 * TCF is set when the LPTMR is enabled and the CNR equals the CMR and
 * increments. TCF is cleared when the LPTMR is disabled or a logic 1 is written to it.
 *
 * Values:
 * - 0 - The value of CNR is not equal to CMR and increments.
 * - 1 - The value of CNR is equal to CMR and increments.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TCF field. */
#define LPTMR_RD_CSR_TCF(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TCF_MASK) >> LPTMR_CSR_TCF_SHIFT)
#define LPTMR_BRD_CSR_TCF(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TCF_SHIFT, LPTMR_CSR_TCF_WIDTH))

/*! @brief Set the TCF field to a new value. */
#define LPTMR_WR_CSR_TCF(base, value) (LPTMR_RMW_CSR(base, LPTMR_CSR_TCF_MASK, LPTMR_CSR_TCF(value)))
#define LPTMR_BWR_CSR_TCF(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TCF_SHIFT), LPTMR_CSR_TCF_SHIFT, LPTMR_CSR_TCF_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_PSR - Low Power Timer Prescale Register
 ******************************************************************************/

/*!
 * @brief LPTMR_PSR - Low Power Timer Prescale Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_PSR register
 */
/*@{*/
#define LPTMR_RD_PSR(base)       (LPTMR_PSR_REG(base))
#define LPTMR_WR_PSR(base, value) (LPTMR_PSR_REG(base) = (value))
#define LPTMR_RMW_PSR(base, mask, value) (LPTMR_WR_PSR(base, (LPTMR_RD_PSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_PSR(base, value) (BME_OR32(&LPTMR_PSR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_PSR(base, value) (BME_AND32(&LPTMR_PSR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_PSR(base, value) (BME_XOR32(&LPTMR_PSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_PSR bitfields
 */

/*!
 * @name Register LPTMR_PSR, field PCS[1:0] (RW)
 *
 * Selects the clock to be used by the LPTMR prescaler/glitch filter. PCS must
 * be altered only when the LPTMR is disabled. The clock connections vary by
 * device. See the chip configuration details for information on the connections to
 * these inputs.
 *
 * Values:
 * - 00 - Prescaler/glitch filter clock 0 selected.
 * - 01 - Prescaler/glitch filter clock 1 selected.
 * - 10 - Prescaler/glitch filter clock 2 selected.
 * - 11 - Prescaler/glitch filter clock 3 selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PCS field. */
#define LPTMR_RD_PSR_PCS(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PCS_MASK) >> LPTMR_PSR_PCS_SHIFT)
#define LPTMR_BRD_PSR_PCS(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PCS_SHIFT, LPTMR_PSR_PCS_WIDTH))

/*! @brief Set the PCS field to a new value. */
#define LPTMR_WR_PSR_PCS(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PCS_MASK, LPTMR_PSR_PCS(value)))
#define LPTMR_BWR_PSR_PCS(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PCS_SHIFT), LPTMR_PSR_PCS_SHIFT, LPTMR_PSR_PCS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PBYP[2] (RW)
 *
 * When PBYP is set, the selected prescaler clock in Time Counter mode or
 * selected input source in Pulse Counter mode directly clocks the CNR. When PBYP is
 * clear, the CNR is clocked by the output of the prescaler/glitch filter. PBYP
 * must be altered only when the LPTMR is disabled.
 *
 * Values:
 * - 0 - Prescaler/glitch filter is enabled.
 * - 1 - Prescaler/glitch filter is bypassed.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PBYP field. */
#define LPTMR_RD_PSR_PBYP(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PBYP_MASK) >> LPTMR_PSR_PBYP_SHIFT)
#define LPTMR_BRD_PSR_PBYP(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PBYP_SHIFT, LPTMR_PSR_PBYP_WIDTH))

/*! @brief Set the PBYP field to a new value. */
#define LPTMR_WR_PSR_PBYP(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PBYP_MASK, LPTMR_PSR_PBYP(value)))
#define LPTMR_BWR_PSR_PBYP(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PBYP_SHIFT), LPTMR_PSR_PBYP_SHIFT, LPTMR_PSR_PBYP_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PRESCALE[6:3] (RW)
 *
 * Configures the size of the Prescaler in Time Counter mode or width of the
 * glitch filter in Pulse Counter mode. PRESCALE must be altered only when the LPTMR
 * is disabled.
 *
 * Values:
 * - 0000 - Prescaler divides the prescaler clock by 2; glitch filter does not
 *     support this configuration.
 * - 0001 - Prescaler divides the prescaler clock by 4; glitch filter recognizes
 *     change on input pin after 2 rising clock edges.
 * - 0010 - Prescaler divides the prescaler clock by 8; glitch filter recognizes
 *     change on input pin after 4 rising clock edges.
 * - 0011 - Prescaler divides the prescaler clock by 16; glitch filter
 *     recognizes change on input pin after 8 rising clock edges.
 * - 0100 - Prescaler divides the prescaler clock by 32; glitch filter
 *     recognizes change on input pin after 16 rising clock edges.
 * - 0101 - Prescaler divides the prescaler clock by 64; glitch filter
 *     recognizes change on input pin after 32 rising clock edges.
 * - 0110 - Prescaler divides the prescaler clock by 128; glitch filter
 *     recognizes change on input pin after 64 rising clock edges.
 * - 0111 - Prescaler divides the prescaler clock by 256; glitch filter
 *     recognizes change on input pin after 128 rising clock edges.
 * - 1000 - Prescaler divides the prescaler clock by 512; glitch filter
 *     recognizes change on input pin after 256 rising clock edges.
 * - 1001 - Prescaler divides the prescaler clock by 1024; glitch filter
 *     recognizes change on input pin after 512 rising clock edges.
 * - 1010 - Prescaler divides the prescaler clock by 2048; glitch filter
 *     recognizes change on input pin after 1024 rising clock edges.
 * - 1011 - Prescaler divides the prescaler clock by 4096; glitch filter
 *     recognizes change on input pin after 2048 rising clock edges.
 * - 1100 - Prescaler divides the prescaler clock by 8192; glitch filter
 *     recognizes change on input pin after 4096 rising clock edges.
 * - 1101 - Prescaler divides the prescaler clock by 16,384; glitch filter
 *     recognizes change on input pin after 8192 rising clock edges.
 * - 1110 - Prescaler divides the prescaler clock by 32,768; glitch filter
 *     recognizes change on input pin after 16,384 rising clock edges.
 * - 1111 - Prescaler divides the prescaler clock by 65,536; glitch filter
 *     recognizes change on input pin after 32,768 rising clock edges.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PRESCALE field. */
#define LPTMR_RD_PSR_PRESCALE(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PRESCALE_MASK) >> LPTMR_PSR_PRESCALE_SHIFT)
#define LPTMR_BRD_PSR_PRESCALE(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PRESCALE_SHIFT, LPTMR_PSR_PRESCALE_WIDTH))

/*! @brief Set the PRESCALE field to a new value. */
#define LPTMR_WR_PSR_PRESCALE(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PRESCALE_MASK, LPTMR_PSR_PRESCALE(value)))
#define LPTMR_BWR_PSR_PRESCALE(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PRESCALE_SHIFT), LPTMR_PSR_PRESCALE_SHIFT, LPTMR_PSR_PRESCALE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_CMR - Low Power Timer Compare Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CMR - Low Power Timer Compare Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CMR register
 */
/*@{*/
#define LPTMR_RD_CMR(base)       (LPTMR_CMR_REG(base))
#define LPTMR_WR_CMR(base, value) (LPTMR_CMR_REG(base) = (value))
#define LPTMR_RMW_CMR(base, mask, value) (LPTMR_WR_CMR(base, (LPTMR_RD_CMR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CMR(base, value) (BME_OR32(&LPTMR_CMR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CMR(base, value) (BME_AND32(&LPTMR_CMR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CMR(base, value) (BME_XOR32(&LPTMR_CMR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CMR bitfields
 */

/*!
 * @name Register LPTMR_CMR, field COMPARE[15:0] (RW)
 *
 * When the LPTMR is enabled and the CNR equals the value in the CMR and
 * increments, TCF is set and the hardware trigger asserts until the next time the CNR
 * increments. If the CMR is 0, the hardware trigger will remain asserted until
 * the LPTMR is disabled. If the LPTMR is enabled, the CMR must be altered only
 * when TCF is set.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CMR_COMPARE field. */
#define LPTMR_RD_CMR_COMPARE(base) ((LPTMR_CMR_REG(base) & LPTMR_CMR_COMPARE_MASK) >> LPTMR_CMR_COMPARE_SHIFT)
#define LPTMR_BRD_CMR_COMPARE(base) (BME_UBFX32(&LPTMR_CMR_REG(base), LPTMR_CMR_COMPARE_SHIFT, LPTMR_CMR_COMPARE_WIDTH))

/*! @brief Set the COMPARE field to a new value. */
#define LPTMR_WR_CMR_COMPARE(base, value) (LPTMR_RMW_CMR(base, LPTMR_CMR_COMPARE_MASK, LPTMR_CMR_COMPARE(value)))
#define LPTMR_BWR_CMR_COMPARE(base, value) (BME_BFI32(&LPTMR_CMR_REG(base), ((uint32_t)(value) << LPTMR_CMR_COMPARE_SHIFT), LPTMR_CMR_COMPARE_SHIFT, LPTMR_CMR_COMPARE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_CNR - Low Power Timer Counter Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CNR - Low Power Timer Counter Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CNR register
 */
/*@{*/
#define LPTMR_RD_CNR(base)       (LPTMR_CNR_REG(base))
#define LPTMR_WR_CNR(base, value) (LPTMR_CNR_REG(base) = (value))
#define LPTMR_RMW_CNR(base, mask, value) (LPTMR_WR_CNR(base, (LPTMR_RD_CNR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CNR(base, value) (BME_OR32(&LPTMR_CNR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CNR(base, value) (BME_AND32(&LPTMR_CNR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CNR(base, value) (BME_XOR32(&LPTMR_CNR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CNR bitfields
 */

/*!
 * @name Register LPTMR_CNR, field COUNTER[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CNR_COUNTER field. */
#define LPTMR_RD_CNR_COUNTER(base) ((LPTMR_CNR_REG(base) & LPTMR_CNR_COUNTER_MASK) >> LPTMR_CNR_COUNTER_SHIFT)
#define LPTMR_BRD_CNR_COUNTER(base) (BME_UBFX32(&LPTMR_CNR_REG(base), LPTMR_CNR_COUNTER_SHIFT, LPTMR_CNR_COUNTER_WIDTH))

/*! @brief Set the COUNTER field to a new value. */
#define LPTMR_WR_CNR_COUNTER(base, value) (LPTMR_RMW_CNR(base, LPTMR_CNR_COUNTER_MASK, LPTMR_CNR_COUNTER(value)))
#define LPTMR_BWR_CNR_COUNTER(base, value) (BME_BFI32(&LPTMR_CNR_REG(base), ((uint32_t)(value) << LPTMR_CNR_COUNTER_SHIFT), LPTMR_CNR_COUNTER_SHIFT, LPTMR_CNR_COUNTER_WIDTH))
/*@}*/

/*
 * MKV10Z7 MCG
 *
 * Multipurpose Clock Generator module
 *
 * Registers defined in this header file:
 * - MCG_C1 - MCG Control 1 Register
 * - MCG_C2 - MCG Control 2 Register
 * - MCG_C3 - MCG Control 3 Register
 * - MCG_C4 - MCG Control 4 Register
 * - MCG_C6 - MCG Control 6 Register
 * - MCG_S - MCG Status Register
 * - MCG_SC - MCG Status and Control Register
 * - MCG_ATCVH - MCG Auto Trim Compare Value High Register
 * - MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 */

#define MCG_INSTANCE_COUNT (1U) /*!< Number of instances of the MCG module. */
#define MCG_IDX (0U) /*!< Instance number for MCG. */

/*******************************************************************************
 * MCG_C1 - MCG Control 1 Register
 ******************************************************************************/

/*!
 * @brief MCG_C1 - MCG Control 1 Register (RW)
 *
 * Reset value: 0x04U
 */
/*!
 * @name Constants and macros for entire MCG_C1 register
 */
/*@{*/
#define MCG_RD_C1(base)          (MCG_C1_REG(base))
#define MCG_WR_C1(base, value)   (MCG_C1_REG(base) = (value))
#define MCG_RMW_C1(base, mask, value) (MCG_WR_C1(base, (MCG_RD_C1(base) & ~(mask)) | (value)))
#define MCG_SET_C1(base, value)  (BME_OR8(&MCG_C1_REG(base), (uint8_t)(value)))
#define MCG_CLR_C1(base, value)  (BME_AND8(&MCG_C1_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C1(base, value)  (BME_XOR8(&MCG_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C1 bitfields
 */

/*!
 * @name Register MCG_C1, field IREFSTEN[0] (RW)
 *
 * Controls whether or not the internal reference clock remains enabled when the
 * MCG enters Stop mode.
 *
 * Values:
 * - 0 - Internal reference clock is disabled in Stop mode.
 * - 1 - Internal reference clock is enabled in Stop mode if IRCLKEN is set or
 *     if MCG is in FEI, FBI, or BLPI modes before entering Stop mode.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IREFSTEN field. */
#define MCG_RD_C1_IREFSTEN(base) ((MCG_C1_REG(base) & MCG_C1_IREFSTEN_MASK) >> MCG_C1_IREFSTEN_SHIFT)
#define MCG_BRD_C1_IREFSTEN(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_IREFSTEN_SHIFT, MCG_C1_IREFSTEN_WIDTH))

/*! @brief Set the IREFSTEN field to a new value. */
#define MCG_WR_C1_IREFSTEN(base, value) (MCG_RMW_C1(base, MCG_C1_IREFSTEN_MASK, MCG_C1_IREFSTEN(value)))
#define MCG_BWR_C1_IREFSTEN(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_IREFSTEN_SHIFT), MCG_C1_IREFSTEN_SHIFT, MCG_C1_IREFSTEN_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field IRCLKEN[1] (RW)
 *
 * Enables the internal reference clock for use as MCGIRCLK.
 *
 * Values:
 * - 0 - MCGIRCLK inactive.
 * - 1 - MCGIRCLK active.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IRCLKEN field. */
#define MCG_RD_C1_IRCLKEN(base) ((MCG_C1_REG(base) & MCG_C1_IRCLKEN_MASK) >> MCG_C1_IRCLKEN_SHIFT)
#define MCG_BRD_C1_IRCLKEN(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_IRCLKEN_SHIFT, MCG_C1_IRCLKEN_WIDTH))

/*! @brief Set the IRCLKEN field to a new value. */
#define MCG_WR_C1_IRCLKEN(base, value) (MCG_RMW_C1(base, MCG_C1_IRCLKEN_MASK, MCG_C1_IRCLKEN(value)))
#define MCG_BWR_C1_IRCLKEN(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_IRCLKEN_SHIFT), MCG_C1_IRCLKEN_SHIFT, MCG_C1_IRCLKEN_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field IREFS[2] (RW)
 *
 * Selects the reference clock source for the FLL.
 *
 * Values:
 * - 0 - External reference clock is selected.
 * - 1 - The slow internal reference clock is selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IREFS field. */
#define MCG_RD_C1_IREFS(base) ((MCG_C1_REG(base) & MCG_C1_IREFS_MASK) >> MCG_C1_IREFS_SHIFT)
#define MCG_BRD_C1_IREFS(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_IREFS_SHIFT, MCG_C1_IREFS_WIDTH))

/*! @brief Set the IREFS field to a new value. */
#define MCG_WR_C1_IREFS(base, value) (MCG_RMW_C1(base, MCG_C1_IREFS_MASK, MCG_C1_IREFS(value)))
#define MCG_BWR_C1_IREFS(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_IREFS_SHIFT), MCG_C1_IREFS_SHIFT, MCG_C1_IREFS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field FRDIV[5:3] (RW)
 *
 * Selects the amount to divide down the external reference clock for the FLL.
 * The resulting frequency must be in the range 31.25 kHz to 39.0625 kHz (This is
 * required when FLL/DCO is the clock source for MCGOUTCLK . In FBE mode, it is
 * not required to meet this range, but it is recommended in the cases when trying
 * to enter a FLL mode from FBE).
 *
 * Values:
 * - 000 - If RANGE = 0 , Divide Factor is 1; for all other RANGE values, Divide
 *     Factor is 32.
 * - 001 - If RANGE = 0 , Divide Factor is 2; for all other RANGE values, Divide
 *     Factor is 64.
 * - 010 - If RANGE = 0 , Divide Factor is 4; for all other RANGE values, Divide
 *     Factor is 128.
 * - 011 - If RANGE = 0 , Divide Factor is 8; for all other RANGE values, Divide
 *     Factor is 256.
 * - 100 - If RANGE = 0 , Divide Factor is 16; for all other RANGE values,
 *     Divide Factor is 512.
 * - 101 - If RANGE = 0 , Divide Factor is 32; for all other RANGE values,
 *     Divide Factor is 1024.
 * - 110 - If RANGE = 0 , Divide Factor is 64; for all other RANGE values,
 *     Divide Factor is 1280 .
 * - 111 - If RANGE = 0 , Divide Factor is 128; for all other RANGE values,
 *     Divide Factor is 1536 .
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_FRDIV field. */
#define MCG_RD_C1_FRDIV(base) ((MCG_C1_REG(base) & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)
#define MCG_BRD_C1_FRDIV(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_FRDIV_SHIFT, MCG_C1_FRDIV_WIDTH))

/*! @brief Set the FRDIV field to a new value. */
#define MCG_WR_C1_FRDIV(base, value) (MCG_RMW_C1(base, MCG_C1_FRDIV_MASK, MCG_C1_FRDIV(value)))
#define MCG_BWR_C1_FRDIV(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_FRDIV_SHIFT), MCG_C1_FRDIV_SHIFT, MCG_C1_FRDIV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field CLKS[7:6] (RW)
 *
 * Selects the clock source for MCGOUTCLK .
 *
 * Values:
 * - 00 - Encoding 0 - Output of FLL is selected.
 * - 01 - Encoding 1 - Internal reference clock is selected.
 * - 10 - Encoding 2 - External reference clock is selected.
 * - 11 - Encoding 3 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_CLKS field. */
#define MCG_RD_C1_CLKS(base) ((MCG_C1_REG(base) & MCG_C1_CLKS_MASK) >> MCG_C1_CLKS_SHIFT)
#define MCG_BRD_C1_CLKS(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_CLKS_SHIFT, MCG_C1_CLKS_WIDTH))

/*! @brief Set the CLKS field to a new value. */
#define MCG_WR_C1_CLKS(base, value) (MCG_RMW_C1(base, MCG_C1_CLKS_MASK, MCG_C1_CLKS(value)))
#define MCG_BWR_C1_CLKS(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_CLKS_SHIFT), MCG_C1_CLKS_SHIFT, MCG_C1_CLKS_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C2 - MCG Control 2 Register
 ******************************************************************************/

/*!
 * @brief MCG_C2 - MCG Control 2 Register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire MCG_C2 register
 */
/*@{*/
#define MCG_RD_C2(base)          (MCG_C2_REG(base))
#define MCG_WR_C2(base, value)   (MCG_C2_REG(base) = (value))
#define MCG_RMW_C2(base, mask, value) (MCG_WR_C2(base, (MCG_RD_C2(base) & ~(mask)) | (value)))
#define MCG_SET_C2(base, value)  (BME_OR8(&MCG_C2_REG(base), (uint8_t)(value)))
#define MCG_CLR_C2(base, value)  (BME_AND8(&MCG_C2_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C2(base, value)  (BME_XOR8(&MCG_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C2 bitfields
 */

/*!
 * @name Register MCG_C2, field IRCS[0] (RW)
 *
 * Selects between the fast or slow internal reference clock source.
 *
 * Values:
 * - 0 - Slow internal reference clock selected.
 * - 1 - Fast internal reference clock selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_IRCS field. */
#define MCG_RD_C2_IRCS(base) ((MCG_C2_REG(base) & MCG_C2_IRCS_MASK) >> MCG_C2_IRCS_SHIFT)
#define MCG_BRD_C2_IRCS(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_IRCS_SHIFT, MCG_C2_IRCS_WIDTH))

/*! @brief Set the IRCS field to a new value. */
#define MCG_WR_C2_IRCS(base, value) (MCG_RMW_C2(base, MCG_C2_IRCS_MASK, MCG_C2_IRCS(value)))
#define MCG_BWR_C2_IRCS(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_IRCS_SHIFT), MCG_C2_IRCS_SHIFT, MCG_C2_IRCS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field LP[1] (RW)
 *
 * Controls whether the FLL is disabled in BLPI and BLPE modes. In FBE mode,
 * setting this bit to 1 will transition the MCG into BLPE mode; in FBI mode,
 * setting this bit to 1 will transition the MCG into BLPI mode. In any other MCG mode,
 * LP bit has no affect.
 *
 * Values:
 * - 0 - FLL is not disabled in bypass modes.
 * - 1 - FLL is disabled in bypass modes (lower power)
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_LP field. */
#define MCG_RD_C2_LP(base)   ((MCG_C2_REG(base) & MCG_C2_LP_MASK) >> MCG_C2_LP_SHIFT)
#define MCG_BRD_C2_LP(base)  (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_LP_SHIFT, MCG_C2_LP_WIDTH))

/*! @brief Set the LP field to a new value. */
#define MCG_WR_C2_LP(base, value) (MCG_RMW_C2(base, MCG_C2_LP_MASK, MCG_C2_LP(value)))
#define MCG_BWR_C2_LP(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_LP_SHIFT), MCG_C2_LP_SHIFT, MCG_C2_LP_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field EREFS[2] (RW)
 *
 * Selects the source for the external reference clock. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0 - External reference clock requested.
 * - 1 - Oscillator requested.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_EREFS field. */
#define MCG_RD_C2_EREFS(base) ((MCG_C2_REG(base) & MCG_C2_EREFS_MASK) >> MCG_C2_EREFS_SHIFT)
#define MCG_BRD_C2_EREFS(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_EREFS_SHIFT, MCG_C2_EREFS_WIDTH))

/*! @brief Set the EREFS field to a new value. */
#define MCG_WR_C2_EREFS(base, value) (MCG_RMW_C2(base, MCG_C2_EREFS_MASK, MCG_C2_EREFS(value)))
#define MCG_BWR_C2_EREFS(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_EREFS_SHIFT), MCG_C2_EREFS_SHIFT, MCG_C2_EREFS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field HGO[3] (RW)
 *
 * Controls the crystal oscillator mode of operation. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0 - Configure crystal oscillator for low-power operation.
 * - 1 - Configure crystal oscillator for high-gain operation.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_HGO field. */
#define MCG_RD_C2_HGO(base)  ((MCG_C2_REG(base) & MCG_C2_HGO_MASK) >> MCG_C2_HGO_SHIFT)
#define MCG_BRD_C2_HGO(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_HGO_SHIFT, MCG_C2_HGO_WIDTH))

/*! @brief Set the HGO field to a new value. */
#define MCG_WR_C2_HGO(base, value) (MCG_RMW_C2(base, MCG_C2_HGO_MASK, MCG_C2_HGO(value)))
#define MCG_BWR_C2_HGO(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_HGO_SHIFT), MCG_C2_HGO_SHIFT, MCG_C2_HGO_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field RANGE[5:4] (RW)
 *
 * Selects the frequency range for the crystal oscillator or external clock
 * source. See the Oscillator (OSC) chapter for more details and the device data
 * sheet for the frequency ranges used.
 *
 * Values:
 * - 00 - Encoding 0 - Low frequency range selected for the crystal oscillator .
 * - 01 - Encoding 1 - High frequency range selected for the crystal oscillator .
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_RANGE field. */
#define MCG_RD_C2_RANGE(base) ((MCG_C2_REG(base) & MCG_C2_RANGE_MASK) >> MCG_C2_RANGE_SHIFT)
#define MCG_BRD_C2_RANGE(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_RANGE_SHIFT, MCG_C2_RANGE_WIDTH))

/*! @brief Set the RANGE field to a new value. */
#define MCG_WR_C2_RANGE(base, value) (MCG_RMW_C2(base, MCG_C2_RANGE_MASK, MCG_C2_RANGE(value)))
#define MCG_BWR_C2_RANGE(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_RANGE_SHIFT), MCG_C2_RANGE_SHIFT, MCG_C2_RANGE_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field FCFTRIM[6] (RW)
 *
 * FCFTRIM controls the smallest adjustment of the fast internal reference clock
 * frequency. Setting FCFTRIM increases the period and clearing FCFTRIM
 * decreases the period by the smallest amount possible. If an FCFTRIM value stored in
 * nonvolatile memory is to be used, it is your responsibility to copy that value
 * from the nonvolatile memory location to this bit.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_FCFTRIM field. */
#define MCG_RD_C2_FCFTRIM(base) ((MCG_C2_REG(base) & MCG_C2_FCFTRIM_MASK) >> MCG_C2_FCFTRIM_SHIFT)
#define MCG_BRD_C2_FCFTRIM(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_FCFTRIM_SHIFT, MCG_C2_FCFTRIM_WIDTH))

/*! @brief Set the FCFTRIM field to a new value. */
#define MCG_WR_C2_FCFTRIM(base, value) (MCG_RMW_C2(base, MCG_C2_FCFTRIM_MASK, MCG_C2_FCFTRIM(value)))
#define MCG_BWR_C2_FCFTRIM(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_FCFTRIM_SHIFT), MCG_C2_FCFTRIM_SHIFT, MCG_C2_FCFTRIM_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field LOCRE0[7] (RW)
 *
 * Determines whether an interrupt or a reset request is made following a loss
 * of OSC0 external reference clock. The LOCRE0 only has an affect when CME0 is
 * set.
 *
 * Values:
 * - 0 - Interrupt request is generated on a loss of OSC0 external reference
 *     clock.
 * - 1 - Generate a reset request on a loss of OSC0 external reference clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_LOCRE0 field. */
#define MCG_RD_C2_LOCRE0(base) ((MCG_C2_REG(base) & MCG_C2_LOCRE0_MASK) >> MCG_C2_LOCRE0_SHIFT)
#define MCG_BRD_C2_LOCRE0(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_LOCRE0_SHIFT, MCG_C2_LOCRE0_WIDTH))

/*! @brief Set the LOCRE0 field to a new value. */
#define MCG_WR_C2_LOCRE0(base, value) (MCG_RMW_C2(base, MCG_C2_LOCRE0_MASK, MCG_C2_LOCRE0(value)))
#define MCG_BWR_C2_LOCRE0(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_LOCRE0_SHIFT), MCG_C2_LOCRE0_SHIFT, MCG_C2_LOCRE0_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C3 - MCG Control 3 Register
 ******************************************************************************/

/*!
 * @brief MCG_C3 - MCG Control 3 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C3 register
 */
/*@{*/
#define MCG_RD_C3(base)          (MCG_C3_REG(base))
#define MCG_WR_C3(base, value)   (MCG_C3_REG(base) = (value))
#define MCG_RMW_C3(base, mask, value) (MCG_WR_C3(base, (MCG_RD_C3(base) & ~(mask)) | (value)))
#define MCG_SET_C3(base, value)  (BME_OR8(&MCG_C3_REG(base), (uint8_t)(value)))
#define MCG_CLR_C3(base, value)  (BME_AND8(&MCG_C3_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C3(base, value)  (BME_XOR8(&MCG_C3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * MCG_C4 - MCG Control 4 Register
 ******************************************************************************/

/*!
 * @brief MCG_C4 - MCG Control 4 Register (RW)
 *
 * Reset value: 0x00U
 *
 * Reset values for DRST and DMX32 bits are 0.
 */
/*!
 * @name Constants and macros for entire MCG_C4 register
 */
/*@{*/
#define MCG_RD_C4(base)          (MCG_C4_REG(base))
#define MCG_WR_C4(base, value)   (MCG_C4_REG(base) = (value))
#define MCG_RMW_C4(base, mask, value) (MCG_WR_C4(base, (MCG_RD_C4(base) & ~(mask)) | (value)))
#define MCG_SET_C4(base, value)  (BME_OR8(&MCG_C4_REG(base), (uint8_t)(value)))
#define MCG_CLR_C4(base, value)  (BME_AND8(&MCG_C4_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C4(base, value)  (BME_XOR8(&MCG_C4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C4 bitfields
 */

/*!
 * @name Register MCG_C4, field SCFTRIM[0] (RW)
 *
 * SCFTRIM A value for SCFTRIM is loaded during reset from a factory programmed
 * location . controls the smallest adjustment of the slow internal reference
 * clock frequency. Setting SCFTRIM increases the period and clearing SCFTRIM
 * decreases the period by the smallest amount possible. If an SCFTRIM value stored in
 * nonvolatile memory is to be used, it is your responsibility to copy that value
 * from the nonvolatile memory location to this bit.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_SCFTRIM field. */
#define MCG_RD_C4_SCFTRIM(base) ((MCG_C4_REG(base) & MCG_C4_SCFTRIM_MASK) >> MCG_C4_SCFTRIM_SHIFT)
#define MCG_BRD_C4_SCFTRIM(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_SCFTRIM_SHIFT, MCG_C4_SCFTRIM_WIDTH))

/*! @brief Set the SCFTRIM field to a new value. */
#define MCG_WR_C4_SCFTRIM(base, value) (MCG_RMW_C4(base, MCG_C4_SCFTRIM_MASK, MCG_C4_SCFTRIM(value)))
#define MCG_BWR_C4_SCFTRIM(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_SCFTRIM_SHIFT), MCG_C4_SCFTRIM_SHIFT, MCG_C4_SCFTRIM_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C4, field FCTRIM[4:1] (RW)
 *
 * FCTRIM A value for FCTRIM is loaded during reset from a factory programmed
 * location. controls the fast internal reference clock frequency by controlling
 * the fast internal reference clock period. The FCTRIM bits are binary weighted,
 * that is, bit 1 adjusts twice as much as bit 0. Increasing the binary value
 * increases the period, and decreasing the value decreases the period. If an
 * FCTRIM[3:0] value stored in nonvolatile memory is to be used, it is your
 * responsibility to copy that value from the nonvolatile memory location to this register.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_FCTRIM field. */
#define MCG_RD_C4_FCTRIM(base) ((MCG_C4_REG(base) & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT)
#define MCG_BRD_C4_FCTRIM(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_FCTRIM_SHIFT, MCG_C4_FCTRIM_WIDTH))

/*! @brief Set the FCTRIM field to a new value. */
#define MCG_WR_C4_FCTRIM(base, value) (MCG_RMW_C4(base, MCG_C4_FCTRIM_MASK, MCG_C4_FCTRIM(value)))
#define MCG_BWR_C4_FCTRIM(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_FCTRIM_SHIFT), MCG_C4_FCTRIM_SHIFT, MCG_C4_FCTRIM_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C4, field DRST_DRS[6:5] (RW)
 *
 * The DRS bits select the frequency range for the FLL output, DCOOUT. When the
 * LP bit is set, writes to the DRS bits are ignored. The DRST read field
 * indicates the current frequency range for DCOOUT. The DRST field does not update
 * immediately after a write to the DRS field due to internal synchronization between
 * clock domains. See the DCO Frequency Range table for more details.
 *
 * Values:
 * - 00 - Encoding 0 - Low range (reset default).
 * - 01 - Encoding 1 - Mid range.
 * - 10 - Encoding 2 - Mid-high range.
 * - 11 - Encoding 3 - High range.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_DRST_DRS field. */
#define MCG_RD_C4_DRST_DRS(base) ((MCG_C4_REG(base) & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)
#define MCG_BRD_C4_DRST_DRS(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_DRST_DRS_SHIFT, MCG_C4_DRST_DRS_WIDTH))

/*! @brief Set the DRST_DRS field to a new value. */
#define MCG_WR_C4_DRST_DRS(base, value) (MCG_RMW_C4(base, MCG_C4_DRST_DRS_MASK, MCG_C4_DRST_DRS(value)))
#define MCG_BWR_C4_DRST_DRS(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_DRST_DRS_SHIFT), MCG_C4_DRST_DRS_SHIFT, MCG_C4_DRST_DRS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C4, field DMX32[7] (RW)
 *
 * The DMX32 bit controls whether the DCO frequency range is narrowed to its
 * maximum frequency with a 32.768 kHz reference. The following table identifies
 * settings for the DCO frequency range. The system clocks derived from this source
 * should not exceed their specified maximums. DRST_DRS DMX32 Reference Range FLL
 * Factor DCO Range 00 0 31.25-39.0625 kHz 640 20-25 MHz 1 32.768 kHz 732 24 MHz
 * 01 0 31.25-39.0625 kHz 1280 40-50 MHz 1 32.768 kHz 1464 48 MHz 10 0
 * 31.25-39.0625 kHz 1920 60-75 MHz 1 32.768 kHz 2197 72 MHz 11 0 31.25-39.0625 kHz 2560
 * 80-100 MHz 1 32.768 kHz 2929 96 MHz
 *
 * Values:
 * - 0 - DCO has a default range of 25%.
 * - 1 - DCO is fine-tuned for maximum frequency with 32.768 kHz reference.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_DMX32 field. */
#define MCG_RD_C4_DMX32(base) ((MCG_C4_REG(base) & MCG_C4_DMX32_MASK) >> MCG_C4_DMX32_SHIFT)
#define MCG_BRD_C4_DMX32(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_DMX32_SHIFT, MCG_C4_DMX32_WIDTH))

/*! @brief Set the DMX32 field to a new value. */
#define MCG_WR_C4_DMX32(base, value) (MCG_RMW_C4(base, MCG_C4_DMX32_MASK, MCG_C4_DMX32(value)))
#define MCG_BWR_C4_DMX32(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_DMX32_SHIFT), MCG_C4_DMX32_SHIFT, MCG_C4_DMX32_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C6 - MCG Control 6 Register
 ******************************************************************************/

/*!
 * @brief MCG_C6 - MCG Control 6 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C6 register
 */
/*@{*/
#define MCG_RD_C6(base)          (MCG_C6_REG(base))
#define MCG_WR_C6(base, value)   (MCG_C6_REG(base) = (value))
#define MCG_RMW_C6(base, mask, value) (MCG_WR_C6(base, (MCG_RD_C6(base) & ~(mask)) | (value)))
#define MCG_SET_C6(base, value)  (BME_OR8(&MCG_C6_REG(base), (uint8_t)(value)))
#define MCG_CLR_C6(base, value)  (BME_AND8(&MCG_C6_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C6(base, value)  (BME_XOR8(&MCG_C6_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C6 bitfields
 */

/*!
 * @name Register MCG_C6, field CME[5] (RW)
 *
 * Determines if a reset request is made following a loss of external clock
 * indication. The CME bit should only be set to a logic 1 when the MCG is in an
 * operational mode that uses the external clock (FEE, FBE, or BLPE). Whenever the
 * CME bit is set to a logic 1, the value of the RANGE bits in the C2 register
 * should not be changed. CME bit should be set to a logic 0 before the MCG enters
 * any Stop mode. Otherwise, a reset request may occur when in Stop mode. CME
 * should also be set to a logic 0 before entering VLPR or VLPW power modes if the MCG
 * is in BLPE mode.
 *
 * Values:
 * - 0 - External clock monitor is disabled.
 * - 1 - Generate a reset request on loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_CME field. */
#define MCG_RD_C6_CME(base)  ((MCG_C6_REG(base) & MCG_C6_CME_MASK) >> MCG_C6_CME_SHIFT)
#define MCG_BRD_C6_CME(base) (BME_UBFX8(&MCG_C6_REG(base), MCG_C6_CME_SHIFT, MCG_C6_CME_WIDTH))

/*! @brief Set the CME field to a new value. */
#define MCG_WR_C6_CME(base, value) (MCG_RMW_C6(base, MCG_C6_CME_MASK, MCG_C6_CME(value)))
#define MCG_BWR_C6_CME(base, value) (BME_BFI8(&MCG_C6_REG(base), ((uint8_t)(value) << MCG_C6_CME_SHIFT), MCG_C6_CME_SHIFT, MCG_C6_CME_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_S - MCG Status Register
 ******************************************************************************/

/*!
 * @brief MCG_S - MCG Status Register (RO)
 *
 * Reset value: 0x10U
 */
/*!
 * @name Constants and macros for entire MCG_S register
 */
/*@{*/
#define MCG_RD_S(base)           (MCG_S_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCG_S bitfields
 */

/*!
 * @name Register MCG_S, field IRCST[0] (RO)
 *
 * The IRCST bit indicates the current source for the internal reference clock
 * select clock (IRCSCLK). The IRCST bit does not update immediately after a write
 * to the IRCS bit due to internal synchronization between clock domains. The
 * IRCST bit will only be updated if the internal reference clock is enabled,
 * either by the MCG being in a mode that uses the IRC or by setting the C1[IRCLKEN]
 * bit .
 *
 * Values:
 * - 0 - Source of internal reference clock is the slow clock (32 kHz IRC).
 * - 1 - Source of internal reference clock is the fast clock (4 MHz IRC).
 */
/*@{*/
/*! @brief Read current value of the MCG_S_IRCST field. */
#define MCG_RD_S_IRCST(base) ((MCG_S_REG(base) & MCG_S_IRCST_MASK) >> MCG_S_IRCST_SHIFT)
#define MCG_BRD_S_IRCST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_IRCST_SHIFT, MCG_S_IRCST_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field OSCINIT0[1] (RO)
 *
 * This bit, which resets to 0, is set to 1 after the initialization cycles of
 * the crystal oscillator clock have completed. After being set, the bit is
 * cleared to 0 if the OSC is subsequently disabled. See the OSC module's detailed
 * description for more information.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_OSCINIT0 field. */
#define MCG_RD_S_OSCINIT0(base) ((MCG_S_REG(base) & MCG_S_OSCINIT0_MASK) >> MCG_S_OSCINIT0_SHIFT)
#define MCG_BRD_S_OSCINIT0(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_OSCINIT0_SHIFT, MCG_S_OSCINIT0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field CLKST[3:2] (RO)
 *
 * These bits indicate the current clock mode. The CLKST bits do not update
 * immediately after a write to the CLKS bits due to internal synchronization between
 * clock domains.
 *
 * Values:
 * - 00 - Encoding 0 - Output of the FLL is selected (reset default).
 * - 01 - Encoding 1 - Internal reference clock is selected.
 * - 10 - Encoding 2 - External reference clock is selected.
 * - 11 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_CLKST field. */
#define MCG_RD_S_CLKST(base) ((MCG_S_REG(base) & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)
#define MCG_BRD_S_CLKST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_CLKST_SHIFT, MCG_S_CLKST_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field IREFST[4] (RO)
 *
 * This bit indicates the current source for the FLL reference clock. The IREFST
 * bit does not update immediately after a write to the IREFS bit due to
 * internal synchronization between clock domains.
 *
 * Values:
 * - 0 - Source of FLL reference clock is the external reference clock.
 * - 1 - Source of FLL reference clock is the internal reference clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_IREFST field. */
#define MCG_RD_S_IREFST(base) ((MCG_S_REG(base) & MCG_S_IREFST_MASK) >> MCG_S_IREFST_SHIFT)
#define MCG_BRD_S_IREFST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_IREFST_SHIFT, MCG_S_IREFST_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_SC - MCG Status and Control Register
 ******************************************************************************/

/*!
 * @brief MCG_SC - MCG Status and Control Register (RW)
 *
 * Reset value: 0x02U
 */
/*!
 * @name Constants and macros for entire MCG_SC register
 */
/*@{*/
#define MCG_RD_SC(base)          (MCG_SC_REG(base))
#define MCG_WR_SC(base, value)   (MCG_SC_REG(base) = (value))
#define MCG_RMW_SC(base, mask, value) (MCG_WR_SC(base, (MCG_RD_SC(base) & ~(mask)) | (value)))
#define MCG_SET_SC(base, value)  (BME_OR8(&MCG_SC_REG(base), (uint8_t)(value)))
#define MCG_CLR_SC(base, value)  (BME_AND8(&MCG_SC_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_SC(base, value)  (BME_XOR8(&MCG_SC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_SC bitfields
 */

/*!
 * @name Register MCG_SC, field LOCS0[0] (W1C)
 *
 * The LOCS0 indicates when a loss of OSC0 reference clock has occurred. The
 * LOCS0 bit only has an effect when CME0 is set. This bit is cleared by writing a
 * logic 1 to it when set.
 *
 * Values:
 * - 0 - Loss of OSC0 has not occurred.
 * - 1 - Loss of OSC0 has occurred.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_LOCS0 field. */
#define MCG_RD_SC_LOCS0(base) ((MCG_SC_REG(base) & MCG_SC_LOCS0_MASK) >> MCG_SC_LOCS0_SHIFT)
#define MCG_BRD_SC_LOCS0(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_LOCS0_SHIFT, MCG_SC_LOCS0_WIDTH))

/*! @brief Set the LOCS0 field to a new value. */
#define MCG_WR_SC_LOCS0(base, value) (MCG_RMW_SC(base, (MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_LOCS0(value)))
#define MCG_BWR_SC_LOCS0(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_LOCS0_SHIFT), MCG_SC_LOCS0_SHIFT, MCG_SC_LOCS0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field FCRDIV[3:1] (RW)
 *
 * Selects the amount to divide down the fast internal reference clock. The
 * resulting frequency will be in the range 31.25 kHz to 4 MHz (Note: Changing the
 * divider when the Fast IRC is enabled is not supported).
 *
 * Values:
 * - 000 - Divide Factor is 1
 * - 001 - Divide Factor is 2.
 * - 010 - Divide Factor is 4.
 * - 011 - Divide Factor is 8.
 * - 100 - Divide Factor is 16
 * - 101 - Divide Factor is 32
 * - 110 - Divide Factor is 64
 * - 111 - Divide Factor is 128.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_FCRDIV field. */
#define MCG_RD_SC_FCRDIV(base) ((MCG_SC_REG(base) & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)
#define MCG_BRD_SC_FCRDIV(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_FCRDIV_SHIFT, MCG_SC_FCRDIV_WIDTH))

/*! @brief Set the FCRDIV field to a new value. */
#define MCG_WR_SC_FCRDIV(base, value) (MCG_RMW_SC(base, (MCG_SC_FCRDIV_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_FCRDIV(value)))
#define MCG_BWR_SC_FCRDIV(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_FCRDIV_SHIFT), MCG_SC_FCRDIV_SHIFT, MCG_SC_FCRDIV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field FLTPRSRV[4] (RW)
 *
 * This bit will prevent the FLL filter values from resetting allowing the FLL
 * output frequency to remain the same during clock mode changes where the FLL/DCO
 * output is still valid. (Note: This requires that the FLL reference frequency
 * to remain the same as what it was prior to the new clock mode switch.
 * Otherwise FLL filter and frequency values will change.)
 *
 * Values:
 * - 0 - FLL filter and FLL frequency will reset on changes to currect clock
 *     mode.
 * - 1 - Fll filter and FLL frequency retain their previous values during new
 *     clock mode change.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_FLTPRSRV field. */
#define MCG_RD_SC_FLTPRSRV(base) ((MCG_SC_REG(base) & MCG_SC_FLTPRSRV_MASK) >> MCG_SC_FLTPRSRV_SHIFT)
#define MCG_BRD_SC_FLTPRSRV(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_FLTPRSRV_SHIFT, MCG_SC_FLTPRSRV_WIDTH))

/*! @brief Set the FLTPRSRV field to a new value. */
#define MCG_WR_SC_FLTPRSRV(base, value) (MCG_RMW_SC(base, (MCG_SC_FLTPRSRV_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_FLTPRSRV(value)))
#define MCG_BWR_SC_FLTPRSRV(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_FLTPRSRV_SHIFT), MCG_SC_FLTPRSRV_SHIFT, MCG_SC_FLTPRSRV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMF[5] (W1C)
 *
 * Fail flag for the Automatic Trim Machine (ATM). This bit asserts when the
 * Automatic Trim Machine is enabled, ATME=1, and a write to the C1, C3, C4, and SC
 * registers is detected or the MCG enters into any Stop mode. A write to ATMF
 * clears the flag.
 *
 * Values:
 * - 0 - Automatic Trim Machine completed normally.
 * - 1 - Automatic Trim Machine failed.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATMF field. */
#define MCG_RD_SC_ATMF(base) ((MCG_SC_REG(base) & MCG_SC_ATMF_MASK) >> MCG_SC_ATMF_SHIFT)
#define MCG_BRD_SC_ATMF(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_ATMF_SHIFT, MCG_SC_ATMF_WIDTH))

/*! @brief Set the ATMF field to a new value. */
#define MCG_WR_SC_ATMF(base, value) (MCG_RMW_SC(base, (MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK), MCG_SC_ATMF(value)))
#define MCG_BWR_SC_ATMF(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_ATMF_SHIFT), MCG_SC_ATMF_SHIFT, MCG_SC_ATMF_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMS[6] (RW)
 *
 * Selects the IRCS clock for Auto Trim Test.
 *
 * Values:
 * - 0 - 32 kHz Internal Reference Clock selected.
 * - 1 - 4 MHz Internal Reference Clock selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATMS field. */
#define MCG_RD_SC_ATMS(base) ((MCG_SC_REG(base) & MCG_SC_ATMS_MASK) >> MCG_SC_ATMS_SHIFT)
#define MCG_BRD_SC_ATMS(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_ATMS_SHIFT, MCG_SC_ATMS_WIDTH))

/*! @brief Set the ATMS field to a new value. */
#define MCG_WR_SC_ATMS(base, value) (MCG_RMW_SC(base, (MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_ATMS(value)))
#define MCG_BWR_SC_ATMS(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_ATMS_SHIFT), MCG_SC_ATMS_SHIFT, MCG_SC_ATMS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field ATME[7] (RW)
 *
 * Enables the Auto Trim Machine to start automatically trimming the selected
 * Internal Reference Clock. ATME deasserts after the Auto Trim Machine has
 * completed trimming all trim bits of the IRCS clock selected by the ATMS bit. Writing
 * to C1, C3, C4, and SC registers or entering Stop mode aborts the auto trim
 * operation and clears this bit.
 *
 * Values:
 * - 0 - Auto Trim Machine disabled.
 * - 1 - Auto Trim Machine enabled.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATME field. */
#define MCG_RD_SC_ATME(base) ((MCG_SC_REG(base) & MCG_SC_ATME_MASK) >> MCG_SC_ATME_SHIFT)
#define MCG_BRD_SC_ATME(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_ATME_SHIFT, MCG_SC_ATME_WIDTH))

/*! @brief Set the ATME field to a new value. */
#define MCG_WR_SC_ATME(base, value) (MCG_RMW_SC(base, (MCG_SC_ATME_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_ATME(value)))
#define MCG_BWR_SC_ATME(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_ATME_SHIFT), MCG_SC_ATME_SHIFT, MCG_SC_ATME_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_ATCVH - MCG Auto Trim Compare Value High Register
 ******************************************************************************/

/*!
 * @brief MCG_ATCVH - MCG Auto Trim Compare Value High Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_ATCVH register
 */
/*@{*/
#define MCG_RD_ATCVH(base)       (MCG_ATCVH_REG(base))
#define MCG_WR_ATCVH(base, value) (MCG_ATCVH_REG(base) = (value))
#define MCG_RMW_ATCVH(base, mask, value) (MCG_WR_ATCVH(base, (MCG_RD_ATCVH(base) & ~(mask)) | (value)))
#define MCG_SET_ATCVH(base, value) (BME_OR8(&MCG_ATCVH_REG(base), (uint8_t)(value)))
#define MCG_CLR_ATCVH(base, value) (BME_AND8(&MCG_ATCVH_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_ATCVH(base, value) (BME_XOR8(&MCG_ATCVH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 ******************************************************************************/

/*!
 * @brief MCG_ATCVL - MCG Auto Trim Compare Value Low Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_ATCVL register
 */
/*@{*/
#define MCG_RD_ATCVL(base)       (MCG_ATCVL_REG(base))
#define MCG_WR_ATCVL(base, value) (MCG_ATCVL_REG(base) = (value))
#define MCG_RMW_ATCVL(base, mask, value) (MCG_WR_ATCVL(base, (MCG_RD_ATCVL(base) & ~(mask)) | (value)))
#define MCG_SET_ATCVL(base, value) (BME_OR8(&MCG_ATCVL_REG(base), (uint8_t)(value)))
#define MCG_CLR_ATCVL(base, value) (BME_AND8(&MCG_ATCVL_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_ATCVL(base, value) (BME_XOR8(&MCG_ATCVL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * MKV10Z7 MCM
 *
 * Core Platform Miscellaneous Control Module
 *
 * Registers defined in this header file:
 * - MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 * - MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 * - MCM_PLACR - Platform Control Register
 * - MCM_CPO - Compute Operation Control Register
 */

#define MCM_INSTANCE_COUNT (1U) /*!< Number of instances of the MCM module. */
#define MCM_IDX (0U) /*!< Instance number for MCM. */

/*******************************************************************************
 * MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 ******************************************************************************/

/*!
 * @brief MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration (RO)
 *
 * Reset value: 0x0007U
 *
 * PLASC is a 16-bit read-only register identifying the presence/absence of bus
 * slave connections to the device's crossbar switch.
 */
/*!
 * @name Constants and macros for entire MCM_PLASC register
 */
/*@{*/
#define MCM_RD_PLASC(base)       (MCM_PLASC_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PLASC bitfields
 */

/*!
 * @name Register MCM_PLASC, field ASC[7:0] (RO)
 *
 * Values:
 * - 0 - A bus slave connection to AXBS input port n is absent.
 * - 1 - A bus slave connection to AXBS input port n is present.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLASC_ASC field. */
#define MCM_RD_PLASC_ASC(base) ((MCM_PLASC_REG(base) & MCM_PLASC_ASC_MASK) >> MCM_PLASC_ASC_SHIFT)
#define MCM_BRD_PLASC_ASC(base) (MCM_RD_PLASC_ASC(base))
/*@}*/

/*******************************************************************************
 * MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 ******************************************************************************/

/*!
 * @brief MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration (RO)
 *
 * Reset value: 0x0005U
 *
 * PLAMC is a 16-bit read-only register identifying the presence/absence of bus
 * master connections to the device's crossbar switch.
 */
/*!
 * @name Constants and macros for entire MCM_PLAMC register
 */
/*@{*/
#define MCM_RD_PLAMC(base)       (MCM_PLAMC_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PLAMC bitfields
 */

/*!
 * @name Register MCM_PLAMC, field AMC[7:0] (RO)
 *
 * Values:
 * - 0 - A bus master connection to AXBS input port n is absent
 * - 1 - A bus master connection to AXBS input port n is present
 */
/*@{*/
/*! @brief Read current value of the MCM_PLAMC_AMC field. */
#define MCM_RD_PLAMC_AMC(base) ((MCM_PLAMC_REG(base) & MCM_PLAMC_AMC_MASK) >> MCM_PLAMC_AMC_SHIFT)
#define MCM_BRD_PLAMC_AMC(base) (MCM_RD_PLAMC_AMC(base))
/*@}*/

/*******************************************************************************
 * MCM_PLACR - Platform Control Register
 ******************************************************************************/

/*!
 * @brief MCM_PLACR - Platform Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PLACR register selects the arbitration policy for the crossbar masters
 * and configures the flash memory controller. The speculation buffer and cache in
 * the flash memory controller is configurable via PLACR[15:10 ]. The speculation
 * buffer is enabled only for instructions after reset. It is possible to have
 * these states for the speculation buffer: DFCS EFDS Description 0 0 Speculation
 * buffer is on for instruction and off for data. 0 1 Speculation buffer is on
 * for instruction and on for data. 1 X Speculation buffer is off. The cache in
 * flash controller is enabled and caching both instruction and data type fetches
 * after reset. It is possible to have these states for the cache: DFCC DFCIC DFCDA
 * Description 0 0 0 Cache is on for both instruction and data. 0 0 1 Cache is
 * on for instruction and off for data. 0 1 0 Cache is off for instruction and on
 * for data. 0 1 1 Cache is off for both instruction and data. 1 X X Cache is off.
 */
/*!
 * @name Constants and macros for entire MCM_PLACR register
 */
/*@{*/
#define MCM_RD_PLACR(base)       (MCM_PLACR_REG(base))
#define MCM_WR_PLACR(base, value) (MCM_PLACR_REG(base) = (value))
#define MCM_RMW_PLACR(base, mask, value) (MCM_WR_PLACR(base, (MCM_RD_PLACR(base) & ~(mask)) | (value)))
#define MCM_SET_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) |  (value)))
#define MCM_CLR_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) & ~(value)))
#define MCM_TOG_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_PLACR bitfields
 */

/*!
 * @name Register MCM_PLACR, field ARB[9] (RW)
 *
 * Values:
 * - 0 - Fixed-priority arbitration for the crossbar masters
 * - 1 - Round-robin arbitration for the crossbar masters
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_ARB field. */
#define MCM_RD_PLACR_ARB(base) ((MCM_PLACR_REG(base) & MCM_PLACR_ARB_MASK) >> MCM_PLACR_ARB_SHIFT)
#define MCM_BRD_PLACR_ARB(base) (MCM_RD_PLACR_ARB(base))

/*! @brief Set the ARB field to a new value. */
#define MCM_WR_PLACR_ARB(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_ARB_MASK, MCM_PLACR_ARB(value)))
#define MCM_BWR_PLACR_ARB(base, value) (MCM_WR_PLACR_ARB(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field CFCC[10] (WORZ)
 *
 * Writing a 1 to this field clears the cache. Writing a 0 to this field is
 * ignored. This field always reads as 0.
 */
/*@{*/
/*! @brief Set the CFCC field to a new value. */
#define MCM_WR_PLACR_CFCC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_CFCC_MASK, MCM_PLACR_CFCC(value)))
#define MCM_BWR_PLACR_CFCC(base, value) (MCM_WR_PLACR_CFCC(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCDA[11] (RW)
 *
 * Disables flash controller data caching.
 *
 * Values:
 * - 0 - Enable flash controller data caching
 * - 1 - Disable flash controller data caching.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCDA field. */
#define MCM_RD_PLACR_DFCDA(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCDA_MASK) >> MCM_PLACR_DFCDA_SHIFT)
#define MCM_BRD_PLACR_DFCDA(base) (MCM_RD_PLACR_DFCDA(base))

/*! @brief Set the DFCDA field to a new value. */
#define MCM_WR_PLACR_DFCDA(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCDA_MASK, MCM_PLACR_DFCDA(value)))
#define MCM_BWR_PLACR_DFCDA(base, value) (MCM_WR_PLACR_DFCDA(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCIC[12] (RW)
 *
 * Disables flash controller instruction caching.
 *
 * Values:
 * - 0 - Enable flash controller instruction caching.
 * - 1 - Disable flash controller instruction caching.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCIC field. */
#define MCM_RD_PLACR_DFCIC(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCIC_MASK) >> MCM_PLACR_DFCIC_SHIFT)
#define MCM_BRD_PLACR_DFCIC(base) (MCM_RD_PLACR_DFCIC(base))

/*! @brief Set the DFCIC field to a new value. */
#define MCM_WR_PLACR_DFCIC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCIC_MASK, MCM_PLACR_DFCIC(value)))
#define MCM_BWR_PLACR_DFCIC(base, value) (MCM_WR_PLACR_DFCIC(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCC[13] (RW)
 *
 * Disables flash controller cache.
 *
 * Values:
 * - 0 - Enable flash controller cache.
 * - 1 - Disable flash controller cache.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCC field. */
#define MCM_RD_PLACR_DFCC(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCC_MASK) >> MCM_PLACR_DFCC_SHIFT)
#define MCM_BRD_PLACR_DFCC(base) (MCM_RD_PLACR_DFCC(base))

/*! @brief Set the DFCC field to a new value. */
#define MCM_WR_PLACR_DFCC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCC_MASK, MCM_PLACR_DFCC(value)))
#define MCM_BWR_PLACR_DFCC(base, value) (MCM_WR_PLACR_DFCC(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field EFDS[14] (RW)
 *
 * Enables flash data speculation.
 *
 * Values:
 * - 0 - Disable flash data speculation.
 * - 1 - Enable flash data speculation.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_EFDS field. */
#define MCM_RD_PLACR_EFDS(base) ((MCM_PLACR_REG(base) & MCM_PLACR_EFDS_MASK) >> MCM_PLACR_EFDS_SHIFT)
#define MCM_BRD_PLACR_EFDS(base) (MCM_RD_PLACR_EFDS(base))

/*! @brief Set the EFDS field to a new value. */
#define MCM_WR_PLACR_EFDS(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_EFDS_MASK, MCM_PLACR_EFDS(value)))
#define MCM_BWR_PLACR_EFDS(base, value) (MCM_WR_PLACR_EFDS(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCS[15] (RW)
 *
 * Disables flash controller speculation.
 *
 * Values:
 * - 0 - Enable flash controller speculation.
 * - 1 - Disable flash controller speculation.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCS field. */
#define MCM_RD_PLACR_DFCS(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCS_MASK) >> MCM_PLACR_DFCS_SHIFT)
#define MCM_BRD_PLACR_DFCS(base) (MCM_RD_PLACR_DFCS(base))

/*! @brief Set the DFCS field to a new value. */
#define MCM_WR_PLACR_DFCS(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCS_MASK, MCM_PLACR_DFCS(value)))
#define MCM_BWR_PLACR_DFCS(base, value) (MCM_WR_PLACR_DFCS(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field ESFC[16] (RW)
 *
 * Enables stalling flash controller when flash is busy. When software needs to
 * access the flash memory while a flash memory resource is being manipulated by
 * a flash command, software can enable a stall mechanism to avoid a read
 * collision. The stall mechanism allows software to execute code from the same block on
 * which flash operations are being performed. However, software must ensure the
 * sector the flash operations are being performed on is not the same sector
 * from which the code is executing. ESFC enables the stall mechanism. This bit must
 * be set only just before the flash operation is executed and must be cleared
 * when the operation completes.
 *
 * Values:
 * - 0 - Disable stalling flash controller when flash is busy.
 * - 1 - Enable stalling flash controller when flash is busy.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_ESFC field. */
#define MCM_RD_PLACR_ESFC(base) ((MCM_PLACR_REG(base) & MCM_PLACR_ESFC_MASK) >> MCM_PLACR_ESFC_SHIFT)
#define MCM_BRD_PLACR_ESFC(base) (MCM_RD_PLACR_ESFC(base))

/*! @brief Set the ESFC field to a new value. */
#define MCM_WR_PLACR_ESFC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_ESFC_MASK, MCM_PLACR_ESFC(value)))
#define MCM_BWR_PLACR_ESFC(base, value) (MCM_WR_PLACR_ESFC(base, value))
/*@}*/

/*******************************************************************************
 * MCM_CPO - Compute Operation Control Register
 ******************************************************************************/

/*!
 * @brief MCM_CPO - Compute Operation Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the Compute Operation.
 */
/*!
 * @name Constants and macros for entire MCM_CPO register
 */
/*@{*/
#define MCM_RD_CPO(base)         (MCM_CPO_REG(base))
#define MCM_WR_CPO(base, value)  (MCM_CPO_REG(base) = (value))
#define MCM_RMW_CPO(base, mask, value) (MCM_WR_CPO(base, (MCM_RD_CPO(base) & ~(mask)) | (value)))
#define MCM_SET_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) |  (value)))
#define MCM_CLR_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) & ~(value)))
#define MCM_TOG_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_CPO bitfields
 */

/*!
 * @name Register MCM_CPO, field CPOREQ[0] (RW)
 *
 * This bit is auto-cleared by vector fetching if CPOWOI = 1.
 *
 * Values:
 * - 0 - Request is cleared.
 * - 1 - Request Compute Operation.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOREQ field. */
#define MCM_RD_CPO_CPOREQ(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOREQ_MASK) >> MCM_CPO_CPOREQ_SHIFT)
#define MCM_BRD_CPO_CPOREQ(base) (MCM_RD_CPO_CPOREQ(base))

/*! @brief Set the CPOREQ field to a new value. */
#define MCM_WR_CPO_CPOREQ(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOREQ_MASK, MCM_CPO_CPOREQ(value)))
#define MCM_BWR_CPO_CPOREQ(base, value) (MCM_WR_CPO_CPOREQ(base, value))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOACK[1] (RO)
 *
 * Values:
 * - 0 - Compute operation entry has not completed or compute operation exit has
 *     completed.
 * - 1 - Compute operation entry has completed or compute operation exit has not
 *     completed.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOACK field. */
#define MCM_RD_CPO_CPOACK(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOACK_MASK) >> MCM_CPO_CPOACK_SHIFT)
#define MCM_BRD_CPO_CPOACK(base) (MCM_RD_CPO_CPOACK(base))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOWOI[2] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - When set, the CPOREQ is cleared on any interrupt or exception vector
 *     fetch.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOWOI field. */
#define MCM_RD_CPO_CPOWOI(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOWOI_MASK) >> MCM_CPO_CPOWOI_SHIFT)
#define MCM_BRD_CPO_CPOWOI(base) (MCM_RD_CPO_CPOWOI(base))

/*! @brief Set the CPOWOI field to a new value. */
#define MCM_WR_CPO_CPOWOI(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOWOI_MASK, MCM_CPO_CPOWOI(value)))
#define MCM_BWR_CPO_CPOWOI(base, value) (MCM_WR_CPO_CPOWOI(base, value))
/*@}*/

/*
 * MKV10Z7 MMDVSQ
 *
 * Memory-Mapped Divide and Square Root
 *
 * Registers defined in this header file:
 * - MMDVSQ_DEND - Dividend Register
 * - MMDVSQ_DSOR - Divisor Register
 * - MMDVSQ_CSR - Control/Status Register
 * - MMDVSQ_RES - Result Register
 * - MMDVSQ_RCND - Radicand Register
 */

#define MMDVSQ_INSTANCE_COUNT (1U) /*!< Number of instances of the MMDVSQ module. */
#define MMDVSQ_IDX (0U) /*!< Instance number for MMDVSQ. */

/*******************************************************************************
 * MMDVSQ_DEND - Dividend Register
 ******************************************************************************/

/*!
 * @brief MMDVSQ_DEND - Dividend Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded with the input dividend operand before a divide
 * operation is initiated. The register is updated by the MMDVSQ hardware during the
 * execution of a divide or square root calculation. Any memory access (read or
 * write) of the DEND register while the module is busy during a calculation causes
 * the access to be stalled (using wait states) until the calculation completes.
 */
/*!
 * @name Constants and macros for entire MMDVSQ_DEND register
 */
/*@{*/
#define MMDVSQ_RD_DEND(base)     (MMDVSQ_DEND_REG(base))
#define MMDVSQ_WR_DEND(base, value) (MMDVSQ_DEND_REG(base) = (value))
#define MMDVSQ_RMW_DEND(base, mask, value) (MMDVSQ_WR_DEND(base, (MMDVSQ_RD_DEND(base) & ~(mask)) | (value)))
#define MMDVSQ_SET_DEND(base, value) (MMDVSQ_WR_DEND(base, MMDVSQ_RD_DEND(base) |  (value)))
#define MMDVSQ_CLR_DEND(base, value) (MMDVSQ_WR_DEND(base, MMDVSQ_RD_DEND(base) & ~(value)))
#define MMDVSQ_TOG_DEND(base, value) (MMDVSQ_WR_DEND(base, MMDVSQ_RD_DEND(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MMDVSQ_DSOR - Divisor Register
 ******************************************************************************/

/*!
 * @brief MMDVSQ_DSOR - Divisor Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded with the input divisor operand before a divide
 * operation is initiated. If CSR[DFS] = 0, a write to this register inititates a
 * divide operation. Any memory access (read or write) of the DSOR register while the
 * module is busy during a calculation causes the access to be stalled (using
 * wait states) until the calculation completes. If a divide operation is inititated
 * with DSOR = 0, the hardware signals a divide-by-zero condition and sets RES =
 * 0 and CSR[DZ] = 1. If CSR[DZE] = 1, an attempted read of the RES result is
 * error terminated.
 */
/*!
 * @name Constants and macros for entire MMDVSQ_DSOR register
 */
/*@{*/
#define MMDVSQ_RD_DSOR(base)     (MMDVSQ_DSOR_REG(base))
#define MMDVSQ_WR_DSOR(base, value) (MMDVSQ_DSOR_REG(base) = (value))
#define MMDVSQ_RMW_DSOR(base, mask, value) (MMDVSQ_WR_DSOR(base, (MMDVSQ_RD_DSOR(base) & ~(mask)) | (value)))
#define MMDVSQ_SET_DSOR(base, value) (MMDVSQ_WR_DSOR(base, MMDVSQ_RD_DSOR(base) |  (value)))
#define MMDVSQ_CLR_DSOR(base, value) (MMDVSQ_WR_DSOR(base, MMDVSQ_RD_DSOR(base) & ~(value)))
#define MMDVSQ_TOG_DSOR(base, value) (MMDVSQ_WR_DSOR(base, MMDVSQ_RD_DSOR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MMDVSQ_CSR - Control/Status Register
 ******************************************************************************/

/*!
 * @brief MMDVSQ_CSR - Control/Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the operating configuration of divide operations and
 * provides status information. The upper 3 bits provide busy status indicators,
 * while the low-order byte defines the configuration for divide operations. The
 * read-only status bits in CSR[31:29] are valid for both divide and square root
 * operations; the configuration and status bit in CSR[5:0] are only valid for
 * divides. A memory write access of the CSR register while the module is busy during
 * a calculation causes the access to be stalled (using wait states) until the
 * calculation completes.
 */
/*!
 * @name Constants and macros for entire MMDVSQ_CSR register
 */
/*@{*/
#define MMDVSQ_RD_CSR(base)      (MMDVSQ_CSR_REG(base))
#define MMDVSQ_WR_CSR(base, value) (MMDVSQ_CSR_REG(base) = (value))
#define MMDVSQ_RMW_CSR(base, mask, value) (MMDVSQ_WR_CSR(base, (MMDVSQ_RD_CSR(base) & ~(mask)) | (value)))
#define MMDVSQ_SET_CSR(base, value) (MMDVSQ_WR_CSR(base, MMDVSQ_RD_CSR(base) |  (value)))
#define MMDVSQ_CLR_CSR(base, value) (MMDVSQ_WR_CSR(base, MMDVSQ_RD_CSR(base) & ~(value)))
#define MMDVSQ_TOG_CSR(base, value) (MMDVSQ_WR_CSR(base, MMDVSQ_RD_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MMDVSQ_CSR bitfields
 */

/*!
 * @name Register MMDVSQ_CSR, field SRT[0] (WORZ)
 *
 * When written with a logical one and CSR[DFS] = 1, this flag initiates a
 * divide operation. If written as a logical one with CSR[DFS] = 0, it is ignored.
 * This bit always reads as a zero. The state of the register write data defines
 * this bit's function.
 *
 * Values:
 * - 0 - No operation initiated
 * - 1 - If CSR[DFS] = 1, then initiate a divide calculation, else ignore
 */
/*@{*/
/*! @brief Set the SRT field to a new value. */
#define MMDVSQ_WR_CSR_SRT(base, value) (MMDVSQ_RMW_CSR(base, MMDVSQ_CSR_SRT_MASK, MMDVSQ_CSR_SRT(value)))
#define MMDVSQ_BWR_CSR_SRT(base, value) (MMDVSQ_WR_CSR_SRT(base, value))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field USGN[1] (RW)
 *
 * This indicator selects whether a signed (default) or unsigned divide is
 * performed. See the CSR[REM] description for the encoding of the four possible
 * divide operations.
 *
 * Values:
 * - 0 - Perform a signed divide
 * - 1 - Perform an unsigned divide
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_USGN field. */
#define MMDVSQ_RD_CSR_USGN(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_USGN_MASK) >> MMDVSQ_CSR_USGN_SHIFT)
#define MMDVSQ_BRD_CSR_USGN(base) (MMDVSQ_RD_CSR_USGN(base))

/*! @brief Set the USGN field to a new value. */
#define MMDVSQ_WR_CSR_USGN(base, value) (MMDVSQ_RMW_CSR(base, MMDVSQ_CSR_USGN_MASK, MMDVSQ_CSR_USGN(value)))
#define MMDVSQ_BWR_CSR_USGN(base, value) (MMDVSQ_WR_CSR_USGN(base, value))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field REM[2] (RW)
 *
 * This indicator selects whether the quotient or the remainder is returned in
 * the RES register. The combined CSR[REM] and CSR[USGN] bits define four possible
 * divide operations: If CSR[REM, USGN] = 0b00, perform a signed divide,
 * returning the quotient If CSR[REM, USGN] = 0b01, perform an unsigned divide,
 * returning the quotient If CSR[REM, USGN] = 0b10, perform a signed divide, returning
 * the remainder If CSR[REM, USGN] = 0b11, perform an unsigned divide, returning
 * the remainder
 *
 * Values:
 * - 0 - Return the quotient in the RES for the divide calculation
 * - 1 - Return the remainder in the RES for the divide calculation
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_REM field. */
#define MMDVSQ_RD_CSR_REM(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_REM_MASK) >> MMDVSQ_CSR_REM_SHIFT)
#define MMDVSQ_BRD_CSR_REM(base) (MMDVSQ_RD_CSR_REM(base))

/*! @brief Set the REM field to a new value. */
#define MMDVSQ_WR_CSR_REM(base, value) (MMDVSQ_RMW_CSR(base, MMDVSQ_CSR_REM_MASK, MMDVSQ_CSR_REM(value)))
#define MMDVSQ_BWR_CSR_REM(base, value) (MMDVSQ_WR_CSR_REM(base, value))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field DZE[3] (RW)
 *
 * This indicator configures the MMDVSQ's response to divide-by-zero
 * calculations. If both CSR[DZ] and CSR[DZE] are set, then a subsequent read of the RES
 * register is error terminated to signal the processor of the attempted
 * divide-by-zero.
 *
 * Values:
 * - 0 - Reads of the RES register return the register contents
 * - 1 - If CSR[DZ] = 1, an attempted read of RES register is error terminated
 *     to signal a divide-by-zero, else the register contents are returned
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_DZE field. */
#define MMDVSQ_RD_CSR_DZE(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_DZE_MASK) >> MMDVSQ_CSR_DZE_SHIFT)
#define MMDVSQ_BRD_CSR_DZE(base) (MMDVSQ_RD_CSR_DZE(base))

/*! @brief Set the DZE field to a new value. */
#define MMDVSQ_WR_CSR_DZE(base, value) (MMDVSQ_RMW_CSR(base, MMDVSQ_CSR_DZE_MASK, MMDVSQ_CSR_DZE(value)))
#define MMDVSQ_BWR_CSR_DZE(base, value) (MMDVSQ_WR_CSR_DZE(base, value))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field DZ[4] (RO)
 *
 * This read-only status indicator signals the last divide operation had a zero
 * divisor, that is, DSOR = 0x0000_0000. For this case, RES is set to 0x0000_0000
 * and this indicator bit set. After a divide-by-zero operation, a read of the
 * RES register returns either the zero result, or, if CSR[DZE] = 1, terminates
 * the read with an error. The CSR[DZ] indicator is cleared by the hardware at the
 * beginning of each operation.
 *
 * Values:
 * - 0 - The last divide operation had a non-zero divisor, that is, DSOR != 0
 * - 1 - The last divide operation had a zero divisor, that is, DSOR = 0
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_DZ field. */
#define MMDVSQ_RD_CSR_DZ(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_DZ_MASK) >> MMDVSQ_CSR_DZ_SHIFT)
#define MMDVSQ_BRD_CSR_DZ(base) (MMDVSQ_RD_CSR_DZ(base))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field DFS[5] (RW)
 *
 * The MMDVSQ supports two mechanisms for initiating a divide operation. The
 * default mechanism is a "fast start" where a write to the DSOR register begins the
 * divide. Alternatively, the start mechanism can begin after a write to the CSR
 * register with CSR[SRT] set. The CSR[DFS] indicator selects the divide start
 * mechanism.
 *
 * Values:
 * - 0 - A divide operation is initiated by a write to the DSOR register
 * - 1 - A divide operation is initiated by a write to the CSR register with
 *     CSR[SRT] = 1
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_DFS field. */
#define MMDVSQ_RD_CSR_DFS(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_DFS_MASK) >> MMDVSQ_CSR_DFS_SHIFT)
#define MMDVSQ_BRD_CSR_DFS(base) (MMDVSQ_RD_CSR_DFS(base))

/*! @brief Set the DFS field to a new value. */
#define MMDVSQ_WR_CSR_DFS(base, value) (MMDVSQ_RMW_CSR(base, MMDVSQ_CSR_DFS_MASK, MMDVSQ_CSR_DFS(value)))
#define MMDVSQ_BWR_CSR_DFS(base, value) (MMDVSQ_WR_CSR_DFS(base, value))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field SQRT[29] (RO)
 *
 * Current or last operation was a square root. This read-only indicator bit
 * signals if the current or last operation performed by the MMDVSQ was a square
 * root. The reset state of this indicator is cleared.
 *
 * Values:
 * - 0 - Current or last MMDVSQ operation was not a square root
 * - 1 - Current or last MMDVSQ operation was a square root
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_SQRT field. */
#define MMDVSQ_RD_CSR_SQRT(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_SQRT_MASK) >> MMDVSQ_CSR_SQRT_SHIFT)
#define MMDVSQ_BRD_CSR_SQRT(base) (MMDVSQ_RD_CSR_SQRT(base))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field DIV[30] (RO)
 *
 * Current or last operation was a divide. This read-only indicator bit signals
 * if the current or last operation performed by the MMDVSQ was a divide. The
 * reset state of this indicator is set.
 *
 * Values:
 * - 0 - Current or last MMDVSQ operation was not a divide
 * - 1 - Current or last MMDVSQ operation was a divide
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_DIV field. */
#define MMDVSQ_RD_CSR_DIV(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_DIV_MASK) >> MMDVSQ_CSR_DIV_SHIFT)
#define MMDVSQ_BRD_CSR_DIV(base) (MMDVSQ_RD_CSR_DIV(base))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field BUSY[31] (RO)
 *
 * This read-only bit is asserted when the MMDVSQ is performing a divide or
 * square root. When an operation is initiated, the hardware sets this flag. It
 * remains asserted until the operation completes and the hardware automatically
 * clears the indicator. This bit can be used to poll the MMDVSQ's execution status.
 * The combined CSR[BUSY, DIV, SQRT] indicators provide an encoded module status:
 * If 0b001, then MMDVSQ is idle and the last calculation was a square root If
 * 0b010, then MMDVSQ is idle and the last calculation was a divide If 0b101, then
 * MMDVSQ is busy processing a square root calculation If 0b110, then MMDVSQ is
 * busy processing a divide calculation The remaining encodings of CSR[BUSY, DIV,
 * SQRT] are reserved.
 *
 * Values:
 * - 0 - MMDVSQ is idle
 * - 1 - MMDVSQ is busy performing a divide or square root calculation
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_BUSY field. */
#define MMDVSQ_RD_CSR_BUSY(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_BUSY_MASK) >> MMDVSQ_CSR_BUSY_SHIFT)
#define MMDVSQ_BRD_CSR_BUSY(base) (MMDVSQ_RD_CSR_BUSY(base))
/*@}*/

/*******************************************************************************
 * MMDVSQ_RES - Result Register
 ******************************************************************************/

/*!
 * @brief MMDVSQ_RES - Result Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded with the result of the divide or square root
 * calculation. It is updated by the MMDVSQ hardware at the completion of the
 * calculation. When a square root operation is performed (on an unsigned 32-bit number),
 * the result is limited to a 16-bit value with RES[31:16] = 0x0000. Any memory
 * access (read or write) of the RES register while the module is busy during a
 * calculation causes the access to be stalled (using wait states) until the
 * calculation completes and the new result written into the register.
 */
/*!
 * @name Constants and macros for entire MMDVSQ_RES register
 */
/*@{*/
#define MMDVSQ_RD_RES(base)      (MMDVSQ_RES_REG(base))
#define MMDVSQ_WR_RES(base, value) (MMDVSQ_RES_REG(base) = (value))
#define MMDVSQ_RMW_RES(base, mask, value) (MMDVSQ_WR_RES(base, (MMDVSQ_RD_RES(base) & ~(mask)) | (value)))
#define MMDVSQ_SET_RES(base, value) (MMDVSQ_WR_RES(base, MMDVSQ_RD_RES(base) |  (value)))
#define MMDVSQ_CLR_RES(base, value) (MMDVSQ_WR_RES(base, MMDVSQ_RD_RES(base) & ~(value)))
#define MMDVSQ_TOG_RES(base, value) (MMDVSQ_WR_RES(base, MMDVSQ_RD_RES(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MMDVSQ_RCND - Radicand Register
 ******************************************************************************/

/*!
 * @brief MMDVSQ_RCND - Radicand Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The write-only radicand register is loaded with the input "square" number. A
 * memory write to this register initiates a square root calculation. A memory
 * write access to the RCND register while the module is busy during a calculation
 * causes the access to be stalled (using wait states) until the calculation
 * completes. An attempted read of this register is error terminated.
 */
/*!
 * @name Constants and macros for entire MMDVSQ_RCND register
 */
/*@{*/
#define MMDVSQ_RD_RCND(base)     (MMDVSQ_RCND_REG(base))
#define MMDVSQ_WR_RCND(base, value) (MMDVSQ_RCND_REG(base) = (value))
#define MMDVSQ_RMW_RCND(base, mask, value) (MMDVSQ_WR_RCND(base, (MMDVSQ_RD_RCND(base) & ~(mask)) | (value)))
#define MMDVSQ_SET_RCND(base, value) (MMDVSQ_WR_RCND(base, MMDVSQ_RD_RCND(base) |  (value)))
#define MMDVSQ_CLR_RCND(base, value) (MMDVSQ_WR_RCND(base, MMDVSQ_RD_RCND(base) & ~(value)))
#define MMDVSQ_TOG_RCND(base, value) (MMDVSQ_WR_RCND(base, MMDVSQ_RD_RCND(base) ^  (value)))
/*@}*/

/*
 * MKV10Z7 MTB
 *
 * Micro Trace Buffer
 *
 * Registers defined in this header file:
 * - MTB_POSITION - MTB Position Register
 * - MTB_MASTER - MTB Master Register
 * - MTB_FLOW - MTB Flow Register
 * - MTB_BASE - MTB Base Register
 * - MTB_MODECTRL - Integration Mode Control Register
 * - MTB_TAGSET - Claim TAG Set Register
 * - MTB_TAGCLEAR - Claim TAG Clear Register
 * - MTB_LOCKACCESS - Lock Access Register
 * - MTB_LOCKSTAT - Lock Status Register
 * - MTB_AUTHSTAT - Authentication Status Register
 * - MTB_DEVICEARCH - Device Architecture Register
 * - MTB_DEVICECFG - Device Configuration Register
 * - MTB_DEVICETYPID - Device Type Identifier Register
 * - MTB_PERIPHID - Peripheral ID Register
 * - MTB_COMPID - Component ID Register
 */

#define MTB_INSTANCE_COUNT (1U) /*!< Number of instances of the MTB module. */
#define MTB_IDX (0U) /*!< Instance number for MTB. */

/*******************************************************************************
 * MTB_POSITION - MTB Position Register
 ******************************************************************************/

/*!
 * @brief MTB_POSITION - MTB Position Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTB_POSITION register contains the Trace Write Address Pointer and Wrap
 * fields. This register can be modified by the explicit programming model writes.
 * It is also automatically updated by the MTB hardware when trace packets are
 * being recorded. The base address of the system RAM in the memory map dictates
 * special consideration for the placement of the MTB. Consider the following
 * guidelines: For the standard configuration where the size of the MTB is <= 25% of
 * the total RAM capacity, it is recommended the MTB be based at the address
 * defined by the MTB_BASE register. The read-only MTB_BASE register is defined by
 * the expression (0x2000_0000 - (RAM_Size/4)). For this configuration, the
 * MTB_POSITION register is initialized to MTB_BASE & 0x0000_7FF8. If the size of the
 * MTB is more than 25% but less than or equal to 50% of the total RAM capacity, it
 * is recommended the MTB be based at address 0x2000_0000. In this
 * configuration, the MTB_POSITION register is initialized to (0x2000_0000 & 0x0000_7FF8) =
 * 0x0000_00000. Following these two suggested placements provides a full-featured
 * circular memory buffer containing program trace packets. In the unlikely event
 * an even larger trace buffer is required, a write-once capacity of 75% of the
 * total RAM capacity can be based at address 0x2000_0000. The MTB_POSITION
 * register is initialized to (0x2000_0000 & 0x0000_7FF8) = 0x0000_0000. However, this
 * configuration cannot support operation as a circular queue and instead
 * requires the use of the MTB_FLOW[WATERMARK] capability to automatically disable
 * tracing or halting the processor as the number of packet writes approach the
 * buffer capacity. See the MTB_FLOW register description for more details.
 */
/*!
 * @name Constants and macros for entire MTB_POSITION register
 */
/*@{*/
#define MTB_RD_POSITION(base)    (MTB_POSITION_REG(base))
#define MTB_WR_POSITION(base, value) (MTB_POSITION_REG(base) = (value))
#define MTB_RMW_POSITION(base, mask, value) (MTB_WR_POSITION(base, (MTB_RD_POSITION(base) & ~(mask)) | (value)))
#define MTB_SET_POSITION(base, value) (MTB_WR_POSITION(base, MTB_RD_POSITION(base) |  (value)))
#define MTB_CLR_POSITION(base, value) (MTB_WR_POSITION(base, MTB_RD_POSITION(base) & ~(value)))
#define MTB_TOG_POSITION(base, value) (MTB_WR_POSITION(base, MTB_RD_POSITION(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTB_POSITION bitfields
 */

/*!
 * @name Register MTB_POSITION, field WRAP[2] (RW)
 *
 * This field is set to 1 automatically when the POINTER value wraps as
 * determined by the MTB_MASTER[MASK] field in the MASTER Trace Control Register. A debug
 * agent might use the WRAP field to determine whether the trace information
 * above and below the pointer address is valid.
 */
/*@{*/
/*! @brief Read current value of the MTB_POSITION_WRAP field. */
#define MTB_RD_POSITION_WRAP(base) ((MTB_POSITION_REG(base) & MTB_POSITION_WRAP_MASK) >> MTB_POSITION_WRAP_SHIFT)
#define MTB_BRD_POSITION_WRAP(base) (MTB_RD_POSITION_WRAP(base))

/*! @brief Set the WRAP field to a new value. */
#define MTB_WR_POSITION_WRAP(base, value) (MTB_RMW_POSITION(base, MTB_POSITION_WRAP_MASK, MTB_POSITION_WRAP(value)))
#define MTB_BWR_POSITION_WRAP(base, value) (MTB_WR_POSITION_WRAP(base, value))
/*@}*/

/*!
 * @name Register MTB_POSITION, field POINTER[31:3] (RW)
 *
 * Because a packet consists of two words, the POINTER field is the address of
 * the first word of a packet. This field contains bits[31:3] of the RAM address
 * where the next trace packet is written. Therefore, it points to an unused
 * location and is automatically incremented. A debug agent can calculate the system
 * memory map address for the current location in the MTB using the following
 * "generic" equation: Given mtb_size = 1 << (MTB_MASTER[MASK] + 4), systemAddress =
 * MTB_BASE + (((MTB_POSITION & 0xFFFF_FFF8) + (mtb_size - (MTB_BASE &
 * (mtb_size-1)))) & 0x0000_7FF8); For this device, a simpler expression also applies. See
 * the following pseudo-code: if ((MTB_POSITION >> 13) == 0x3) systemAddress =
 * (0x1FFF << 16) + (0x1 << 15) + (MTB_POSITION & 0x7FF8); else systemAddress =
 * (0x2000 << 16) + (0x0 << 15) + (MTB_POSITION & 0x7FF8); The size of the RAM is
 * parameterized and the most significant bits of the POINTER field are RAZ/WI. For
 * these devices, POSITION[31:15] == POSITION[POINTER[28:12]] are RAZ/WI.
 * Therefore, the active bits in this field are POSITION[14:3] ==
 * POSITION[POINTER[11:0]].
 */
/*@{*/
/*! @brief Read current value of the MTB_POSITION_POINTER field. */
#define MTB_RD_POSITION_POINTER(base) ((MTB_POSITION_REG(base) & MTB_POSITION_POINTER_MASK) >> MTB_POSITION_POINTER_SHIFT)
#define MTB_BRD_POSITION_POINTER(base) (MTB_RD_POSITION_POINTER(base))

/*! @brief Set the POINTER field to a new value. */
#define MTB_WR_POSITION_POINTER(base, value) (MTB_RMW_POSITION(base, MTB_POSITION_POINTER_MASK, MTB_POSITION_POINTER(value)))
#define MTB_BWR_POSITION_POINTER(base, value) (MTB_WR_POSITION_POINTER(base, value))
/*@}*/

/*******************************************************************************
 * MTB_MASTER - MTB Master Register
 ******************************************************************************/

/*!
 * @brief MTB_MASTER - MTB Master Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * The MTB_MASTER register contains the main program trace enable plus other
 * trace controls. This register can be modified by the explicit programming model
 * writes. MTB_MASTER[EN] and MTB_MASTER[HALTREQ] fields are also automatically
 * updated by the MTB hardware. Before MTB_MASTER[EN] or MTB_MASTER[TSTARTEN] are
 * set to 1, the software must initialize the MTB_POSITION and MTB_FLOW registers.
 * If MTB_FLOW[WATERMARK] is used to stop tracing or to halt the processor,
 * MTB_MASTER[MASK] must still be set to a value that prevents MTB_POSITION[POINTER]
 * from wrapping before it reaches the MTB_FLOW[WATERMARK] value. The format of
 * this mask field is different than MTBDWT_MASKn[MASK].
 */
/*!
 * @name Constants and macros for entire MTB_MASTER register
 */
/*@{*/
#define MTB_RD_MASTER(base)      (MTB_MASTER_REG(base))
#define MTB_WR_MASTER(base, value) (MTB_MASTER_REG(base) = (value))
#define MTB_RMW_MASTER(base, mask, value) (MTB_WR_MASTER(base, (MTB_RD_MASTER(base) & ~(mask)) | (value)))
#define MTB_SET_MASTER(base, value) (MTB_WR_MASTER(base, MTB_RD_MASTER(base) |  (value)))
#define MTB_CLR_MASTER(base, value) (MTB_WR_MASTER(base, MTB_RD_MASTER(base) & ~(value)))
#define MTB_TOG_MASTER(base, value) (MTB_WR_MASTER(base, MTB_RD_MASTER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTB_MASTER bitfields
 */

/*!
 * @name Register MTB_MASTER, field MASK[4:0] (RW)
 *
 * This value determines the maximum size of the trace buffer in RAM. It
 * specifies the most-significant bit of the MTB_POSITION[POINTER] field that can be
 * updated by automatic increment. If the trace tries to advance past this power of
 * 2, the MTB_POSITION[WRAP] bit is set to 1, the MTB_POSITION[MASK+3:3] ==
 * MTB_POSITION[POINTER[MASK:0]] bits are set to 0, and the MTB_POSITION[14:MASK+3] ==
 * MTB_POSITION[POINTER[11:MASK+1]] bits remain unchanged. This field causes the
 * trace packet information to be stored in a circular buffer of size 2^[MASK+4]
 * bytes, that can be positioned in memory at multiples of this size. As
 * detailed in the MTB_POSITION description, typical "upper limits" for the MTB size are
 * RAM_Size/4 or RAM_Size/2. Values greater than the maximum have the same
 * effect as the maximum.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_MASK field. */
#define MTB_RD_MASTER_MASK(base) ((MTB_MASTER_REG(base) & MTB_MASTER_MASK_MASK) >> MTB_MASTER_MASK_SHIFT)
#define MTB_BRD_MASTER_MASK(base) (MTB_RD_MASTER_MASK(base))

/*! @brief Set the MASK field to a new value. */
#define MTB_WR_MASTER_MASK(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_MASK_MASK, MTB_MASTER_MASK(value)))
#define MTB_BWR_MASTER_MASK(base, value) (MTB_WR_MASTER_MASK(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field TSTARTEN[5] (RW)
 *
 * If this field is 1 and the TSTART signal is HIGH, then EN is set to 1.
 * Tracing continues until a stop condition occurs.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_TSTARTEN field. */
#define MTB_RD_MASTER_TSTARTEN(base) ((MTB_MASTER_REG(base) & MTB_MASTER_TSTARTEN_MASK) >> MTB_MASTER_TSTARTEN_SHIFT)
#define MTB_BRD_MASTER_TSTARTEN(base) (MTB_RD_MASTER_TSTARTEN(base))

/*! @brief Set the TSTARTEN field to a new value. */
#define MTB_WR_MASTER_TSTARTEN(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_TSTARTEN_MASK, MTB_MASTER_TSTARTEN(value)))
#define MTB_BWR_MASTER_TSTARTEN(base, value) (MTB_WR_MASTER_TSTARTEN(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field TSTOPEN[6] (RW)
 *
 * If this field is 1 and the TSTOP signal is HIGH, then EN is set to 0. If a
 * trace packet is being written to memory, the write is completed before tracing
 * is stopped.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_TSTOPEN field. */
#define MTB_RD_MASTER_TSTOPEN(base) ((MTB_MASTER_REG(base) & MTB_MASTER_TSTOPEN_MASK) >> MTB_MASTER_TSTOPEN_SHIFT)
#define MTB_BRD_MASTER_TSTOPEN(base) (MTB_RD_MASTER_TSTOPEN(base))

/*! @brief Set the TSTOPEN field to a new value. */
#define MTB_WR_MASTER_TSTOPEN(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_TSTOPEN_MASK, MTB_MASTER_TSTOPEN(value)))
#define MTB_BWR_MASTER_TSTOPEN(base, value) (MTB_WR_MASTER_TSTOPEN(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field SFRWPRIV[7] (RW)
 *
 * If this field is 0, then user or privileged AHB read and write accesses to
 * the MTB_RAM Special Function Registers (programming model) are permitted. If
 * this field is 1, then only privileged write accesses are permitted; user write
 * accesses are ignored. The HPROT[1] signal determines if an access is user or
 * privileged. Note MTB_RAM SFR read access are not controlled by this bit and are
 * always permitted.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_SFRWPRIV field. */
#define MTB_RD_MASTER_SFRWPRIV(base) ((MTB_MASTER_REG(base) & MTB_MASTER_SFRWPRIV_MASK) >> MTB_MASTER_SFRWPRIV_SHIFT)
#define MTB_BRD_MASTER_SFRWPRIV(base) (MTB_RD_MASTER_SFRWPRIV(base))

/*! @brief Set the SFRWPRIV field to a new value. */
#define MTB_WR_MASTER_SFRWPRIV(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_SFRWPRIV_MASK, MTB_MASTER_SFRWPRIV(value)))
#define MTB_BWR_MASTER_SFRWPRIV(base, value) (MTB_WR_MASTER_SFRWPRIV(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field RAMPRIV[8] (RW)
 *
 * If this field is 0, then user or privileged AHB read and write accesses to
 * the RAM are permitted. If this field is 1, then only privileged AHB read and
 * write accesses to the RAM are permitted and user accesses are RAZ/WI. The
 * HPROT[1] signal determines if an access is a user or privileged mode reference.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_RAMPRIV field. */
#define MTB_RD_MASTER_RAMPRIV(base) ((MTB_MASTER_REG(base) & MTB_MASTER_RAMPRIV_MASK) >> MTB_MASTER_RAMPRIV_SHIFT)
#define MTB_BRD_MASTER_RAMPRIV(base) (MTB_RD_MASTER_RAMPRIV(base))

/*! @brief Set the RAMPRIV field to a new value. */
#define MTB_WR_MASTER_RAMPRIV(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_RAMPRIV_MASK, MTB_MASTER_RAMPRIV(value)))
#define MTB_BWR_MASTER_RAMPRIV(base, value) (MTB_WR_MASTER_RAMPRIV(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field HALTREQ[9] (RW)
 *
 * This field is connected to the halt request signal of the trace logic,
 * EDBGRQ. When HALTREQ is set to 1, the EDBFGRQ is asserted if DBGEN (invasive debug
 * enable, one of the debug authentication interface signals) is also HIGH.
 * HALTREQ can be automatically set to 1 using MTB_FLOW[WATERMARK].
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_HALTREQ field. */
#define MTB_RD_MASTER_HALTREQ(base) ((MTB_MASTER_REG(base) & MTB_MASTER_HALTREQ_MASK) >> MTB_MASTER_HALTREQ_SHIFT)
#define MTB_BRD_MASTER_HALTREQ(base) (MTB_RD_MASTER_HALTREQ(base))

/*! @brief Set the HALTREQ field to a new value. */
#define MTB_WR_MASTER_HALTREQ(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_HALTREQ_MASK, MTB_MASTER_HALTREQ(value)))
#define MTB_BWR_MASTER_HALTREQ(base, value) (MTB_WR_MASTER_HALTREQ(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field EN[31] (RW)
 *
 * When this field is 1, trace data is written into the RAM memory location
 * addressed by MTB_POSITION[POINTER]. The MTB_POSITION[POINTER] value auto
 * increments after the trace data packet is written. EN can be automatically set to 0
 * using the MTB_FLOW[WATERMARK] field and the MTB_FLOW[AUTOSTOP] bit. EN is
 * automatically set to 1 if TSTARTEN is 1 and the TSTART signal is HIGH. EN is
 * automatically set to 0 if TSTOPEN is 1 and the TSTOP signal is HIGH. If EN is set to 0
 * because MTB_FLOW[WATERMARK] is set, then it is not automatically set to 1 if
 * TSTARTEN is 1 and the TSTART input is HIGH. In this case, tracing can only be
 * restarted if MTB_FLOW[WATERMARK] or MTB_POSITION[POINTER] value is changed by
 * software.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_EN field. */
#define MTB_RD_MASTER_EN(base) ((MTB_MASTER_REG(base) & MTB_MASTER_EN_MASK) >> MTB_MASTER_EN_SHIFT)
#define MTB_BRD_MASTER_EN(base) (MTB_RD_MASTER_EN(base))

/*! @brief Set the EN field to a new value. */
#define MTB_WR_MASTER_EN(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_EN_MASK, MTB_MASTER_EN(value)))
#define MTB_BWR_MASTER_EN(base, value) (MTB_WR_MASTER_EN(base, value))
/*@}*/

/*******************************************************************************
 * MTB_FLOW - MTB Flow Register
 ******************************************************************************/

/*!
 * @brief MTB_FLOW - MTB Flow Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTB_FLOW register contains the watermark address and the
 * autostop/autohalt control bits. If tracing is stopped using the watermark autostop feature, it
 * cannot be restarted until software clears the watermark autostop. This can be
 * achieved in one of the following ways: Changing the MTB_POSITION[POINTER]
 * field value to point to the beginning of the trace buffer, or Setting
 * MTB_FLOW[AUTOSTOP] = 0. A debug agent can use MTB_FLOW[AUTOSTOP] to fill the trace buffer
 * once only without halting the processor. A debug agent can use
 * MTB_FLOW[AUTOHALT] to fill the trace buffer once before causing the Cortex-M0+ processor to
 * enter the Debug state. To enter Debug state, the Cortex-M0+ processor might
 * have to perform additional branch type operations. Therefore, the
 * MTB_FLOW[WATERMARK] field must be set below the final entry in the trace buffer region.
 */
/*!
 * @name Constants and macros for entire MTB_FLOW register
 */
/*@{*/
#define MTB_RD_FLOW(base)        (MTB_FLOW_REG(base))
#define MTB_WR_FLOW(base, value) (MTB_FLOW_REG(base) = (value))
#define MTB_RMW_FLOW(base, mask, value) (MTB_WR_FLOW(base, (MTB_RD_FLOW(base) & ~(mask)) | (value)))
#define MTB_SET_FLOW(base, value) (MTB_WR_FLOW(base, MTB_RD_FLOW(base) |  (value)))
#define MTB_CLR_FLOW(base, value) (MTB_WR_FLOW(base, MTB_RD_FLOW(base) & ~(value)))
#define MTB_TOG_FLOW(base, value) (MTB_WR_FLOW(base, MTB_RD_FLOW(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTB_FLOW bitfields
 */

/*!
 * @name Register MTB_FLOW, field AUTOSTOP[0] (RW)
 *
 * If this field is 1 and WATERMARK is equal to MTB_POSITION[POINTER], then
 * MTB_MASTER[EN] is automatically set to 0. This stops tracing.
 */
/*@{*/
/*! @brief Read current value of the MTB_FLOW_AUTOSTOP field. */
#define MTB_RD_FLOW_AUTOSTOP(base) ((MTB_FLOW_REG(base) & MTB_FLOW_AUTOSTOP_MASK) >> MTB_FLOW_AUTOSTOP_SHIFT)
#define MTB_BRD_FLOW_AUTOSTOP(base) (MTB_RD_FLOW_AUTOSTOP(base))

/*! @brief Set the AUTOSTOP field to a new value. */
#define MTB_WR_FLOW_AUTOSTOP(base, value) (MTB_RMW_FLOW(base, MTB_FLOW_AUTOSTOP_MASK, MTB_FLOW_AUTOSTOP(value)))
#define MTB_BWR_FLOW_AUTOSTOP(base, value) (MTB_WR_FLOW_AUTOSTOP(base, value))
/*@}*/

/*!
 * @name Register MTB_FLOW, field AUTOHALT[1] (RW)
 *
 * If this field is 1 and WATERMARK is equal to MTB_POSITION[POINTER], then
 * MTB_MASTER[HALTREQ] is automatically set to 1. If the DBGEN signal is HIGH, the
 * MTB asserts this halt request to the Cortex-M0+ processor by asserting the
 * EDBGRQ signal.
 */
/*@{*/
/*! @brief Read current value of the MTB_FLOW_AUTOHALT field. */
#define MTB_RD_FLOW_AUTOHALT(base) ((MTB_FLOW_REG(base) & MTB_FLOW_AUTOHALT_MASK) >> MTB_FLOW_AUTOHALT_SHIFT)
#define MTB_BRD_FLOW_AUTOHALT(base) (MTB_RD_FLOW_AUTOHALT(base))

/*! @brief Set the AUTOHALT field to a new value. */
#define MTB_WR_FLOW_AUTOHALT(base, value) (MTB_RMW_FLOW(base, MTB_FLOW_AUTOHALT_MASK, MTB_FLOW_AUTOHALT(value)))
#define MTB_BWR_FLOW_AUTOHALT(base, value) (MTB_WR_FLOW_AUTOHALT(base, value))
/*@}*/

/*!
 * @name Register MTB_FLOW, field WATERMARK[31:3] (RW)
 *
 * This field contains an address in the same format as the
 * MTB_POSITION[POINTER] field. When MTB_POSITION[POINTER] matches the WATERMARK field value, actions
 * defined by the AUTOHALT and AUTOSTOP bits are performed.
 */
/*@{*/
/*! @brief Read current value of the MTB_FLOW_WATERMARK field. */
#define MTB_RD_FLOW_WATERMARK(base) ((MTB_FLOW_REG(base) & MTB_FLOW_WATERMARK_MASK) >> MTB_FLOW_WATERMARK_SHIFT)
#define MTB_BRD_FLOW_WATERMARK(base) (MTB_RD_FLOW_WATERMARK(base))

/*! @brief Set the WATERMARK field to a new value. */
#define MTB_WR_FLOW_WATERMARK(base, value) (MTB_RMW_FLOW(base, MTB_FLOW_WATERMARK_MASK, MTB_FLOW_WATERMARK(value)))
#define MTB_BWR_FLOW_WATERMARK(base, value) (MTB_WR_FLOW_WATERMARK(base, value))
/*@}*/

/*******************************************************************************
 * MTB_BASE - MTB Base Register
 ******************************************************************************/

/*!
 * @brief MTB_BASE - MTB Base Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The read-only MTB_BASE Register indicates where the RAM is located in the
 * system memory map. This register is provided to enable auto discovery of the MTB
 * RAM location, by a debug agent and is defined by a hardware design parameter.
 * For this device, the base address is defined by the expression:
 * MTB_BASE[BASEADDR] = 0x2000_0000 - (RAM_Size/4)
 */
/*!
 * @name Constants and macros for entire MTB_BASE register
 */
/*@{*/
#define MTB_RD_BASE(base)        (MTB_BASE_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_MODECTRL - Integration Mode Control Register
 ******************************************************************************/

/*!
 * @brief MTB_MODECTRL - Integration Mode Control Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register enables the device to switch from a functional mode, or default
 * behavior, into integration mode. It is hardwired to specific values used
 * during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_MODECTRL register
 */
/*@{*/
#define MTB_RD_MODECTRL(base)    (MTB_MODECTRL_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_TAGSET - Claim TAG Set Register
 ******************************************************************************/

/*!
 * @brief MTB_TAGSET - Claim TAG Set Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Claim Tag Set Register returns the number of bits that can be set on a
 * read, and enables individual bits to be set on a write. It is hardwired to
 * specific values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_TAGSET register
 */
/*@{*/
#define MTB_RD_TAGSET(base)      (MTB_TAGSET_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_TAGCLEAR - Claim TAG Clear Register
 ******************************************************************************/

/*!
 * @brief MTB_TAGCLEAR - Claim TAG Clear Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The read/write Claim Tag Clear Register is used to read the claim status on
 * debug resources. A read indicates the claim tag status. Writing 1 to a specific
 * bit clears the corresponding claim tag to 0. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_TAGCLEAR register
 */
/*@{*/
#define MTB_RD_TAGCLEAR(base)    (MTB_TAGCLEAR_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_LOCKACCESS - Lock Access Register
 ******************************************************************************/

/*!
 * @brief MTB_LOCKACCESS - Lock Access Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Lock Access Register enables a write access to component registers. It is
 * hardwired to specific values used during the auto-discovery process by an
 * external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_LOCKACCESS register
 */
/*@{*/
#define MTB_RD_LOCKACCESS(base)  (MTB_LOCKACCESS_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_LOCKSTAT - Lock Status Register
 ******************************************************************************/

/*!
 * @brief MTB_LOCKSTAT - Lock Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Lock Status Register indicates the status of the lock control mechanism.
 * This register is used in conjunction with the Lock Access Register. It is
 * hardwired to specific values used during the auto-discovery process by an external
 * debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_LOCKSTAT register
 */
/*@{*/
#define MTB_RD_LOCKSTAT(base)    (MTB_LOCKSTAT_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_AUTHSTAT - Authentication Status Register
 ******************************************************************************/

/*!
 * @brief MTB_AUTHSTAT - Authentication Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Authentication Status Register reports the required security level and
 * current status of the security enable bit pairs. Where functionality changes on
 * a given security level, this change must be reported in this register. It is
 * connected to specific signals used during the auto-discovery process by an
 * external debug agent. MTB_AUTHSTAT[3:2] indicates if nonsecure, noninvasive debug
 * is enabled or disabled, while MTB_AUTHSTAT[1:0] indicates the enabled/disabled
 * state of nonsecure, invasive debug. For both 2-bit fields, 0b10 indicates the
 * functionality is disabled and 0b11 indicates it is enabled.
 */
/*!
 * @name Constants and macros for entire MTB_AUTHSTAT register
 */
/*@{*/
#define MTB_RD_AUTHSTAT(base)    (MTB_AUTHSTAT_REG(base))
/*@}*/

/*
 * Constants & macros for individual MTB_AUTHSTAT bitfields
 */

/*!
 * @name Register MTB_AUTHSTAT, field BIT0[0] (RO)
 *
 * Connected to DBGEN.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT0 field. */
#define MTB_RD_AUTHSTAT_BIT0(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT0_MASK) >> MTB_AUTHSTAT_BIT0_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT0(base) (MTB_RD_AUTHSTAT_BIT0(base))
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT1[1] (ROO)
 *
 * Hardwired to 1.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT1 field. */
#define MTB_RD_AUTHSTAT_BIT1(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT1_MASK) >> MTB_AUTHSTAT_BIT1_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT1(base) (MTB_RD_AUTHSTAT_BIT1(base))
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT2[2] (RO)
 *
 * Connected to NIDEN or DBGEN signal.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT2 field. */
#define MTB_RD_AUTHSTAT_BIT2(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT2_MASK) >> MTB_AUTHSTAT_BIT2_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT2(base) (MTB_RD_AUTHSTAT_BIT2(base))
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT3[3] (ROO)
 *
 * Hardwired to 1.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT3 field. */
#define MTB_RD_AUTHSTAT_BIT3(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT3_MASK) >> MTB_AUTHSTAT_BIT3_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT3(base) (MTB_RD_AUTHSTAT_BIT3(base))
/*@}*/

/*******************************************************************************
 * MTB_DEVICEARCH - Device Architecture Register
 ******************************************************************************/

/*!
 * @brief MTB_DEVICEARCH - Device Architecture Register (RO)
 *
 * Reset value: 0x47700A31U
 *
 * This register indicates the device architecture. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_DEVICEARCH register
 */
/*@{*/
#define MTB_RD_DEVICEARCH(base)  (MTB_DEVICEARCH_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_DEVICECFG - Device Configuration Register
 ******************************************************************************/

/*!
 * @brief MTB_DEVICECFG - Device Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates the device configuration. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_DEVICECFG register
 */
/*@{*/
#define MTB_RD_DEVICECFG(base)   (MTB_DEVICECFG_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_DEVICETYPID - Device Type Identifier Register
 ******************************************************************************/

/*!
 * @brief MTB_DEVICETYPID - Device Type Identifier Register (RO)
 *
 * Reset value: 0x00000031U
 *
 * This register indicates the device type ID. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_DEVICETYPID register
 */
/*@{*/
#define MTB_RD_DEVICETYPID(base) (MTB_DEVICETYPID_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_PERIPHID - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief MTB_PERIPHID - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_PERIPHID register
 */
/*@{*/
#define MTB_RD_PERIPHID(base, index) (MTB_PERIPHID_REG(base, index))
/*@}*/

/*******************************************************************************
 * MTB_COMPID - Component ID Register
 ******************************************************************************/

/*!
 * @brief MTB_COMPID - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_COMPID register
 */
/*@{*/
#define MTB_RD_COMPID(base, index) (MTB_COMPID_REG(base, index))
/*@}*/

/*
 * MKV10Z7 MTBDWT
 *
 * MTB data watchpoint and trace
 *
 * Registers defined in this header file:
 * - MTBDWT_CTRL - MTB DWT Control Register
 * - MTBDWT_COMP - MTB_DWT Comparator Register
 * - MTBDWT_MASK - MTB_DWT Comparator Mask Register
 * - MTBDWT_FCT - MTB_DWT Comparator Function Register 0
 * - MTBDWT_TBCTRL - MTB_DWT Trace Buffer Control Register
 * - MTBDWT_DEVICECFG - Device Configuration Register
 * - MTBDWT_DEVICETYPID - Device Type Identifier Register
 * - MTBDWT_PERIPHID - Peripheral ID Register
 * - MTBDWT_COMPID - Component ID Register
 */

#define MTBDWT_INSTANCE_COUNT (1U) /*!< Number of instances of the MTBDWT module. */
#define MTBDWT_IDX (0U) /*!< Instance number for MTBDWT. */

/*******************************************************************************
 * MTBDWT_CTRL - MTB DWT Control Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_CTRL - MTB DWT Control Register (RO)
 *
 * Reset value: 0x2F000000U
 *
 * The MTBDWT_CTRL register provides read-only information on the watchpoint
 * configuration for the MTB_DWT.
 */
/*!
 * @name Constants and macros for entire MTBDWT_CTRL register
 */
/*@{*/
#define MTBDWT_RD_CTRL(base)     (MTBDWT_CTRL_REG(base))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_CTRL bitfields
 */

/*!
 * @name Register MTBDWT_CTRL, field DWTCFGCTRL[27:0] (RO)
 *
 * This field is hardwired to 0xF00_0000, disabling all the remaining DWT
 * functionality. The specific fields and their state are: MTBDWT_CTRL[27] = NOTRCPKT =
 * 1, trace sample and exception trace is not supported MTBDWT_CTRL[26] =
 * NOEXTTRIG = 1, external match signals are not supported MTBDWT_CTRL[25] = NOCYCCNT =
 * 1, cycle counter is not supported MTBDWT_CTRL[24] = NOPRFCNT = 1, profiling
 * counters are not supported MTBDWT_CTRL[22] = CYCEBTENA = 0, no POSTCNT
 * underflow packets generated MTBDWT_CTRL[21] = FOLDEVTENA = 0, no folded instruction
 * counter overflow events MTBDWT_CTRL[20] = LSUEVTENA = 0, no LSU counter overflow
 * events MTBDWT_CTRL[19] = SLEEPEVTENA = 0, no sleep counter overflow events
 * MTBDWT_CTRL[18] = EXCEVTENA = 0, no exception overhead counter events
 * MTBDWT_CTRL[17] = CPIEVTENA = 0, no CPI counter overflow events MTBDWT_CTRL[16] =
 * EXCTRCENA = 0, generation of exception trace disabled MTBDWT_CTRL[12] = PCSAMPLENA =
 * 0, no periodic PC sample packets generated MTBDWT_CTRL[11:10] = SYNCTAP = 0,
 * no synchronization packets MTBDWT_CTRL[9] = CYCTAP = 0, cycle counter is not
 * supported MTBDWT_CTRL[8:5] = POSTINIT = 0, cycle counter is not supported
 * MTBDWT_CTRL[4:1] = POSTPRESET = 0, cycle counter is not supported MTBDWT_CTRL[0] =
 * CYCCNTENA = 0, cycle counter is not supported
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_CTRL_DWTCFGCTRL field. */
#define MTBDWT_RD_CTRL_DWTCFGCTRL(base) ((MTBDWT_CTRL_REG(base) & MTBDWT_CTRL_DWTCFGCTRL_MASK) >> MTBDWT_CTRL_DWTCFGCTRL_SHIFT)
#define MTBDWT_BRD_CTRL_DWTCFGCTRL(base) (MTBDWT_RD_CTRL_DWTCFGCTRL(base))
/*@}*/

/*!
 * @name Register MTBDWT_CTRL, field NUMCMP[31:28] (RO)
 *
 * The MTB_DWT implements two comparators.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_CTRL_NUMCMP field. */
#define MTBDWT_RD_CTRL_NUMCMP(base) ((MTBDWT_CTRL_REG(base) & MTBDWT_CTRL_NUMCMP_MASK) >> MTBDWT_CTRL_NUMCMP_SHIFT)
#define MTBDWT_BRD_CTRL_NUMCMP(base) (MTBDWT_RD_CTRL_NUMCMP(base))
/*@}*/

/*******************************************************************************
 * MTBDWT_COMP - MTB_DWT Comparator Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_COMP - MTB_DWT Comparator Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_COMPn registers provide the reference value for comparator n.
 */
/*!
 * @name Constants and macros for entire MTBDWT_COMP register
 */
/*@{*/
#define MTBDWT_RD_COMP(base, index) (MTBDWT_COMP_REG(base, index))
#define MTBDWT_WR_COMP(base, index, value) (MTBDWT_COMP_REG(base, index) = (value))
#define MTBDWT_RMW_COMP(base, index, mask, value) (MTBDWT_WR_COMP(base, index, (MTBDWT_RD_COMP(base, index) & ~(mask)) | (value)))
#define MTBDWT_SET_COMP(base, index, value) (MTBDWT_WR_COMP(base, index, MTBDWT_RD_COMP(base, index) |  (value)))
#define MTBDWT_CLR_COMP(base, index, value) (MTBDWT_WR_COMP(base, index, MTBDWT_RD_COMP(base, index) & ~(value)))
#define MTBDWT_TOG_COMP(base, index, value) (MTBDWT_WR_COMP(base, index, MTBDWT_RD_COMP(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * MTBDWT_MASK - MTB_DWT Comparator Mask Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_MASK - MTB_DWT Comparator Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_MASKn registers define the size of the ignore mask applied to the
 * reference address for address range matching by comparator n. Note the format
 * of this mask field is different than the MTB_MASTER[MASK].
 */
/*!
 * @name Constants and macros for entire MTBDWT_MASK register
 */
/*@{*/
#define MTBDWT_RD_MASK(base, index) (MTBDWT_MASK_REG(base, index))
#define MTBDWT_WR_MASK(base, index, value) (MTBDWT_MASK_REG(base, index) = (value))
#define MTBDWT_RMW_MASK(base, index, mask, value) (MTBDWT_WR_MASK(base, index, (MTBDWT_RD_MASK(base, index) & ~(mask)) | (value)))
#define MTBDWT_SET_MASK(base, index, value) (MTBDWT_WR_MASK(base, index, MTBDWT_RD_MASK(base, index) |  (value)))
#define MTBDWT_CLR_MASK(base, index, value) (MTBDWT_WR_MASK(base, index, MTBDWT_RD_MASK(base, index) & ~(value)))
#define MTBDWT_TOG_MASK(base, index, value) (MTBDWT_WR_MASK(base, index, MTBDWT_RD_MASK(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_MASK bitfields
 */

/*!
 * @name Register MTBDWT_MASK, field MASK[4:0] (RW)
 *
 * The value of the ignore mask, 0-31 bits, is applied to address range
 * matching. MASK = 0 is used to include all bits of the address in the comparison,
 * except if MASK = 0 and the comparator is configured to watch instruction fetch
 * addresses, address bit [0] is ignored by the hardware since all fetches must be at
 * least halfword aligned. For MASK != 0 and regardless of watch type, address
 * bits [x-1:0] are ignored in the address comparison. Using a mask means the
 * comparator matches on a range of addresses, defined by the unmasked most
 * significant bits of the address, bits [31:x]. The maximum MASK value is 24, producing a
 * 16 Mbyte mask. An attempted write of a MASK value > 24 is limited by the
 * MTBDWT hardware to 24. If MTBDWT_COMP0 is used as a data value comparator, then
 * MTBDWT_MASK0 should be programmed to zero.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_MASK_MASK field. */
#define MTBDWT_RD_MASK_MASK(base, index) ((MTBDWT_MASK_REG(base, index) & MTBDWT_MASK_MASK_MASK) >> MTBDWT_MASK_MASK_SHIFT)
#define MTBDWT_BRD_MASK_MASK(base, index) (MTBDWT_RD_MASK_MASK(base, index))

/*! @brief Set the MASK field to a new value. */
#define MTBDWT_WR_MASK_MASK(base, index, value) (MTBDWT_RMW_MASK(base, index, MTBDWT_MASK_MASK_MASK, MTBDWT_MASK_MASK(value)))
#define MTBDWT_BWR_MASK_MASK(base, index, value) (MTBDWT_WR_MASK_MASK(base, index, value))
/*@}*/

/*******************************************************************************
 * MTBDWT_FCT - MTB_DWT Comparator Function Register 0
 ******************************************************************************/

/*!
 * @brief MTBDWT_FCT - MTB_DWT Comparator Function Register 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_FCTn registers control the operation of comparator n.
 */
/*!
 * @name Constants and macros for entire MTBDWT_FCT register
 */
/*@{*/
#define MTBDWT_RD_FCT(base, index) (MTBDWT_FCT_REG(base, index))
#define MTBDWT_WR_FCT(base, index, value) (MTBDWT_FCT_REG(base, index) = (value))
#define MTBDWT_RMW_FCT(base, index, mask, value) (MTBDWT_WR_FCT(base, index, (MTBDWT_RD_FCT(base, index) & ~(mask)) | (value)))
#define MTBDWT_SET_FCT(base, index, value) (MTBDWT_WR_FCT(base, index, MTBDWT_RD_FCT(base, index) |  (value)))
#define MTBDWT_CLR_FCT(base, index, value) (MTBDWT_WR_FCT(base, index, MTBDWT_RD_FCT(base, index) & ~(value)))
#define MTBDWT_TOG_FCT(base, index, value) (MTBDWT_WR_FCT(base, index, MTBDWT_RD_FCT(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_FCT bitfields
 */

/*!
 * @name Register MTBDWT_FCT, field FUNCTION[3:0] (RW)
 *
 * Selects the action taken on a comparator match. If MTBDWT_COMP0 is used for a
 * data value and MTBDWT_COMP1 for an address value, then MTBDWT_FCT1[FUNCTION]
 * must be set to zero. For this configuration, MTBDWT_MASK1 can be set to a
 * non-zero value, so the combined comparators match on a range of addresses.
 *
 * Values:
 * - 0000 - Disabled.
 * - 0100 - Instruction fetch.
 * - 0101 - Data operand read.
 * - 0110 - Data operand write.
 * - 0111 - Data operand (read + write).
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_FUNCTION field. */
#define MTBDWT_RD_FCT_FUNCTION(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_FUNCTION_MASK) >> MTBDWT_FCT_FUNCTION_SHIFT)
#define MTBDWT_BRD_FCT_FUNCTION(base, index) (MTBDWT_RD_FCT_FUNCTION(base, index))

/*! @brief Set the FUNCTION field to a new value. */
#define MTBDWT_WR_FCT_FUNCTION(base, index, value) (MTBDWT_RMW_FCT(base, index, MTBDWT_FCT_FUNCTION_MASK, MTBDWT_FCT_FUNCTION(value)))
#define MTBDWT_BWR_FCT_FUNCTION(base, index, value) (MTBDWT_WR_FCT_FUNCTION(base, index, value))
/*@}*/

/*!
 * @name Register MTBDWT_FCT, field DATAVMATCH[8] (RW)
 *
 * When this field is 1, it enables data value comparison. For this
 * implementation, MTBDWT_COMP0 supports address or data value comparisons; MTBDWT_COMP1 only
 * supports address comparisons.
 *
 * Values:
 * - 0 - Perform address comparison.
 * - 1 - Perform data value comparison.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_DATAVMATCH field. */
#define MTBDWT_RD_FCT_DATAVMATCH(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_DATAVMATCH_MASK) >> MTBDWT_FCT_DATAVMATCH_SHIFT)
#define MTBDWT_BRD_FCT_DATAVMATCH(base, index) (MTBDWT_RD_FCT_DATAVMATCH(base, index))

/*! @brief Set the DATAVMATCH field to a new value. */
#define MTBDWT_WR_FCT_DATAVMATCH(base, index, value) (MTBDWT_RMW_FCT(base, index, MTBDWT_FCT_DATAVMATCH_MASK, MTBDWT_FCT_DATAVMATCH(value)))
#define MTBDWT_BWR_FCT_DATAVMATCH(base, index, value) (MTBDWT_WR_FCT_DATAVMATCH(base, index, value))
/*@}*/

/*!
 * @name Register MTBDWT_FCT, field DATAVSIZE[11:10] (RW)
 *
 * For data value matching, this field defines the size of the required data
 * comparison.
 *
 * Values:
 * - 00 - Byte.
 * - 01 - Halfword.
 * - 10 - Word.
 * - 11 - Reserved. Any attempts to use this value results in UNPREDICTABLE
 *     behavior.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_DATAVSIZE field. */
#define MTBDWT_RD_FCT_DATAVSIZE(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_DATAVSIZE_MASK) >> MTBDWT_FCT_DATAVSIZE_SHIFT)
#define MTBDWT_BRD_FCT_DATAVSIZE(base, index) (MTBDWT_RD_FCT_DATAVSIZE(base, index))

/*! @brief Set the DATAVSIZE field to a new value. */
#define MTBDWT_WR_FCT_DATAVSIZE(base, index, value) (MTBDWT_RMW_FCT(base, index, MTBDWT_FCT_DATAVSIZE_MASK, MTBDWT_FCT_DATAVSIZE(value)))
#define MTBDWT_BWR_FCT_DATAVSIZE(base, index, value) (MTBDWT_WR_FCT_DATAVSIZE(base, index, value))
/*@}*/

/*!
 * @name Register MTBDWT_FCT, field DATAVADDR0[15:12] (RW)
 *
 * Since the MTB_DWT implements two comparators, the DATAVADDR0 field is
 * restricted to values {0,1}. When the DATAVMATCH bit is asserted, this field defines
 * the comparator number to use for linked address comparison. If MTBDWT_COMP0 is
 * used as a data watchpoint and MTBDWT_COMP1 as an address watchpoint,
 * DATAVADDR0 must be set.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_DATAVADDR0 field. */
#define MTBDWT_RD_FCT_DATAVADDR0(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_DATAVADDR0_MASK) >> MTBDWT_FCT_DATAVADDR0_SHIFT)
#define MTBDWT_BRD_FCT_DATAVADDR0(base, index) (MTBDWT_RD_FCT_DATAVADDR0(base, index))

/*! @brief Set the DATAVADDR0 field to a new value. */
#define MTBDWT_WR_FCT_DATAVADDR0(base, index, value) (MTBDWT_RMW_FCT(base, index, MTBDWT_FCT_DATAVADDR0_MASK, MTBDWT_FCT_DATAVADDR0(value)))
#define MTBDWT_BWR_FCT_DATAVADDR0(base, index, value) (MTBDWT_WR_FCT_DATAVADDR0(base, index, value))
/*@}*/

/*!
 * @name Register MTBDWT_FCT, field MATCHED[24] (RO)
 *
 * If this read-only flag is asserted, it indicates the operation defined by the
 * FUNCTION field occurred since the last read of the register. Reading the
 * register clears this bit.
 *
 * Values:
 * - 0 - No match.
 * - 1 - Match occurred.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_MATCHED field. */
#define MTBDWT_RD_FCT_MATCHED(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_MATCHED_MASK) >> MTBDWT_FCT_MATCHED_SHIFT)
#define MTBDWT_BRD_FCT_MATCHED(base, index) (MTBDWT_RD_FCT_MATCHED(base, index))
/*@}*/

/*******************************************************************************
 * MTBDWT_TBCTRL - MTB_DWT Trace Buffer Control Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_TBCTRL - MTB_DWT Trace Buffer Control Register (RW)
 *
 * Reset value: 0x20000000U
 *
 * The MTBDWT_TBCTRL register defines how the watchpoint comparisons control the
 * actual trace buffer operation. Recall the MTB supports starting and stopping
 * the program trace based on the watchpoint comparisons signaled via TSTART and
 * TSTOP. The watchpoint comparison signals are enabled in the MTB's control
 * logic by setting the appropriate enable bits, MTB_MASTER[TSTARTEN, TSTOPEN]. In
 * the event of simultaneous assertion of both TSTART and TSTOP, TSTART takes
 * priority.
 */
/*!
 * @name Constants and macros for entire MTBDWT_TBCTRL register
 */
/*@{*/
#define MTBDWT_RD_TBCTRL(base)   (MTBDWT_TBCTRL_REG(base))
#define MTBDWT_WR_TBCTRL(base, value) (MTBDWT_TBCTRL_REG(base) = (value))
#define MTBDWT_RMW_TBCTRL(base, mask, value) (MTBDWT_WR_TBCTRL(base, (MTBDWT_RD_TBCTRL(base) & ~(mask)) | (value)))
#define MTBDWT_SET_TBCTRL(base, value) (MTBDWT_WR_TBCTRL(base, MTBDWT_RD_TBCTRL(base) |  (value)))
#define MTBDWT_CLR_TBCTRL(base, value) (MTBDWT_WR_TBCTRL(base, MTBDWT_RD_TBCTRL(base) & ~(value)))
#define MTBDWT_TOG_TBCTRL(base, value) (MTBDWT_WR_TBCTRL(base, MTBDWT_RD_TBCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_TBCTRL bitfields
 */

/*!
 * @name Register MTBDWT_TBCTRL, field ACOMP0[0] (RW)
 *
 * When the MTBDWT_FCT0[MATCHED] is set, it indicates MTBDWT_COMP0 address
 * compare has triggered and the trace buffer's recording state is changed. The
 * assertion of MTBDWT_FCT0[MATCHED] is caused by the following conditions: Address
 * match in MTBDWT_COMP0 when MTBDWT_FCT0[DATAVMATCH] = 0 Data match in MTBDWT_COMP0
 * when MTBDWT_FCT0[DATAVMATCH, DATAVADDR0] = {1,0} Data match in MTBDWT_COMP0
 * and address match in MTBDWT_COMP1 when MTBDWT_FCT0[DATAVMATCH, DATAVADDR0] =
 * {1,1}
 *
 * Values:
 * - 0 - Trigger TSTOP based on the assertion of MTBDWT_FCT0[MATCHED].
 * - 1 - Trigger TSTART based on the assertion of MTBDWT_FCT0[MATCHED].
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_TBCTRL_ACOMP0 field. */
#define MTBDWT_RD_TBCTRL_ACOMP0(base) ((MTBDWT_TBCTRL_REG(base) & MTBDWT_TBCTRL_ACOMP0_MASK) >> MTBDWT_TBCTRL_ACOMP0_SHIFT)
#define MTBDWT_BRD_TBCTRL_ACOMP0(base) (MTBDWT_RD_TBCTRL_ACOMP0(base))

/*! @brief Set the ACOMP0 field to a new value. */
#define MTBDWT_WR_TBCTRL_ACOMP0(base, value) (MTBDWT_RMW_TBCTRL(base, MTBDWT_TBCTRL_ACOMP0_MASK, MTBDWT_TBCTRL_ACOMP0(value)))
#define MTBDWT_BWR_TBCTRL_ACOMP0(base, value) (MTBDWT_WR_TBCTRL_ACOMP0(base, value))
/*@}*/

/*!
 * @name Register MTBDWT_TBCTRL, field ACOMP1[1] (RW)
 *
 * When the MTBDWT_FCT1[MATCHED] is set, it indicates MTBDWT_COMP1 address
 * compare has triggered and the trace buffer's recording state is changed.
 *
 * Values:
 * - 0 - Trigger TSTOP based on the assertion of MTBDWT_FCT1[MATCHED].
 * - 1 - Trigger TSTART based on the assertion of MTBDWT_FCT1[MATCHED].
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_TBCTRL_ACOMP1 field. */
#define MTBDWT_RD_TBCTRL_ACOMP1(base) ((MTBDWT_TBCTRL_REG(base) & MTBDWT_TBCTRL_ACOMP1_MASK) >> MTBDWT_TBCTRL_ACOMP1_SHIFT)
#define MTBDWT_BRD_TBCTRL_ACOMP1(base) (MTBDWT_RD_TBCTRL_ACOMP1(base))

/*! @brief Set the ACOMP1 field to a new value. */
#define MTBDWT_WR_TBCTRL_ACOMP1(base, value) (MTBDWT_RMW_TBCTRL(base, MTBDWT_TBCTRL_ACOMP1_MASK, MTBDWT_TBCTRL_ACOMP1(value)))
#define MTBDWT_BWR_TBCTRL_ACOMP1(base, value) (MTBDWT_WR_TBCTRL_ACOMP1(base, value))
/*@}*/

/*!
 * @name Register MTBDWT_TBCTRL, field NUMCOMP[31:28] (RO)
 *
 * This read-only field specifies the number of comparators in the MTB_DWT. This
 * implementation includes two registers.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_TBCTRL_NUMCOMP field. */
#define MTBDWT_RD_TBCTRL_NUMCOMP(base) ((MTBDWT_TBCTRL_REG(base) & MTBDWT_TBCTRL_NUMCOMP_MASK) >> MTBDWT_TBCTRL_NUMCOMP_SHIFT)
#define MTBDWT_BRD_TBCTRL_NUMCOMP(base) (MTBDWT_RD_TBCTRL_NUMCOMP(base))
/*@}*/

/*******************************************************************************
 * MTBDWT_DEVICECFG - Device Configuration Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_DEVICECFG - Device Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates the device configuration. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTBDWT_DEVICECFG register
 */
/*@{*/
#define MTBDWT_RD_DEVICECFG(base) (MTBDWT_DEVICECFG_REG(base))
/*@}*/

/*******************************************************************************
 * MTBDWT_DEVICETYPID - Device Type Identifier Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_DEVICETYPID - Device Type Identifier Register (RO)
 *
 * Reset value: 0x00000004U
 *
 * This register indicates the device type ID. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTBDWT_DEVICETYPID register
 */
/*@{*/
#define MTBDWT_RD_DEVICETYPID(base) (MTBDWT_DEVICETYPID_REG(base))
/*@}*/

/*******************************************************************************
 * MTBDWT_PERIPHID - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_PERIPHID - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTBDWT_PERIPHID register
 */
/*@{*/
#define MTBDWT_RD_PERIPHID(base, index) (MTBDWT_PERIPHID_REG(base, index))
/*@}*/

/*******************************************************************************
 * MTBDWT_COMPID - Component ID Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_COMPID - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTBDWT_COMPID register
 */
/*@{*/
#define MTBDWT_RD_COMPID(base, index) (MTBDWT_COMPID_REG(base, index))
/*@}*/

/*
 * MKV10Z7 NV
 *
 * Flash configuration field
 *
 * Registers defined in this header file:
 * - NV_BACKKEY3 - Backdoor Comparison Key 3.
 * - NV_BACKKEY2 - Backdoor Comparison Key 2.
 * - NV_BACKKEY1 - Backdoor Comparison Key 1.
 * - NV_BACKKEY0 - Backdoor Comparison Key 0.
 * - NV_BACKKEY7 - Backdoor Comparison Key 7.
 * - NV_BACKKEY6 - Backdoor Comparison Key 6.
 * - NV_BACKKEY5 - Backdoor Comparison Key 5.
 * - NV_BACKKEY4 - Backdoor Comparison Key 4.
 * - NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 * - NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 * - NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 * - NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 * - NV_FSEC - Non-volatile Flash Security Register
 * - NV_FOPT - Non-volatile Flash Option Register
 */

#define NV_INSTANCE_COUNT (1U) /*!< Number of instances of the NV module. */
#define FTFA_FlashConfig_IDX (0U) /*!< Instance number for FTFA_FlashConfig. */

/*******************************************************************************
 * NV_BACKKEY3 - Backdoor Comparison Key 3.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY3 - Backdoor Comparison Key 3. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY3 register
 */
/*@{*/
#define NV_RD_BACKKEY3(base)     (NV_BACKKEY3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY2 - Backdoor Comparison Key 2.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY2 - Backdoor Comparison Key 2. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY2 register
 */
/*@{*/
#define NV_RD_BACKKEY2(base)     (NV_BACKKEY2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY1 - Backdoor Comparison Key 1.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY1 - Backdoor Comparison Key 1. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY1 register
 */
/*@{*/
#define NV_RD_BACKKEY1(base)     (NV_BACKKEY1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY0 - Backdoor Comparison Key 0.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY0 - Backdoor Comparison Key 0. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY0 register
 */
/*@{*/
#define NV_RD_BACKKEY0(base)     (NV_BACKKEY0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY7 - Backdoor Comparison Key 7.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY7 - Backdoor Comparison Key 7. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY7 register
 */
/*@{*/
#define NV_RD_BACKKEY7(base)     (NV_BACKKEY7_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY6 - Backdoor Comparison Key 6.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY6 - Backdoor Comparison Key 6. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY6 register
 */
/*@{*/
#define NV_RD_BACKKEY6(base)     (NV_BACKKEY6_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY5 - Backdoor Comparison Key 5.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY5 - Backdoor Comparison Key 5. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY5 register
 */
/*@{*/
#define NV_RD_BACKKEY5(base)     (NV_BACKKEY5_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY4 - Backdoor Comparison Key 4.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY4 - Backdoor Comparison Key 4. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY4 register
 */
/*@{*/
#define NV_RD_BACKKEY4(base)     (NV_BACKKEY4_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT3 register
 */
/*@{*/
#define NV_RD_FPROT3(base)       (NV_FPROT3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT2 register
 */
/*@{*/
#define NV_RD_FPROT2(base)       (NV_FPROT2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT1 register
 */
/*@{*/
#define NV_RD_FPROT1(base)       (NV_FPROT1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT0 register
 */
/*@{*/
#define NV_RD_FPROT0(base)       (NV_FPROT0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FSEC - Non-volatile Flash Security Register
 ******************************************************************************/

/*!
 * @brief NV_FSEC - Non-volatile Flash Security Register (RO)
 *
 * Reset value: 0xFFU
 *
 * Allows the user to customize the operation of the MCU at boot time
 */
/*!
 * @name Constants and macros for entire NV_FSEC register
 */
/*@{*/
#define NV_RD_FSEC(base)         (NV_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FSEC bitfields
 */

/*!
 * @name Register NV_FSEC, field SEC[1:0] (RO)
 *
 * Values:
 * - 10 - MCU security status is unsecure
 * - 11 - MCU security status is secure
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_SEC field. */
#define NV_RD_FSEC_SEC(base) ((NV_FSEC_REG(base) & NV_FSEC_SEC_MASK) >> NV_FSEC_SEC_SHIFT)
#define NV_BRD_FSEC_SEC(base) (NV_RD_FSEC_SEC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field FSLACC[3:2] (RO)
 *
 * Values:
 * - 10 - Freescale factory access denied
 * - 11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_FSLACC field. */
#define NV_RD_FSEC_FSLACC(base) ((NV_FSEC_REG(base) & NV_FSEC_FSLACC_MASK) >> NV_FSEC_FSLACC_SHIFT)
#define NV_BRD_FSEC_FSLACC(base) (NV_RD_FSEC_FSLACC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field MEEN[5:4] (RO)
 *
 * Values:
 * - 10 - Mass erase is disabled
 * - 11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_MEEN field. */
#define NV_RD_FSEC_MEEN(base) ((NV_FSEC_REG(base) & NV_FSEC_MEEN_MASK) >> NV_FSEC_MEEN_SHIFT)
#define NV_BRD_FSEC_MEEN(base) (NV_RD_FSEC_MEEN(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field KEYEN[7:6] (RO)
 *
 * Values:
 * - 10 - Backdoor key access enabled
 * - 11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_KEYEN field. */
#define NV_RD_FSEC_KEYEN(base) ((NV_FSEC_REG(base) & NV_FSEC_KEYEN_MASK) >> NV_FSEC_KEYEN_SHIFT)
#define NV_BRD_FSEC_KEYEN(base) (NV_RD_FSEC_KEYEN(base))
/*@}*/

/*******************************************************************************
 * NV_FOPT - Non-volatile Flash Option Register
 ******************************************************************************/

/*!
 * @brief NV_FOPT - Non-volatile Flash Option Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FOPT register
 */
/*@{*/
#define NV_RD_FOPT(base)         (NV_FOPT_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FOPT bitfields
 */

/*!
 * @name Register NV_FOPT, field LPBOOT0[0] (RO)
 *
 * Values:
 * - 00 - Core and system clock divider (OUTDIV1) is 0x7 (divide by 8) when
 *     LPBOOT1=0 or 0x1 (divide by 2) when LPBOOT1=1.
 * - 01 - Core and system clock divider (OUTDIV1) is 0x3 (divide by 4) when
 *     LPBOOT1=0 or 0x0 (divide by 1) when LPBOOT1=1.
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_LPBOOT0 field. */
#define NV_RD_FOPT_LPBOOT0(base) ((NV_FOPT_REG(base) & NV_FOPT_LPBOOT0_MASK) >> NV_FOPT_LPBOOT0_SHIFT)
#define NV_BRD_FOPT_LPBOOT0(base) (NV_RD_FOPT_LPBOOT0(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field NMI_DIS[2] (RO)
 *
 * Values:
 * - 00 - NMI interrupts are always blocked
 * - 01 - NMI_b pin/interrupts reset default to enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_NMI_DIS field. */
#define NV_RD_FOPT_NMI_DIS(base) ((NV_FOPT_REG(base) & NV_FOPT_NMI_DIS_MASK) >> NV_FOPT_NMI_DIS_SHIFT)
#define NV_BRD_FOPT_NMI_DIS(base) (NV_RD_FOPT_NMI_DIS(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field RESET_PIN_CFG[3] (RO)
 *
 * Values:
 * - 00 - RESET pin is disabled following a POR and cannot be enabled as reset
 *     function
 * - 01 - RESET_b pin is dedicated
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_RESET_PIN_CFG field. */
#define NV_RD_FOPT_RESET_PIN_CFG(base) ((NV_FOPT_REG(base) & NV_FOPT_RESET_PIN_CFG_MASK) >> NV_FOPT_RESET_PIN_CFG_SHIFT)
#define NV_BRD_FOPT_RESET_PIN_CFG(base) (NV_RD_FOPT_RESET_PIN_CFG(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field LPBOOT1[4] (RO)
 *
 * Values:
 * - 00 - Core and system clock divider (OUTDIV1) is 0x7 (divide by 8) when
 *     LPBOOT0=0 or 0x3 (divide by 4) when LPBOOT0=1.
 * - 01 - Core and system clock divider (OUTDIV1) is 0x1 (divide by 2) when
 *     LPBOOT0=0 or 0x0 (divide by 1) when LPBOOT0=1.
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_LPBOOT1 field. */
#define NV_RD_FOPT_LPBOOT1(base) ((NV_FOPT_REG(base) & NV_FOPT_LPBOOT1_MASK) >> NV_FOPT_LPBOOT1_SHIFT)
#define NV_BRD_FOPT_LPBOOT1(base) (NV_RD_FOPT_LPBOOT1(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field FAST_INIT[5] (RO)
 *
 * Values:
 * - 00 - Slower initialization
 * - 01 - Fast Initialization
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_FAST_INIT field. */
#define NV_RD_FOPT_FAST_INIT(base) ((NV_FOPT_REG(base) & NV_FOPT_FAST_INIT_MASK) >> NV_FOPT_FAST_INIT_SHIFT)
#define NV_BRD_FOPT_FAST_INIT(base) (NV_RD_FOPT_FAST_INIT(base))
/*@}*/

/*
 * MKV10Z7 OSC
 *
 * Oscillator
 *
 * Registers defined in this header file:
 * - OSC_CR - OSC Control Register
 */

#define OSC_INSTANCE_COUNT (1U) /*!< Number of instances of the OSC module. */
#define OSC0_IDX (0U) /*!< Instance number for OSC0. */

/*******************************************************************************
 * OSC_CR - OSC Control Register
 ******************************************************************************/

/*!
 * @brief OSC_CR - OSC Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * After OSC is enabled and starts generating the clocks, the configurations
 * such as low power and frequency range, must not be changed.
 */
/*!
 * @name Constants and macros for entire OSC_CR register
 */
/*@{*/
#define OSC_RD_CR(base)          (OSC_CR_REG(base))
#define OSC_WR_CR(base, value)   (OSC_CR_REG(base) = (value))
#define OSC_RMW_CR(base, mask, value) (OSC_WR_CR(base, (OSC_RD_CR(base) & ~(mask)) | (value)))
#define OSC_SET_CR(base, value)  (BME_OR8(&OSC_CR_REG(base), (uint8_t)(value)))
#define OSC_CLR_CR(base, value)  (BME_AND8(&OSC_CR_REG(base), (uint8_t)(~(value))))
#define OSC_TOG_CR(base, value)  (BME_XOR8(&OSC_CR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual OSC_CR bitfields
 */

/*!
 * @name Register OSC_CR, field SC16P[0] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 16 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC16P field. */
#define OSC_RD_CR_SC16P(base) ((OSC_CR_REG(base) & OSC_CR_SC16P_MASK) >> OSC_CR_SC16P_SHIFT)
#define OSC_BRD_CR_SC16P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC16P_SHIFT, OSC_CR_SC16P_WIDTH))

/*! @brief Set the SC16P field to a new value. */
#define OSC_WR_CR_SC16P(base, value) (OSC_RMW_CR(base, OSC_CR_SC16P_MASK, OSC_CR_SC16P(value)))
#define OSC_BWR_CR_SC16P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC16P_SHIFT), OSC_CR_SC16P_SHIFT, OSC_CR_SC16P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field SC8P[1] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 8 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC8P field. */
#define OSC_RD_CR_SC8P(base) ((OSC_CR_REG(base) & OSC_CR_SC8P_MASK) >> OSC_CR_SC8P_SHIFT)
#define OSC_BRD_CR_SC8P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC8P_SHIFT, OSC_CR_SC8P_WIDTH))

/*! @brief Set the SC8P field to a new value. */
#define OSC_WR_CR_SC8P(base, value) (OSC_RMW_CR(base, OSC_CR_SC8P_MASK, OSC_CR_SC8P(value)))
#define OSC_BWR_CR_SC8P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC8P_SHIFT), OSC_CR_SC8P_SHIFT, OSC_CR_SC8P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field SC4P[2] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 4 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC4P field. */
#define OSC_RD_CR_SC4P(base) ((OSC_CR_REG(base) & OSC_CR_SC4P_MASK) >> OSC_CR_SC4P_SHIFT)
#define OSC_BRD_CR_SC4P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC4P_SHIFT, OSC_CR_SC4P_WIDTH))

/*! @brief Set the SC4P field to a new value. */
#define OSC_WR_CR_SC4P(base, value) (OSC_RMW_CR(base, OSC_CR_SC4P_MASK, OSC_CR_SC4P(value)))
#define OSC_BWR_CR_SC4P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC4P_SHIFT), OSC_CR_SC4P_SHIFT, OSC_CR_SC4P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field SC2P[3] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 2 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC2P field. */
#define OSC_RD_CR_SC2P(base) ((OSC_CR_REG(base) & OSC_CR_SC2P_MASK) >> OSC_CR_SC2P_SHIFT)
#define OSC_BRD_CR_SC2P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC2P_SHIFT, OSC_CR_SC2P_WIDTH))

/*! @brief Set the SC2P field to a new value. */
#define OSC_WR_CR_SC2P(base, value) (OSC_RMW_CR(base, OSC_CR_SC2P_MASK, OSC_CR_SC2P(value)))
#define OSC_BWR_CR_SC2P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC2P_SHIFT), OSC_CR_SC2P_SHIFT, OSC_CR_SC2P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field EREFSTEN[5] (RW)
 *
 * Controls whether or not the external reference clock (OSCERCLK) remains
 * enabled when MCU enters Stop mode.
 *
 * Values:
 * - 0 - External reference clock is disabled in Stop mode.
 * - 1 - External reference clock stays enabled in Stop mode if ERCLKEN is set
 *     before entering Stop mode.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_EREFSTEN field. */
#define OSC_RD_CR_EREFSTEN(base) ((OSC_CR_REG(base) & OSC_CR_EREFSTEN_MASK) >> OSC_CR_EREFSTEN_SHIFT)
#define OSC_BRD_CR_EREFSTEN(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_EREFSTEN_SHIFT, OSC_CR_EREFSTEN_WIDTH))

/*! @brief Set the EREFSTEN field to a new value. */
#define OSC_WR_CR_EREFSTEN(base, value) (OSC_RMW_CR(base, OSC_CR_EREFSTEN_MASK, OSC_CR_EREFSTEN(value)))
#define OSC_BWR_CR_EREFSTEN(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_EREFSTEN_SHIFT), OSC_CR_EREFSTEN_SHIFT, OSC_CR_EREFSTEN_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field ERCLKEN[7] (RW)
 *
 * Enables external reference clock (OSCERCLK).
 *
 * Values:
 * - 0 - External reference clock is inactive.
 * - 1 - External reference clock is enabled.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_ERCLKEN field. */
#define OSC_RD_CR_ERCLKEN(base) ((OSC_CR_REG(base) & OSC_CR_ERCLKEN_MASK) >> OSC_CR_ERCLKEN_SHIFT)
#define OSC_BRD_CR_ERCLKEN(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_ERCLKEN_SHIFT, OSC_CR_ERCLKEN_WIDTH))

/*! @brief Set the ERCLKEN field to a new value. */
#define OSC_WR_CR_ERCLKEN(base, value) (OSC_RMW_CR(base, OSC_CR_ERCLKEN_MASK, OSC_CR_ERCLKEN(value)))
#define OSC_BWR_CR_ERCLKEN(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_ERCLKEN_SHIFT), OSC_CR_ERCLKEN_SHIFT, OSC_CR_ERCLKEN_WIDTH))
/*@}*/

/*
 * MKV10Z7 PDB
 *
 * Programmable Delay Block
 *
 * Registers defined in this header file:
 * - PDB_SC - Status and Control register
 * - PDB_MOD - Modulus register
 * - PDB_CNT - Counter register
 * - PDB_IDLY - Interrupt Delay register
 * - PDB_C1 - Channel n Control register 1
 * - PDB_S - Channel n Status register
 * - PDB_DLY - Channel n Delay 0 register
 * - PDB_INTC - DAC Interval Trigger n Control register
 * - PDB_INT - DAC Interval n register
 * - PDB_POEN - Pulse-Out n Enable register
 * - PDB_PODLY - Pulse-Out n Delay register
 */

#define PDB_INSTANCE_COUNT (1U) /*!< Number of instances of the PDB module. */
#define PDB0_IDX (0U) /*!< Instance number for PDB0. */

/*******************************************************************************
 * PDB_SC - Status and Control register
 ******************************************************************************/

/*!
 * @brief PDB_SC - Status and Control register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_SC register
 */
/*@{*/
#define PDB_RD_SC(base)          (PDB_SC_REG(base))
#define PDB_WR_SC(base, value)   (PDB_SC_REG(base) = (value))
#define PDB_RMW_SC(base, mask, value) (PDB_WR_SC(base, (PDB_RD_SC(base) & ~(mask)) | (value)))
#define PDB_SET_SC(base, value)  (BME_OR32(&PDB_SC_REG(base), (uint32_t)(value)))
#define PDB_CLR_SC(base, value)  (BME_AND32(&PDB_SC_REG(base), (uint32_t)(~(value))))
#define PDB_TOG_SC(base, value)  (BME_XOR32(&PDB_SC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_SC bitfields
 */

/*!
 * @name Register PDB_SC, field LDOK[0] (RW)
 *
 * Writing 1 to this bit updates the internal registers of MOD, IDLY, CHnDLYm,
 * DACINTx,and POyDLY with the values written to their buffers. The MOD, IDLY,
 * CHnDLYm, DACINTx, and POyDLY will take effect according to the LDMOD. After 1 is
 * written to the LDOK field, the values in the buffers of above registers are
 * not effective and the buffers cannot be written until the values in buffers are
 * loaded into their internal registers. LDOK can be written only when PDBEN is
 * set or it can be written at the same time with PDBEN being written to 1. It is
 * automatically cleared when the values in buffers are loaded into the internal
 * registers or the PDBEN is cleared. Writing 0 to it has no effect.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_LDOK field. */
#define PDB_RD_SC_LDOK(base) ((PDB_SC_REG(base) & PDB_SC_LDOK_MASK) >> PDB_SC_LDOK_SHIFT)
#define PDB_BRD_SC_LDOK(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_LDOK_SHIFT, PDB_SC_LDOK_WIDTH))

/*! @brief Set the LDOK field to a new value. */
#define PDB_WR_SC_LDOK(base, value) (PDB_RMW_SC(base, PDB_SC_LDOK_MASK, PDB_SC_LDOK(value)))
#define PDB_BWR_SC_LDOK(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_LDOK_SHIFT), PDB_SC_LDOK_SHIFT, PDB_SC_LDOK_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field CONT[1] (RW)
 *
 * Enables the PDB operation in Continuous mode.
 *
 * Values:
 * - 0 - PDB operation in One-Shot mode
 * - 1 - PDB operation in Continuous mode
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_CONT field. */
#define PDB_RD_SC_CONT(base) ((PDB_SC_REG(base) & PDB_SC_CONT_MASK) >> PDB_SC_CONT_SHIFT)
#define PDB_BRD_SC_CONT(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_CONT_SHIFT, PDB_SC_CONT_WIDTH))

/*! @brief Set the CONT field to a new value. */
#define PDB_WR_SC_CONT(base, value) (PDB_RMW_SC(base, PDB_SC_CONT_MASK, PDB_SC_CONT(value)))
#define PDB_BWR_SC_CONT(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_CONT_SHIFT), PDB_SC_CONT_SHIFT, PDB_SC_CONT_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field MULT[3:2] (RW)
 *
 * Selects the multiplication factor of the prescaler divider for the counter
 * clock.
 *
 * Values:
 * - 00 - Multiplication factor is 1.
 * - 01 - Multiplication factor is 10.
 * - 10 - Multiplication factor is 20.
 * - 11 - Multiplication factor is 40.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_MULT field. */
#define PDB_RD_SC_MULT(base) ((PDB_SC_REG(base) & PDB_SC_MULT_MASK) >> PDB_SC_MULT_SHIFT)
#define PDB_BRD_SC_MULT(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_MULT_SHIFT, PDB_SC_MULT_WIDTH))

/*! @brief Set the MULT field to a new value. */
#define PDB_WR_SC_MULT(base, value) (PDB_RMW_SC(base, PDB_SC_MULT_MASK, PDB_SC_MULT(value)))
#define PDB_BWR_SC_MULT(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_MULT_SHIFT), PDB_SC_MULT_SHIFT, PDB_SC_MULT_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIE[5] (RW)
 *
 * Enables the PDB interrupt. When this field is set and DMAEN is cleared, PDBIF
 * generates a PDB interrupt.
 *
 * Values:
 * - 0 - PDB interrupt disabled.
 * - 1 - PDB interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBIE field. */
#define PDB_RD_SC_PDBIE(base) ((PDB_SC_REG(base) & PDB_SC_PDBIE_MASK) >> PDB_SC_PDBIE_SHIFT)
#define PDB_BRD_SC_PDBIE(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PDBIE_SHIFT, PDB_SC_PDBIE_WIDTH))

/*! @brief Set the PDBIE field to a new value. */
#define PDB_WR_SC_PDBIE(base, value) (PDB_RMW_SC(base, PDB_SC_PDBIE_MASK, PDB_SC_PDBIE(value)))
#define PDB_BWR_SC_PDBIE(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PDBIE_SHIFT), PDB_SC_PDBIE_SHIFT, PDB_SC_PDBIE_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIF[6] (RW)
 *
 * This field is set when the counter value is equal to the IDLY register.
 * Writing zero clears this field.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBIF field. */
#define PDB_RD_SC_PDBIF(base) ((PDB_SC_REG(base) & PDB_SC_PDBIF_MASK) >> PDB_SC_PDBIF_SHIFT)
#define PDB_BRD_SC_PDBIF(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PDBIF_SHIFT, PDB_SC_PDBIF_WIDTH))

/*! @brief Set the PDBIF field to a new value. */
#define PDB_WR_SC_PDBIF(base, value) (PDB_RMW_SC(base, PDB_SC_PDBIF_MASK, PDB_SC_PDBIF(value)))
#define PDB_BWR_SC_PDBIF(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PDBIF_SHIFT), PDB_SC_PDBIF_SHIFT, PDB_SC_PDBIF_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEN[7] (RW)
 *
 * Values:
 * - 0 - PDB disabled. Counter is off.
 * - 1 - PDB enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBEN field. */
#define PDB_RD_SC_PDBEN(base) ((PDB_SC_REG(base) & PDB_SC_PDBEN_MASK) >> PDB_SC_PDBEN_SHIFT)
#define PDB_BRD_SC_PDBEN(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PDBEN_SHIFT, PDB_SC_PDBEN_WIDTH))

/*! @brief Set the PDBEN field to a new value. */
#define PDB_WR_SC_PDBEN(base, value) (PDB_RMW_SC(base, PDB_SC_PDBEN_MASK, PDB_SC_PDBEN(value)))
#define PDB_BWR_SC_PDBEN(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PDBEN_SHIFT), PDB_SC_PDBEN_SHIFT, PDB_SC_PDBEN_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field TRGSEL[11:8] (RW)
 *
 * Selects the trigger input source for the PDB. The trigger input source can be
 * internal or external (EXTRG pin), or the software trigger. Refer to chip
 * configuration details for the actual PDB input trigger connections.
 *
 * Values:
 * - 0000 - Trigger-In 0 is selected.
 * - 0001 - Trigger-In 1 is selected.
 * - 0010 - Trigger-In 2 is selected.
 * - 0011 - Trigger-In 3 is selected.
 * - 0100 - Trigger-In 4 is selected.
 * - 0101 - Trigger-In 5 is selected.
 * - 0110 - Trigger-In 6 is selected.
 * - 0111 - Trigger-In 7 is selected.
 * - 1000 - Trigger-In 8 is selected.
 * - 1001 - Trigger-In 9 is selected.
 * - 1010 - Trigger-In 10 is selected.
 * - 1011 - Trigger-In 11 is selected.
 * - 1100 - Trigger-In 12 is selected.
 * - 1101 - Trigger-In 13 is selected.
 * - 1110 - Trigger-In 14 is selected.
 * - 1111 - Software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_TRGSEL field. */
#define PDB_RD_SC_TRGSEL(base) ((PDB_SC_REG(base) & PDB_SC_TRGSEL_MASK) >> PDB_SC_TRGSEL_SHIFT)
#define PDB_BRD_SC_TRGSEL(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_TRGSEL_SHIFT, PDB_SC_TRGSEL_WIDTH))

/*! @brief Set the TRGSEL field to a new value. */
#define PDB_WR_SC_TRGSEL(base, value) (PDB_RMW_SC(base, PDB_SC_TRGSEL_MASK, PDB_SC_TRGSEL(value)))
#define PDB_BWR_SC_TRGSEL(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_TRGSEL_SHIFT), PDB_SC_TRGSEL_SHIFT, PDB_SC_TRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PRESCALER[14:12] (RW)
 *
 * Values:
 * - 000 - Counting uses the peripheral clock divided by multiplication factor
 *     selected by MULT.
 * - 001 - Counting uses the peripheral clock divided by twice of the
 *     multiplication factor selected by MULT.
 * - 010 - Counting uses the peripheral clock divided by four times of the
 *     multiplication factor selected by MULT.
 * - 011 - Counting uses the peripheral clock divided by eight times of the
 *     multiplication factor selected by MULT.
 * - 100 - Counting uses the peripheral clock divided by 16 times of the
 *     multiplication factor selected by MULT.
 * - 101 - Counting uses the peripheral clock divided by 32 times of the
 *     multiplication factor selected by MULT.
 * - 110 - Counting uses the peripheral clock divided by 64 times of the
 *     multiplication factor selected by MULT.
 * - 111 - Counting uses the peripheral clock divided by 128 times of the
 *     multiplication factor selected by MULT.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PRESCALER field. */
#define PDB_RD_SC_PRESCALER(base) ((PDB_SC_REG(base) & PDB_SC_PRESCALER_MASK) >> PDB_SC_PRESCALER_SHIFT)
#define PDB_BRD_SC_PRESCALER(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PRESCALER_SHIFT, PDB_SC_PRESCALER_WIDTH))

/*! @brief Set the PRESCALER field to a new value. */
#define PDB_WR_SC_PRESCALER(base, value) (PDB_RMW_SC(base, PDB_SC_PRESCALER_MASK, PDB_SC_PRESCALER(value)))
#define PDB_BWR_SC_PRESCALER(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PRESCALER_SHIFT), PDB_SC_PRESCALER_SHIFT, PDB_SC_PRESCALER_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field DMAEN[15] (RW)
 *
 * When DMA is enabled, the PDBIF flag generates a DMA request instead of an
 * interrupt.
 *
 * Values:
 * - 0 - DMA disabled.
 * - 1 - DMA enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_DMAEN field. */
#define PDB_RD_SC_DMAEN(base) ((PDB_SC_REG(base) & PDB_SC_DMAEN_MASK) >> PDB_SC_DMAEN_SHIFT)
#define PDB_BRD_SC_DMAEN(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_DMAEN_SHIFT, PDB_SC_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define PDB_WR_SC_DMAEN(base, value) (PDB_RMW_SC(base, PDB_SC_DMAEN_MASK, PDB_SC_DMAEN(value)))
#define PDB_BWR_SC_DMAEN(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_DMAEN_SHIFT), PDB_SC_DMAEN_SHIFT, PDB_SC_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field SWTRIG[16] (WORZ)
 *
 * When PDB is enabled and the software trigger is selected as the trigger input
 * source, writing 1 to this field resets and restarts the counter. Writing 0 to
 * this field has no effect. Reading this field results 0.
 */
/*@{*/
/*! @brief Set the SWTRIG field to a new value. */
#define PDB_WR_SC_SWTRIG(base, value) (PDB_RMW_SC(base, PDB_SC_SWTRIG_MASK, PDB_SC_SWTRIG(value)))
#define PDB_BWR_SC_SWTRIG(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_SWTRIG_SHIFT), PDB_SC_SWTRIG_SHIFT, PDB_SC_SWTRIG_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEIE[17] (RW)
 *
 * Enables the PDB sequence error interrupt. When this field is set, any of the
 * PDB channel sequence error flags generates a PDB sequence error interrupt.
 *
 * Values:
 * - 0 - PDB sequence error interrupt disabled.
 * - 1 - PDB sequence error interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBEIE field. */
#define PDB_RD_SC_PDBEIE(base) ((PDB_SC_REG(base) & PDB_SC_PDBEIE_MASK) >> PDB_SC_PDBEIE_SHIFT)
#define PDB_BRD_SC_PDBEIE(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PDBEIE_SHIFT, PDB_SC_PDBEIE_WIDTH))

/*! @brief Set the PDBEIE field to a new value. */
#define PDB_WR_SC_PDBEIE(base, value) (PDB_RMW_SC(base, PDB_SC_PDBEIE_MASK, PDB_SC_PDBEIE(value)))
#define PDB_BWR_SC_PDBEIE(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PDBEIE_SHIFT), PDB_SC_PDBEIE_SHIFT, PDB_SC_PDBEIE_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field LDMOD[19:18] (RW)
 *
 * Selects the mode to load the MOD, IDLY, CHnDLYm, INTx, and POyDLY registers,
 * after 1 is written to LDOK.
 *
 * Values:
 * - 00 - The internal registers are loaded with the values from their buffers
 *     immediately after 1 is written to LDOK.
 * - 01 - The internal registers are loaded with the values from their buffers
 *     when the PDB counter reaches the MOD register value after 1 is written to
 *     LDOK.
 * - 10 - The internal registers are loaded with the values from their buffers
 *     when a trigger input event is detected after 1 is written to LDOK.
 * - 11 - The internal registers are loaded with the values from their buffers
 *     when either the PDB counter reaches the MOD register value or a trigger
 *     input event is detected, after 1 is written to LDOK.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_LDMOD field. */
#define PDB_RD_SC_LDMOD(base) ((PDB_SC_REG(base) & PDB_SC_LDMOD_MASK) >> PDB_SC_LDMOD_SHIFT)
#define PDB_BRD_SC_LDMOD(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_LDMOD_SHIFT, PDB_SC_LDMOD_WIDTH))

/*! @brief Set the LDMOD field to a new value. */
#define PDB_WR_SC_LDMOD(base, value) (PDB_RMW_SC(base, PDB_SC_LDMOD_MASK, PDB_SC_LDMOD(value)))
#define PDB_BWR_SC_LDMOD(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_LDMOD_SHIFT), PDB_SC_LDMOD_SHIFT, PDB_SC_LDMOD_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_MOD - Modulus register
 ******************************************************************************/

/*!
 * @brief PDB_MOD - Modulus register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire PDB_MOD register
 */
/*@{*/
#define PDB_RD_MOD(base)         (PDB_MOD_REG(base))
#define PDB_WR_MOD(base, value)  (PDB_MOD_REG(base) = (value))
#define PDB_RMW_MOD(base, mask, value) (PDB_WR_MOD(base, (PDB_RD_MOD(base) & ~(mask)) | (value)))
#define PDB_SET_MOD(base, value) (BME_OR32(&PDB_MOD_REG(base), (uint32_t)(value)))
#define PDB_CLR_MOD(base, value) (BME_AND32(&PDB_MOD_REG(base), (uint32_t)(~(value))))
#define PDB_TOG_MOD(base, value) (BME_XOR32(&PDB_MOD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_MOD bitfields
 */

/*!
 * @name Register PDB_MOD, field MOD[15:0] (RW)
 *
 * Specifies the period of the counter. When the counter reaches this value, it
 * will be reset back to zero. If the PDB is in Continuous mode, the count begins
 * anew. Reading this field returns the value of the internal register that is
 * effective for the current cycle of PDB.
 */
/*@{*/
/*! @brief Read current value of the PDB_MOD_MOD field. */
#define PDB_RD_MOD_MOD(base) ((PDB_MOD_REG(base) & PDB_MOD_MOD_MASK) >> PDB_MOD_MOD_SHIFT)
#define PDB_BRD_MOD_MOD(base) (BME_UBFX32(&PDB_MOD_REG(base), PDB_MOD_MOD_SHIFT, PDB_MOD_MOD_WIDTH))

/*! @brief Set the MOD field to a new value. */
#define PDB_WR_MOD_MOD(base, value) (PDB_RMW_MOD(base, PDB_MOD_MOD_MASK, PDB_MOD_MOD(value)))
#define PDB_BWR_MOD_MOD(base, value) (BME_BFI32(&PDB_MOD_REG(base), ((uint32_t)(value) << PDB_MOD_MOD_SHIFT), PDB_MOD_MOD_SHIFT, PDB_MOD_MOD_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_CNT - Counter register
 ******************************************************************************/

/*!
 * @brief PDB_CNT - Counter register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CNT register
 */
/*@{*/
#define PDB_RD_CNT(base)         (PDB_CNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual PDB_CNT bitfields
 */

/*!
 * @name Register PDB_CNT, field CNT[15:0] (RO)
 *
 * Contains the current value of the counter.
 */
/*@{*/
/*! @brief Read current value of the PDB_CNT_CNT field. */
#define PDB_RD_CNT_CNT(base) ((PDB_CNT_REG(base) & PDB_CNT_CNT_MASK) >> PDB_CNT_CNT_SHIFT)
#define PDB_BRD_CNT_CNT(base) (BME_UBFX32(&PDB_CNT_REG(base), PDB_CNT_CNT_SHIFT, PDB_CNT_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_IDLY - Interrupt Delay register
 ******************************************************************************/

/*!
 * @brief PDB_IDLY - Interrupt Delay register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire PDB_IDLY register
 */
/*@{*/
#define PDB_RD_IDLY(base)        (PDB_IDLY_REG(base))
#define PDB_WR_IDLY(base, value) (PDB_IDLY_REG(base) = (value))
#define PDB_RMW_IDLY(base, mask, value) (PDB_WR_IDLY(base, (PDB_RD_IDLY(base) & ~(mask)) | (value)))
#define PDB_SET_IDLY(base, value) (BME_OR32(&PDB_IDLY_REG(base), (uint32_t)(value)))
#define PDB_CLR_IDLY(base, value) (BME_AND32(&PDB_IDLY_REG(base), (uint32_t)(~(value))))
#define PDB_TOG_IDLY(base, value) (BME_XOR32(&PDB_IDLY_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_IDLY bitfields
 */

/*!
 * @name Register PDB_IDLY, field IDLY[15:0] (RW)
 *
 * Specifies the delay value to schedule the PDB interrupt. It can be used to
 * schedule an independent interrupt at some point in the PDB cycle. If enabled, a
 * PDB interrupt is generated, when the counter is equal to the IDLY. Reading
 * this field returns the value of internal register that is effective for the
 * current cycle of the PDB.
 */
/*@{*/
/*! @brief Read current value of the PDB_IDLY_IDLY field. */
#define PDB_RD_IDLY_IDLY(base) ((PDB_IDLY_REG(base) & PDB_IDLY_IDLY_MASK) >> PDB_IDLY_IDLY_SHIFT)
#define PDB_BRD_IDLY_IDLY(base) (BME_UBFX32(&PDB_IDLY_REG(base), PDB_IDLY_IDLY_SHIFT, PDB_IDLY_IDLY_WIDTH))

/*! @brief Set the IDLY field to a new value. */
#define PDB_WR_IDLY_IDLY(base, value) (PDB_RMW_IDLY(base, PDB_IDLY_IDLY_MASK, PDB_IDLY_IDLY(value)))
#define PDB_BWR_IDLY_IDLY(base, value) (BME_BFI32(&PDB_IDLY_REG(base), ((uint32_t)(value) << PDB_IDLY_IDLY_SHIFT), PDB_IDLY_IDLY_SHIFT, PDB_IDLY_IDLY_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_C1 - Channel n Control register 1
 ******************************************************************************/

/*!
 * @brief PDB_C1 - Channel n Control register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PDB channel has one control register, CHnC1. The bits in this register
 * control the functionality of each PDB channel operation.
 */
/*!
 * @name Constants and macros for entire PDB_C1 register
 */
/*@{*/
#define PDB_RD_C1(base, index)   (PDB_C1_REG(base, index))
#define PDB_WR_C1(base, index, value) (PDB_C1_REG(base, index) = (value))
#define PDB_RMW_C1(base, index, mask, value) (PDB_WR_C1(base, index, (PDB_RD_C1(base, index) & ~(mask)) | (value)))
#define PDB_SET_C1(base, index, value) (BME_OR32(&PDB_C1_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_C1(base, index, value) (BME_AND32(&PDB_C1_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_C1(base, index, value) (BME_XOR32(&PDB_C1_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_C1 bitfields
 */

/*!
 * @name Register PDB_C1, field EN[7:0] (RW)
 *
 * These bits enable the PDB ADC pre-trigger outputs. Only lower M pre-trigger
 * bits are implemented in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger disabled.
 * - 1 - PDB channel's corresponding pre-trigger enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_EN field. */
#define PDB_RD_C1_EN(base, index) ((PDB_C1_REG(base, index) & PDB_C1_EN_MASK) >> PDB_C1_EN_SHIFT)
#define PDB_BRD_C1_EN(base, index) (BME_UBFX32(&PDB_C1_REG(base, index), PDB_C1_EN_SHIFT, PDB_C1_EN_WIDTH))

/*! @brief Set the EN field to a new value. */
#define PDB_WR_C1_EN(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_EN_MASK, PDB_C1_EN(value)))
#define PDB_BWR_C1_EN(base, index, value) (BME_BFI32(&PDB_C1_REG(base, index), ((uint32_t)(value) << PDB_C1_EN_SHIFT), PDB_C1_EN_SHIFT, PDB_C1_EN_WIDTH))
/*@}*/

/*!
 * @name Register PDB_C1, field TOS[15:8] (RW)
 *
 * Selects the PDB ADC pre-trigger outputs. Only lower M pre-trigger fields are
 * implemented in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger is in bypassed mode. The
 *     pre-trigger asserts one peripheral clock cycle after a rising edge is detected
 *     on selected trigger input source or software trigger is selected and SWTRIG
 *     is written with 1.
 * - 1 - PDB channel's corresponding pre-trigger asserts when the counter
 *     reaches the channel delay register and one peripheral clock cycle after a rising
 *     edge is detected on selected trigger input source or software trigger is
 *     selected and SETRIG is written with 1.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_TOS field. */
#define PDB_RD_C1_TOS(base, index) ((PDB_C1_REG(base, index) & PDB_C1_TOS_MASK) >> PDB_C1_TOS_SHIFT)
#define PDB_BRD_C1_TOS(base, index) (BME_UBFX32(&PDB_C1_REG(base, index), PDB_C1_TOS_SHIFT, PDB_C1_TOS_WIDTH))

/*! @brief Set the TOS field to a new value. */
#define PDB_WR_C1_TOS(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_TOS_MASK, PDB_C1_TOS(value)))
#define PDB_BWR_C1_TOS(base, index, value) (BME_BFI32(&PDB_C1_REG(base, index), ((uint32_t)(value) << PDB_C1_TOS_SHIFT), PDB_C1_TOS_SHIFT, PDB_C1_TOS_WIDTH))
/*@}*/

/*!
 * @name Register PDB_C1, field BB[23:16] (RW)
 *
 * These bits enable the PDB ADC pre-trigger operation as back-to-back mode.
 * Only lower M pre-trigger bits are implemented in this MCU. Back-to-back operation
 * enables the ADC conversions complete to trigger the next PDB channel
 * pre-trigger and trigger output, so that the ADC conversions can be triggered on next
 * set of configuration and results registers. Application code must only enable
 * the back-to-back operation of the PDB pre-triggers at the leading of the
 * back-to-back connection chain.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger back-to-back operation disabled.
 * - 1 - PDB channel's corresponding pre-trigger back-to-back operation enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_BB field. */
#define PDB_RD_C1_BB(base, index) ((PDB_C1_REG(base, index) & PDB_C1_BB_MASK) >> PDB_C1_BB_SHIFT)
#define PDB_BRD_C1_BB(base, index) (BME_UBFX32(&PDB_C1_REG(base, index), PDB_C1_BB_SHIFT, PDB_C1_BB_WIDTH))

/*! @brief Set the BB field to a new value. */
#define PDB_WR_C1_BB(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_BB_MASK, PDB_C1_BB(value)))
#define PDB_BWR_C1_BB(base, index, value) (BME_BFI32(&PDB_C1_REG(base, index), ((uint32_t)(value) << PDB_C1_BB_SHIFT), PDB_C1_BB_SHIFT, PDB_C1_BB_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_S - Channel n Status register
 ******************************************************************************/

/*!
 * @brief PDB_S - Channel n Status register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_S register
 */
/*@{*/
#define PDB_RD_S(base, index)    (PDB_S_REG(base, index))
#define PDB_WR_S(base, index, value) (PDB_S_REG(base, index) = (value))
#define PDB_RMW_S(base, index, mask, value) (PDB_WR_S(base, index, (PDB_RD_S(base, index) & ~(mask)) | (value)))
#define PDB_SET_S(base, index, value) (BME_OR32(&PDB_S_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_S(base, index, value) (BME_AND32(&PDB_S_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_S(base, index, value) (BME_XOR32(&PDB_S_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_S bitfields
 */

/*!
 * @name Register PDB_S, field ERR[7:0] (RW)
 *
 * Only the lower M bits are implemented in this MCU.
 *
 * Values:
 * - 0 - Sequence error not detected on PDB channel's corresponding pre-trigger.
 * - 1 - Sequence error detected on PDB channel's corresponding pre-trigger.
 *     ADCn block can be triggered for a conversion by one pre-trigger from PDB
 *     channel n. When one conversion, which is triggered by one of the pre-triggers
 *     from PDB channel n, is in progress, new trigger from PDB channel's
 *     corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set.
 *     Writing 0's to clear the sequence error flags.
 */
/*@{*/
/*! @brief Read current value of the PDB_S_ERR field. */
#define PDB_RD_S_ERR(base, index) ((PDB_S_REG(base, index) & PDB_S_ERR_MASK) >> PDB_S_ERR_SHIFT)
#define PDB_BRD_S_ERR(base, index) (BME_UBFX32(&PDB_S_REG(base, index), PDB_S_ERR_SHIFT, PDB_S_ERR_WIDTH))

/*! @brief Set the ERR field to a new value. */
#define PDB_WR_S_ERR(base, index, value) (PDB_RMW_S(base, index, PDB_S_ERR_MASK, PDB_S_ERR(value)))
#define PDB_BWR_S_ERR(base, index, value) (BME_BFI32(&PDB_S_REG(base, index), ((uint32_t)(value) << PDB_S_ERR_SHIFT), PDB_S_ERR_SHIFT, PDB_S_ERR_WIDTH))
/*@}*/

/*!
 * @name Register PDB_S, field CF[23:16] (RW)
 *
 * The CF[m] bit is set when the PDB counter matches the CHnDLYm. Write 0 to
 * clear these bits.
 */
/*@{*/
/*! @brief Read current value of the PDB_S_CF field. */
#define PDB_RD_S_CF(base, index) ((PDB_S_REG(base, index) & PDB_S_CF_MASK) >> PDB_S_CF_SHIFT)
#define PDB_BRD_S_CF(base, index) (BME_UBFX32(&PDB_S_REG(base, index), PDB_S_CF_SHIFT, PDB_S_CF_WIDTH))

/*! @brief Set the CF field to a new value. */
#define PDB_WR_S_CF(base, index, value) (PDB_RMW_S(base, index, PDB_S_CF_MASK, PDB_S_CF(value)))
#define PDB_BWR_S_CF(base, index, value) (BME_BFI32(&PDB_S_REG(base, index), ((uint32_t)(value) << PDB_S_CF_SHIFT), PDB_S_CF_SHIFT, PDB_S_CF_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_DLY - Channel n Delay 0 register
 ******************************************************************************/

/*!
 * @brief PDB_DLY - Channel n Delay 0 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_DLY register
 */
/*@{*/
#define PDB_RD_DLY(base, index, index2) (PDB_DLY_REG(base, index, index2))
#define PDB_WR_DLY(base, index, index2, value) (PDB_DLY_REG(base, index, index2) = (value))
#define PDB_RMW_DLY(base, index, index2, mask, value) (PDB_WR_DLY(base, index, index2, (PDB_RD_DLY(base, index, index2) & ~(mask)) | (value)))
#define PDB_SET_DLY(base, index, index2, value) (BME_OR32(&PDB_DLY_REG(base, index, index2), (uint32_t)(value)))
#define PDB_CLR_DLY(base, index, index2, value) (BME_AND32(&PDB_DLY_REG(base, index, index2), (uint32_t)(~(value))))
#define PDB_TOG_DLY(base, index, index2, value) (BME_XOR32(&PDB_DLY_REG(base, index, index2), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_DLY bitfields
 */

/*!
 * @name Register PDB_DLY, field DLY[15:0] (RW)
 *
 * Specifies the delay value for the channel's corresponding pre-trigger. The
 * pre-trigger asserts when the counter is equal to DLY. Reading this field returns
 * the value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_DLY_DLY field. */
#define PDB_RD_DLY_DLY(base, index, index2) ((PDB_DLY_REG(base, index, index2) & PDB_DLY_DLY_MASK) >> PDB_DLY_DLY_SHIFT)
#define PDB_BRD_DLY_DLY(base, index, index2) (BME_UBFX32(&PDB_DLY_REG(base, index, index2), PDB_DLY_DLY_SHIFT, PDB_DLY_DLY_WIDTH))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_DLY_DLY(base, index, index2, value) (PDB_RMW_DLY(base, index, index2, PDB_DLY_DLY_MASK, PDB_DLY_DLY(value)))
#define PDB_BWR_DLY_DLY(base, index, index2, value) (BME_BFI32(&PDB_DLY_REG(base, index, index2), ((uint32_t)(value) << PDB_DLY_DLY_SHIFT), PDB_DLY_DLY_SHIFT, PDB_DLY_DLY_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_INTC - DAC Interval Trigger n Control register
 ******************************************************************************/

/*!
 * @brief PDB_INTC - DAC Interval Trigger n Control register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_INTC register
 */
/*@{*/
#define PDB_RD_INTC(base, index) (PDB_INTC_REG(base, index))
#define PDB_WR_INTC(base, index, value) (PDB_INTC_REG(base, index) = (value))
#define PDB_RMW_INTC(base, index, mask, value) (PDB_WR_INTC(base, index, (PDB_RD_INTC(base, index) & ~(mask)) | (value)))
#define PDB_SET_INTC(base, index, value) (BME_OR32(&PDB_INTC_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_INTC(base, index, value) (BME_AND32(&PDB_INTC_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_INTC(base, index, value) (BME_XOR32(&PDB_INTC_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_INTC bitfields
 */

/*!
 * @name Register PDB_INTC, field TOE[0] (RW)
 *
 * Enables the DAC interval trigger.
 *
 * Values:
 * - 0 - DAC interval trigger disabled.
 * - 1 - DAC interval trigger enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_INTC_TOE field. */
#define PDB_RD_INTC_TOE(base, index) ((PDB_INTC_REG(base, index) & PDB_INTC_TOE_MASK) >> PDB_INTC_TOE_SHIFT)
#define PDB_BRD_INTC_TOE(base, index) (BME_UBFX32(&PDB_INTC_REG(base, index), PDB_INTC_TOE_SHIFT, PDB_INTC_TOE_WIDTH))

/*! @brief Set the TOE field to a new value. */
#define PDB_WR_INTC_TOE(base, index, value) (PDB_RMW_INTC(base, index, PDB_INTC_TOE_MASK, PDB_INTC_TOE(value)))
#define PDB_BWR_INTC_TOE(base, index, value) (BME_BFI32(&PDB_INTC_REG(base, index), ((uint32_t)(value) << PDB_INTC_TOE_SHIFT), PDB_INTC_TOE_SHIFT, PDB_INTC_TOE_WIDTH))
/*@}*/

/*!
 * @name Register PDB_INTC, field EXT[1] (RW)
 *
 * This bit enables the external trigger for DAC interval counter.
 *
 * Values:
 * - 0 - DAC external trigger input disabled. DAC interval counter is reset and
 *     started counting when a rising edge is detected on selected trigger input
 *     source or software trigger is selected and SWTRIG is written with 1.
 * - 1 - DAC external trigger input enabled. DAC interval counter is bypassed
 *     and DAC external trigger input triggers the DAC interval trigger.
 */
/*@{*/
/*! @brief Read current value of the PDB_INTC_EXT field. */
#define PDB_RD_INTC_EXT(base, index) ((PDB_INTC_REG(base, index) & PDB_INTC_EXT_MASK) >> PDB_INTC_EXT_SHIFT)
#define PDB_BRD_INTC_EXT(base, index) (BME_UBFX32(&PDB_INTC_REG(base, index), PDB_INTC_EXT_SHIFT, PDB_INTC_EXT_WIDTH))

/*! @brief Set the EXT field to a new value. */
#define PDB_WR_INTC_EXT(base, index, value) (PDB_RMW_INTC(base, index, PDB_INTC_EXT_MASK, PDB_INTC_EXT(value)))
#define PDB_BWR_INTC_EXT(base, index, value) (BME_BFI32(&PDB_INTC_REG(base, index), ((uint32_t)(value) << PDB_INTC_EXT_SHIFT), PDB_INTC_EXT_SHIFT, PDB_INTC_EXT_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_INT - DAC Interval n register
 ******************************************************************************/

/*!
 * @brief PDB_INT - DAC Interval n register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_INT register
 */
/*@{*/
#define PDB_RD_INT(base, index)  (PDB_INT_REG(base, index))
#define PDB_WR_INT(base, index, value) (PDB_INT_REG(base, index) = (value))
#define PDB_RMW_INT(base, index, mask, value) (PDB_WR_INT(base, index, (PDB_RD_INT(base, index) & ~(mask)) | (value)))
#define PDB_SET_INT(base, index, value) (BME_OR32(&PDB_INT_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_INT(base, index, value) (BME_AND32(&PDB_INT_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_INT(base, index, value) (BME_XOR32(&PDB_INT_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_INT bitfields
 */

/*!
 * @name Register PDB_INT, field INT[15:0] (RW)
 *
 * These bits specify the interval value for DAC interval trigger. DAC interval
 * trigger triggers DAC[1:0] update when the DAC interval counter is equal to the
 * DACINT. Reading these bits returns the value of internal register that is
 * effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_INT_INT field. */
#define PDB_RD_INT_INT(base, index) ((PDB_INT_REG(base, index) & PDB_INT_INT_MASK) >> PDB_INT_INT_SHIFT)
#define PDB_BRD_INT_INT(base, index) (BME_UBFX32(&PDB_INT_REG(base, index), PDB_INT_INT_SHIFT, PDB_INT_INT_WIDTH))

/*! @brief Set the INT field to a new value. */
#define PDB_WR_INT_INT(base, index, value) (PDB_RMW_INT(base, index, PDB_INT_INT_MASK, PDB_INT_INT(value)))
#define PDB_BWR_INT_INT(base, index, value) (BME_BFI32(&PDB_INT_REG(base, index), ((uint32_t)(value) << PDB_INT_INT_SHIFT), PDB_INT_INT_SHIFT, PDB_INT_INT_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_POEN - Pulse-Out n Enable register
 ******************************************************************************/

/*!
 * @brief PDB_POEN - Pulse-Out n Enable register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_POEN register
 */
/*@{*/
#define PDB_RD_POEN(base)        (PDB_POEN_REG(base))
#define PDB_WR_POEN(base, value) (PDB_POEN_REG(base) = (value))
#define PDB_RMW_POEN(base, mask, value) (PDB_WR_POEN(base, (PDB_RD_POEN(base) & ~(mask)) | (value)))
#define PDB_SET_POEN(base, value) (BME_OR32(&PDB_POEN_REG(base), (uint32_t)(value)))
#define PDB_CLR_POEN(base, value) (BME_AND32(&PDB_POEN_REG(base), (uint32_t)(~(value))))
#define PDB_TOG_POEN(base, value) (BME_XOR32(&PDB_POEN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_POEN bitfields
 */

/*!
 * @name Register PDB_POEN, field POEN[7:0] (RW)
 *
 * Enables the pulse output. Only lower Y bits are implemented in this MCU.
 *
 * Values:
 * - 0 - PDB Pulse-Out disabled
 * - 1 - PDB Pulse-Out enabled
 */
/*@{*/
/*! @brief Read current value of the PDB_POEN_POEN field. */
#define PDB_RD_POEN_POEN(base) ((PDB_POEN_REG(base) & PDB_POEN_POEN_MASK) >> PDB_POEN_POEN_SHIFT)
#define PDB_BRD_POEN_POEN(base) (BME_UBFX32(&PDB_POEN_REG(base), PDB_POEN_POEN_SHIFT, PDB_POEN_POEN_WIDTH))

/*! @brief Set the POEN field to a new value. */
#define PDB_WR_POEN_POEN(base, value) (PDB_RMW_POEN(base, PDB_POEN_POEN_MASK, PDB_POEN_POEN(value)))
#define PDB_BWR_POEN_POEN(base, value) (BME_BFI32(&PDB_POEN_REG(base), ((uint32_t)(value) << PDB_POEN_POEN_SHIFT), PDB_POEN_POEN_SHIFT, PDB_POEN_POEN_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_PODLY - Pulse-Out n Delay register
 ******************************************************************************/

/*!
 * @brief PDB_PODLY - Pulse-Out n Delay register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_PODLY register
 */
/*@{*/
#define PDB_RD_PODLY(base, index) (PDB_PODLY_REG(base, index))
#define PDB_WR_PODLY(base, index, value) (PDB_PODLY_REG(base, index) = (value))
#define PDB_RMW_PODLY(base, index, mask, value) (PDB_WR_PODLY(base, index, (PDB_RD_PODLY(base, index) & ~(mask)) | (value)))
#define PDB_SET_PODLY(base, index, value) (BME_OR32(&PDB_PODLY_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_PODLY(base, index, value) (BME_AND32(&PDB_PODLY_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_PODLY(base, index, value) (BME_XOR32(&PDB_PODLY_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_PODLY bitfields
 */

/*!
 * @name Register PDB_PODLY, field DLY2[15:0] (RW)
 *
 * Specifies the delay 2 value for the PDB Pulse-Out. Pulse-Out goes low when
 * the PDB counter is equal to the DLY2. Reading this field returns the value of
 * internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_PODLY_DLY2 field. */
#define PDB_RD_PODLY_DLY2(base, index) ((PDB_PODLY_REG(base, index) & PDB_PODLY_DLY2_MASK) >> PDB_PODLY_DLY2_SHIFT)
#define PDB_BRD_PODLY_DLY2(base, index) (BME_UBFX32(&PDB_PODLY_REG(base, index), PDB_PODLY_DLY2_SHIFT, PDB_PODLY_DLY2_WIDTH))

/*! @brief Set the DLY2 field to a new value. */
#define PDB_WR_PODLY_DLY2(base, index, value) (PDB_RMW_PODLY(base, index, PDB_PODLY_DLY2_MASK, PDB_PODLY_DLY2(value)))
#define PDB_BWR_PODLY_DLY2(base, index, value) (BME_BFI32(&PDB_PODLY_REG(base, index), ((uint32_t)(value) << PDB_PODLY_DLY2_SHIFT), PDB_PODLY_DLY2_SHIFT, PDB_PODLY_DLY2_WIDTH))
/*@}*/

/*!
 * @name Register PDB_PODLY, field DLY1[31:16] (RW)
 *
 * Specifies the delay 1 value for the PDB Pulse-Out. Pulse-Out goes high when
 * the PDB counter is equal to the DLY1. Reading this field returns the value of
 * internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_PODLY_DLY1 field. */
#define PDB_RD_PODLY_DLY1(base, index) ((PDB_PODLY_REG(base, index) & PDB_PODLY_DLY1_MASK) >> PDB_PODLY_DLY1_SHIFT)
#define PDB_BRD_PODLY_DLY1(base, index) (BME_UBFX32(&PDB_PODLY_REG(base, index), PDB_PODLY_DLY1_SHIFT, PDB_PODLY_DLY1_WIDTH))

/*! @brief Set the DLY1 field to a new value. */
#define PDB_WR_PODLY_DLY1(base, index, value) (PDB_RMW_PODLY(base, index, PDB_PODLY_DLY1_MASK, PDB_PODLY_DLY1(value)))
#define PDB_BWR_PODLY_DLY1(base, index, value) (BME_BFI32(&PDB_PODLY_REG(base, index), ((uint32_t)(value) << PDB_PODLY_DLY1_SHIFT), PDB_PODLY_DLY1_SHIFT, PDB_PODLY_DLY1_WIDTH))
/*@}*/

/*
 * MKV10Z7 PMC
 *
 * Power Management Controller
 *
 * Registers defined in this header file:
 * - PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 * - PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 * - PMC_REGSC - Regulator Status And Control register
 */

#define PMC_INSTANCE_COUNT (1U) /*!< Number of instances of the PMC module. */
#define PMC_IDX (0U) /*!< Instance number for PMC. */

/*******************************************************************************
 * PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register (RW)
 *
 * Reset value: 0x10U
 *
 * This register contains status and control bits to support the low voltage
 * detect function. This register should be written during the reset initialization
 * program to set the desired controls even if the desired settings are the same
 * as the reset settings. While the device is in the very low power or low
 * leakage modes, the LVD system is disabled regardless of LVDSC1 settings. To protect
 * systems that must have LVD always on, configure the Power Mode Protection
 * (PMPROT) register of the SMC module (SMC_PMPROT) to disallow any very low power or
 * low leakage modes from being enabled. See the device's data sheet for the
 * exact LVD trip voltages. The LVDV bits are reset solely on a POR Only event. The
 * register's other bits are reset on Chip Reset Not VLLS. For more information
 * about these reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC1 register
 */
/*@{*/
#define PMC_RD_LVDSC1(base)      (PMC_LVDSC1_REG(base))
#define PMC_WR_LVDSC1(base, value) (PMC_LVDSC1_REG(base) = (value))
#define PMC_RMW_LVDSC1(base, mask, value) (PMC_WR_LVDSC1(base, (PMC_RD_LVDSC1(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC1(base, value) (BME_OR8(&PMC_LVDSC1_REG(base), (uint8_t)(value)))
#define PMC_CLR_LVDSC1(base, value) (BME_AND8(&PMC_LVDSC1_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_LVDSC1(base, value) (BME_XOR8(&PMC_LVDSC1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC1 bitfields
 */

/*!
 * @name Register PMC_LVDSC1, field LVDV[1:0] (RW)
 *
 * Selects the LVD trip point voltage (V LVD ).
 *
 * Values:
 * - 00 - Low trip point selected (V LVD = V LVDL )
 * - 01 - High trip point selected (V LVD = V LVDH )
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDV field. */
#define PMC_RD_LVDSC1_LVDV(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDV_MASK) >> PMC_LVDSC1_LVDV_SHIFT)
#define PMC_BRD_LVDSC1_LVDV(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDV_SHIFT, PMC_LVDSC1_LVDV_WIDTH))

/*! @brief Set the LVDV field to a new value. */
#define PMC_WR_LVDSC1_LVDV(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDV_MASK, PMC_LVDSC1_LVDV(value)))
#define PMC_BWR_LVDSC1_LVDV(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDV_SHIFT), PMC_LVDSC1_LVDV_SHIFT, PMC_LVDSC1_LVDV_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDRE[4] (RW)
 *
 * This write-once bit enables LVDF events to generate a hardware reset.
 * Additional writes are ignored.
 *
 * Values:
 * - 0 - LVDF does not generate hardware resets
 * - 1 - Force an MCU reset when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDRE field. */
#define PMC_RD_LVDSC1_LVDRE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDRE_MASK) >> PMC_LVDSC1_LVDRE_SHIFT)
#define PMC_BRD_LVDSC1_LVDRE(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDRE_SHIFT, PMC_LVDSC1_LVDRE_WIDTH))

/*! @brief Set the LVDRE field to a new value. */
#define PMC_WR_LVDSC1_LVDRE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDRE_MASK, PMC_LVDSC1_LVDRE(value)))
#define PMC_BWR_LVDSC1_LVDRE(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDRE_SHIFT), PMC_LVDSC1_LVDRE_SHIFT, PMC_LVDSC1_LVDRE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVDF.
 *
 * Values:
 * - 0 - Hardware interrupt disabled (use polling)
 * - 1 - Request a hardware interrupt when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDIE field. */
#define PMC_RD_LVDSC1_LVDIE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDIE_MASK) >> PMC_LVDSC1_LVDIE_SHIFT)
#define PMC_BRD_LVDSC1_LVDIE(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDIE_SHIFT, PMC_LVDSC1_LVDIE_WIDTH))

/*! @brief Set the LVDIE field to a new value. */
#define PMC_WR_LVDSC1_LVDIE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDIE_MASK, PMC_LVDSC1_LVDIE(value)))
#define PMC_BWR_LVDSC1_LVDIE(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDIE_SHIFT), PMC_LVDSC1_LVDIE_SHIFT, PMC_LVDSC1_LVDIE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage detection errors.
 * Write 1 to clear LVDF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVDACK field to a new value. */
#define PMC_WR_LVDSC1_LVDACK(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDACK_MASK, PMC_LVDSC1_LVDACK(value)))
#define PMC_BWR_LVDSC1_LVDACK(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDACK_SHIFT), PMC_LVDSC1_LVDACK_SHIFT, PMC_LVDSC1_LVDACK_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDF[7] (RO)
 *
 * This read-only status field indicates a low-voltage detect event.
 *
 * Values:
 * - 0 - Low-voltage event not detected
 * - 1 - Low-voltage event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDF field. */
#define PMC_RD_LVDSC1_LVDF(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDF_MASK) >> PMC_LVDSC1_LVDF_SHIFT)
#define PMC_BRD_LVDSC1_LVDF(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDF_SHIFT, PMC_LVDSC1_LVDF_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains status and control bits to support the low voltage
 * warning function. While the device is in the very low power or low leakage modes,
 * the LVD system is disabled regardless of LVDSC2 settings. See the device's
 * data sheet for the exact LVD trip voltages. The LVW trip voltages depend on LVWV
 * and LVDV. LVWV is reset solely on a POR Only event. The other fields of the
 * register are reset on Chip Reset Not VLLS. For more information about these
 * reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC2 register
 */
/*@{*/
#define PMC_RD_LVDSC2(base)      (PMC_LVDSC2_REG(base))
#define PMC_WR_LVDSC2(base, value) (PMC_LVDSC2_REG(base) = (value))
#define PMC_RMW_LVDSC2(base, mask, value) (PMC_WR_LVDSC2(base, (PMC_RD_LVDSC2(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC2(base, value) (BME_OR8(&PMC_LVDSC2_REG(base), (uint8_t)(value)))
#define PMC_CLR_LVDSC2(base, value) (BME_AND8(&PMC_LVDSC2_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_LVDSC2(base, value) (BME_XOR8(&PMC_LVDSC2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC2 bitfields
 */

/*!
 * @name Register PMC_LVDSC2, field LVWV[1:0] (RW)
 *
 * Selects the LVW trip point voltage (VLVW). The actual voltage for the warning
 * depends on LVDSC1[LVDV].
 *
 * Values:
 * - 00 - Low trip point selected (VLVW = VLVW1)
 * - 01 - Mid 1 trip point selected (VLVW = VLVW2)
 * - 10 - Mid 2 trip point selected (VLVW = VLVW3)
 * - 11 - High trip point selected (VLVW = VLVW4)
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWV field. */
#define PMC_RD_LVDSC2_LVWV(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWV_MASK) >> PMC_LVDSC2_LVWV_SHIFT)
#define PMC_BRD_LVDSC2_LVWV(base) (BME_UBFX8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWV_SHIFT, PMC_LVDSC2_LVWV_WIDTH))

/*! @brief Set the LVWV field to a new value. */
#define PMC_WR_LVDSC2_LVWV(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWV_MASK, PMC_LVDSC2_LVWV(value)))
#define PMC_BWR_LVDSC2_LVWV(base, value) (BME_BFI8(&PMC_LVDSC2_REG(base), ((uint8_t)(value) << PMC_LVDSC2_LVWV_SHIFT), PMC_LVDSC2_LVWV_SHIFT, PMC_LVDSC2_LVWV_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVWF.
 *
 * Values:
 * - 0 - Hardware interrupt disabled (use polling)
 * - 1 - Request a hardware interrupt when LVWF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWIE field. */
#define PMC_RD_LVDSC2_LVWIE(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWIE_MASK) >> PMC_LVDSC2_LVWIE_SHIFT)
#define PMC_BRD_LVDSC2_LVWIE(base) (BME_UBFX8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWIE_SHIFT, PMC_LVDSC2_LVWIE_WIDTH))

/*! @brief Set the LVWIE field to a new value. */
#define PMC_WR_LVDSC2_LVWIE(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWIE_MASK, PMC_LVDSC2_LVWIE(value)))
#define PMC_BWR_LVDSC2_LVWIE(base, value) (BME_BFI8(&PMC_LVDSC2_REG(base), ((uint8_t)(value) << PMC_LVDSC2_LVWIE_SHIFT), PMC_LVDSC2_LVWIE_SHIFT, PMC_LVDSC2_LVWIE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage warning errors.
 * Write 1 to clear LVWF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVWACK field to a new value. */
#define PMC_WR_LVDSC2_LVWACK(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWACK_MASK, PMC_LVDSC2_LVWACK(value)))
#define PMC_BWR_LVDSC2_LVWACK(base, value) (BME_BFI8(&PMC_LVDSC2_REG(base), ((uint8_t)(value) << PMC_LVDSC2_LVWACK_SHIFT), PMC_LVDSC2_LVWACK_SHIFT, PMC_LVDSC2_LVWACK_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWF[7] (RO)
 *
 * This read-only status field indicates a low-voltage warning event. LVWF is
 * set when VSupply transitions below the trip point, or after reset and VSupply is
 * already below VLVW. LVWF may be 1 after power-on reset, therefore, to use LVW
 * interrupt function, before enabling LVWIE, LVWF must be cleared by writing
 * LVWACK first.
 *
 * Values:
 * - 0 - Low-voltage warning event not detected
 * - 1 - Low-voltage warning event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWF field. */
#define PMC_RD_LVDSC2_LVWF(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWF_MASK) >> PMC_LVDSC2_LVWF_SHIFT)
#define PMC_BRD_LVDSC2_LVWF(base) (BME_UBFX8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWF_SHIFT, PMC_LVDSC2_LVWF_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_REGSC - Regulator Status And Control register
 ******************************************************************************/

/*!
 * @brief PMC_REGSC - Regulator Status And Control register (RW)
 *
 * Reset value: 0x04U
 *
 * The PMC contains an internal voltage regulator. The voltage regulator design
 * uses a bandgap reference that is also available through a buffer as input to
 * certain internal peripherals, such as the CMP and ADC. The internal regulator
 * provides a status bit (REGONS) indicating the regulator is in run regulation.
 * This register is reset on Chip Reset Not VLLS and by reset types that trigger
 * Chip Reset not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire PMC_REGSC register
 */
/*@{*/
#define PMC_RD_REGSC(base)       (PMC_REGSC_REG(base))
#define PMC_WR_REGSC(base, value) (PMC_REGSC_REG(base) = (value))
#define PMC_RMW_REGSC(base, mask, value) (PMC_WR_REGSC(base, (PMC_RD_REGSC(base) & ~(mask)) | (value)))
#define PMC_SET_REGSC(base, value) (BME_OR8(&PMC_REGSC_REG(base), (uint8_t)(value)))
#define PMC_CLR_REGSC(base, value) (BME_AND8(&PMC_REGSC_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_REGSC(base, value) (BME_XOR8(&PMC_REGSC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_REGSC bitfields
 */

/*!
 * @name Register PMC_REGSC, field BGBE[0] (RW)
 *
 * Enables the bandgap buffer.
 *
 * Values:
 * - 0 - Bandgap buffer not enabled
 * - 1 - Bandgap buffer enabled
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BGBE field. */
#define PMC_RD_REGSC_BGBE(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BGBE_MASK) >> PMC_REGSC_BGBE_SHIFT)
#define PMC_BRD_REGSC_BGBE(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_BGBE_SHIFT, PMC_REGSC_BGBE_WIDTH))

/*! @brief Set the BGBE field to a new value. */
#define PMC_WR_REGSC_BGBE(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_BGBE_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_BGBE(value)))
#define PMC_BWR_REGSC_BGBE(base, value) (BME_BFI8(&PMC_REGSC_REG(base), ((uint8_t)(value) << PMC_REGSC_BGBE_SHIFT), PMC_REGSC_BGBE_SHIFT, PMC_REGSC_BGBE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field REGONS[2] (RO)
 *
 * This read-only field provides the current status of the internal voltage
 * regulator.
 *
 * Values:
 * - 0 - Regulator is in stop regulation or in transition to/from it
 * - 1 - Regulator is in run regulation
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_REGONS field. */
#define PMC_RD_REGSC_REGONS(base) ((PMC_REGSC_REG(base) & PMC_REGSC_REGONS_MASK) >> PMC_REGSC_REGONS_SHIFT)
#define PMC_BRD_REGSC_REGONS(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_REGONS_SHIFT, PMC_REGSC_REGONS_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field ACKISO[3] (W1C)
 *
 * Reading this field indicates whether certain peripherals and the I/O pads are
 * in a latched state as a result of having been in a VLLS mode. Writing 1 to
 * this field when it is set releases the I/O pads and certain peripherals to their
 * normal run mode state. After recovering from a VLLS mode, user should restore
 * chip configuration before clearing ACKISO. In particular, pin configuration
 * for enabled LLWU wakeup pins should be restored to avoid any LLWU flag from
 * being falsely set when ACKISO is cleared.
 *
 * Values:
 * - 0 - Peripherals and I/O pads are in normal run state.
 * - 1 - Certain peripherals and I/O pads are in an isolated and latched state.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_ACKISO field. */
#define PMC_RD_REGSC_ACKISO(base) ((PMC_REGSC_REG(base) & PMC_REGSC_ACKISO_MASK) >> PMC_REGSC_ACKISO_SHIFT)
#define PMC_BRD_REGSC_ACKISO(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_ACKISO_SHIFT, PMC_REGSC_ACKISO_WIDTH))

/*! @brief Set the ACKISO field to a new value. */
#define PMC_WR_REGSC_ACKISO(base, value) (PMC_RMW_REGSC(base, PMC_REGSC_ACKISO_MASK, PMC_REGSC_ACKISO(value)))
#define PMC_BWR_REGSC_ACKISO(base, value) (BME_BFI8(&PMC_REGSC_REG(base), ((uint8_t)(value) << PMC_REGSC_ACKISO_SHIFT), PMC_REGSC_ACKISO_SHIFT, PMC_REGSC_ACKISO_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field BGEN[4] (RW)
 *
 * BGEN controls whether the bandgap is enabled in lower power modes of
 * operation (VLPx, and VLLSx). When on-chip peripherals require the bandgap voltage
 * reference in low power modes of operation, set BGEN to continue to enable the
 * bandgap operation. When the bandgap voltage reference is not needed in low power
 * modes, clear BGEN to avoid excess power consumption.
 *
 * Values:
 * - 0 - Bandgap voltage reference is disabled in VLPx , and VLLSx modes.
 * - 1 - Bandgap voltage reference is enabled in VLPx , and VLLSx modes.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BGEN field. */
#define PMC_RD_REGSC_BGEN(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BGEN_MASK) >> PMC_REGSC_BGEN_SHIFT)
#define PMC_BRD_REGSC_BGEN(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_BGEN_SHIFT, PMC_REGSC_BGEN_WIDTH))

/*! @brief Set the BGEN field to a new value. */
#define PMC_WR_REGSC_BGEN(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_BGEN_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_BGEN(value)))
#define PMC_BWR_REGSC_BGEN(base, value) (BME_BFI8(&PMC_REGSC_REG(base), ((uint8_t)(value) << PMC_REGSC_BGEN_SHIFT), PMC_REGSC_BGEN_SHIFT, PMC_REGSC_BGEN_WIDTH))
/*@}*/

/*
 * MKV10Z7 PORT
 *
 * Pin Control and Interrupts
 *
 * Registers defined in this header file:
 * - PORT_PCR - Pin Control Register n
 * - PORT_GPCLR - Global Pin Control Low Register
 * - PORT_GPCHR - Global Pin Control High Register
 * - PORT_ISFR - Interrupt Status Flag Register
 */

#define PORT_INSTANCE_COUNT (5U) /*!< Number of instances of the PORT module. */
#define PORTA_IDX (0U) /*!< Instance number for PORTA. */
#define PORTB_IDX (1U) /*!< Instance number for PORTB. */
#define PORTC_IDX (2U) /*!< Instance number for PORTC. */
#define PORTD_IDX (3U) /*!< Instance number for PORTD. */
#define PORTE_IDX (4U) /*!< Instance number for PORTE. */

/*******************************************************************************
 * PORT_PCR - Pin Control Register n
 ******************************************************************************/

/*!
 * @brief PORT_PCR - Pin Control Register n (RW)
 *
 * Reset value: 0x00000702U
 *
 * See the Signal Multiplexing and Pin Assignment chapter for the reset value of
 * this device. See the GPIO Configuration section for details on the available
 * functions for each pin. Do not modify pin configuration registers associated
 * with pins not available in your selected package. All unbonded pins not
 * available in your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire PORT_PCR register
 */
/*@{*/
#define PORT_RD_PCR(base, index) (PORT_PCR_REG(base, index))
#define PORT_WR_PCR(base, index, value) (PORT_PCR_REG(base, index) = (value))
#define PORT_RMW_PCR(base, index, mask, value) (PORT_WR_PCR(base, index, (PORT_RD_PCR(base, index) & ~(mask)) | (value)))
#define PORT_SET_PCR(base, index, value) (BME_OR32(&PORT_PCR_REG(base, index), (uint32_t)(value)))
#define PORT_CLR_PCR(base, index, value) (BME_AND32(&PORT_PCR_REG(base, index), (uint32_t)(~(value))))
#define PORT_TOG_PCR(base, index, value) (BME_XOR32(&PORT_PCR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PORT_PCR bitfields
 */

/*!
 * @name Register PORT_PCR, field PS[0] (RW)
 *
 * This bit is read only for pins that do not support a configurable pull
 * resistor direction. Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Internal pulldown resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 * - 1 - Internal pullup resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PS field. */
#define PORT_RD_PCR_PS(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PS_MASK) >> PORT_PCR_PS_SHIFT)
#define PORT_BRD_PCR_PS(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PS_SHIFT, PORT_PCR_PS_WIDTH))

/*! @brief Set the PS field to a new value. */
#define PORT_WR_PCR_PS(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PS_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PS(value)))
#define PORT_BWR_PCR_PS(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PS_SHIFT), PORT_PCR_PS_SHIFT, PORT_PCR_PS_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field PE[1] (RW)
 *
 * This field is read-only for pins that do not support a configurable pull
 * resistor. Refer to the Chapter of Signal Multiplexing and Signal Descriptions for
 * the pins that support a configurable pull resistor. Pull configuration is
 * valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Internal pullup or pulldown resistor is not enabled on the
 *     corresponding pin.
 * - 1 - Internal pullup or pulldown resistor is enabled on the corresponding
 *     pin, if the pin is configured as a digital input.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PE field. */
#define PORT_RD_PCR_PE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PE_MASK) >> PORT_PCR_PE_SHIFT)
#define PORT_BRD_PCR_PE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PE_SHIFT, PORT_PCR_PE_WIDTH))

/*! @brief Set the PE field to a new value. */
#define PORT_WR_PCR_PE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PE(value)))
#define PORT_BWR_PCR_PE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PE_SHIFT), PORT_PCR_PE_SHIFT, PORT_PCR_PE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field SRE[2] (RW)
 *
 * This field is read-only for pins that do not support a configurable slew
 * rate. Slew rate configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Fast slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 * - 1 - Slow slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_SRE field. */
#define PORT_RD_PCR_SRE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_SRE_MASK) >> PORT_PCR_SRE_SHIFT)
#define PORT_BRD_PCR_SRE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_SRE_SHIFT, PORT_PCR_SRE_WIDTH))

/*! @brief Set the SRE field to a new value. */
#define PORT_WR_PCR_SRE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_SRE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_SRE(value)))
#define PORT_BWR_PCR_SRE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_SRE_SHIFT), PORT_PCR_SRE_SHIFT, PORT_PCR_SRE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field PFE[4] (RW)
 *
 * This field is read-only for pins that do not support a configurable passive
 * input filter. Passive filter configuration is valid in all digital pin muxing
 * modes.
 *
 * Values:
 * - 0 - Passive input filter is disabled on the corresponding pin.
 * - 1 - Passive input filter is enabled on the corresponding pin, if the pin is
 *     configured as a digital input. Refer to the device data sheet for filter
 *     characteristics.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PFE field. */
#define PORT_RD_PCR_PFE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PFE_MASK) >> PORT_PCR_PFE_SHIFT)
#define PORT_BRD_PCR_PFE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PFE_SHIFT, PORT_PCR_PFE_WIDTH))

/*! @brief Set the PFE field to a new value. */
#define PORT_WR_PCR_PFE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PFE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PFE(value)))
#define PORT_BWR_PCR_PFE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PFE_SHIFT), PORT_PCR_PFE_SHIFT, PORT_PCR_PFE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field DSE[6] (RW)
 *
 * This field is read-only for pins that do not support a configurable drive
 * strength. Drive strength configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Low drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 * - 1 - High drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_DSE field. */
#define PORT_RD_PCR_DSE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_DSE_MASK) >> PORT_PCR_DSE_SHIFT)
#define PORT_BRD_PCR_DSE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_DSE_SHIFT, PORT_PCR_DSE_WIDTH))

/*! @brief Set the DSE field to a new value. */
#define PORT_WR_PCR_DSE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_DSE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_DSE(value)))
#define PORT_BWR_PCR_DSE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_DSE_SHIFT), PORT_PCR_DSE_SHIFT, PORT_PCR_DSE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field MUX[10:8] (RW)
 *
 * Not all pins support all pin muxing slots. Unimplemented pin muxing slots are
 * reserved and may result in configuring the pin for a different pin muxing
 * slot. The corresponding pin is configured in the following pin muxing slot as
 * follows:
 *
 * Values:
 * - 000 - Pin disabled (analog).
 * - 001 - Alternative 1 (GPIO).
 * - 010 - Alternative 2 (chip-specific).
 * - 011 - Alternative 3 (chip-specific).
 * - 100 - Alternative 4 (chip-specific).
 * - 101 - Alternative 5 (chip-specific).
 * - 110 - Alternative 6 (chip-specific).
 * - 111 - Alternative 7 (chip-specific).
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_MUX field. */
#define PORT_RD_PCR_MUX(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_MUX_MASK) >> PORT_PCR_MUX_SHIFT)
#define PORT_BRD_PCR_MUX(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_MUX_SHIFT, PORT_PCR_MUX_WIDTH))

/*! @brief Set the MUX field to a new value. */
#define PORT_WR_PCR_MUX(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_MUX_MASK | PORT_PCR_ISF_MASK), PORT_PCR_MUX(value)))
#define PORT_BWR_PCR_MUX(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_MUX_SHIFT), PORT_PCR_MUX_SHIFT, PORT_PCR_MUX_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field IRQC[19:16] (RW)
 *
 * This field is read-only for pins that do not support interrupt generation.
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * corresponding pin is configured to generate interrupt/DMA request as follows:
 *
 * Values:
 * - 0000 - Flag is disabled.
 * - 0001 - Flag and DMA request on rising edge.
 * - 0010 - Flag and DMA request on falling edge.
 * - 0011 - Flag and DMA request on either edge.
 * - 0100 - Reserved.
 * - 0101 - Reserved.
 * - 0110 - Reserved.
 * - 0111 - Reserved.
 * - 1000 - Flag and Interrupt when logic 0.
 * - 1001 - Flag and Interrupt on rising-edge.
 * - 1010 - Flag and Interrupt on falling-edge.
 * - 1011 - Flag and Interrupt on either edge.
 * - 1100 - Flag and Interrupt when logic 1.
 * - 1101 - Reserved.
 * - 1110 - Reserved.
 * - 1111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_IRQC field. */
#define PORT_RD_PCR_IRQC(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_IRQC_MASK) >> PORT_PCR_IRQC_SHIFT)
#define PORT_BRD_PCR_IRQC(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_IRQC_SHIFT, PORT_PCR_IRQC_WIDTH))

/*! @brief Set the IRQC field to a new value. */
#define PORT_WR_PCR_IRQC(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_IRQC_MASK | PORT_PCR_ISF_MASK), PORT_PCR_IRQC(value)))
#define PORT_BWR_PCR_IRQC(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_IRQC_SHIFT), PORT_PCR_IRQC_SHIFT, PORT_PCR_IRQC_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field ISF[24] (W1C)
 *
 * This field is read-only for pins that do not support interrupt generation.
 * The pin interrupt configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Configured interrupt is not detected.
 * - 1 - Configured interrupt is detected. If the pin is configured to generate
 *     a DMA request, then the corresponding flag will be cleared automatically
 *     at the completion of the requested DMA transfer. Otherwise, the flag
 *     remains set until a logic 1 is written to the flag. If the pin is configured for
 *     a level sensitive interrupt and the pin remains asserted, then the flag
 *     is set again immediately after it is cleared.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ISF field. */
#define PORT_RD_PCR_ISF(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ISF_MASK) >> PORT_PCR_ISF_SHIFT)
#define PORT_BRD_PCR_ISF(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_ISF_SHIFT, PORT_PCR_ISF_WIDTH))

/*! @brief Set the ISF field to a new value. */
#define PORT_WR_PCR_ISF(base, index, value) (PORT_RMW_PCR(base, index, PORT_PCR_ISF_MASK, PORT_PCR_ISF(value)))
#define PORT_BWR_PCR_ISF(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_ISF_SHIFT), PORT_PCR_ISF_SHIFT, PORT_PCR_ISF_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_GPCLR - Global Pin Control Low Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCLR - Global Pin Control Low Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCLR register
 */
/*@{*/
#define PORT_RD_GPCLR(base)      (PORT_GPCLR_REG(base))
#define PORT_WR_GPCLR(base, value) (PORT_GPCLR_REG(base) = (value))
#define PORT_RMW_GPCLR(base, mask, value) (PORT_WR_GPCLR(base, (PORT_RD_GPCLR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCLR bitfields
 */

/*!
 * @name Register PORT_GPCLR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCLR_GPWD(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWD_MASK, PORT_GPCLR_GPWD(value)))
#define PORT_BWR_GPCLR_GPWD(base, value) (BME_BFI32(&PORT_GPCLR_REG(base), ((uint32_t)(value) << PORT_GPCLR_GPWD_SHIFT), PORT_GPCLR_GPWD_SHIFT, PORT_GPCLR_GPWD_WIDTH))
/*@}*/

/*!
 * @name Register PORT_GPCLR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (15 through 0) bits [15:0] update with
 * the value in GPWD.
 *
 * Values:
 * - 0 - Corresponding Pin Control Register is not updated with the value in
 *     GPWD.
 * - 1 - Corresponding Pin Control Register is updated with the value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCLR_GPWE(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWE_MASK, PORT_GPCLR_GPWE(value)))
#define PORT_BWR_GPCLR_GPWE(base, value) (BME_BFI32(&PORT_GPCLR_REG(base), ((uint32_t)(value) << PORT_GPCLR_GPWE_SHIFT), PORT_GPCLR_GPWE_SHIFT, PORT_GPCLR_GPWE_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_GPCHR - Global Pin Control High Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCHR - Global Pin Control High Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCHR register
 */
/*@{*/
#define PORT_RD_GPCHR(base)      (PORT_GPCHR_REG(base))
#define PORT_WR_GPCHR(base, value) (PORT_GPCHR_REG(base) = (value))
#define PORT_RMW_GPCHR(base, mask, value) (PORT_WR_GPCHR(base, (PORT_RD_GPCHR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCHR bitfields
 */

/*!
 * @name Register PORT_GPCHR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCHR_GPWD(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWD_MASK, PORT_GPCHR_GPWD(value)))
#define PORT_BWR_GPCHR_GPWD(base, value) (BME_BFI32(&PORT_GPCHR_REG(base), ((uint32_t)(value) << PORT_GPCHR_GPWD_SHIFT), PORT_GPCHR_GPWD_SHIFT, PORT_GPCHR_GPWD_WIDTH))
/*@}*/

/*!
 * @name Register PORT_GPCHR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (31 through 16) bits [15:0] update with
 * the value in GPWD.
 *
 * Values:
 * - 0 - Corresponding Pin Control Register is not updated with the value in
 *     GPWD.
 * - 1 - Corresponding Pin Control Register is updated with the value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCHR_GPWE(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWE_MASK, PORT_GPCHR_GPWE(value)))
#define PORT_BWR_GPCHR_GPWE(base, value) (BME_BFI32(&PORT_GPCHR_REG(base), ((uint32_t)(value) << PORT_GPCHR_GPWE_SHIFT), PORT_GPCHR_GPWE_SHIFT, PORT_GPCHR_GPWE_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_ISFR - Interrupt Status Flag Register
 ******************************************************************************/

/*!
 * @brief PORT_ISFR - Interrupt Status Flag Register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * The corresponding bit is read only for pins that do not support interrupt
 * generation. The pin interrupt configuration is valid in all digital pin muxing
 * modes. The Interrupt Status Flag for each pin is also visible in the
 * corresponding Pin Control Register, and each flag can be cleared in either location.
 */
/*!
 * @name Constants and macros for entire PORT_ISFR register
 */
/*@{*/
#define PORT_RD_ISFR(base)       (PORT_ISFR_REG(base))
#define PORT_WR_ISFR(base, value) (PORT_ISFR_REG(base) = (value))
#define PORT_RMW_ISFR(base, mask, value) (PORT_WR_ISFR(base, (PORT_RD_ISFR(base) & ~(mask)) | (value)))
#define PORT_SET_ISFR(base, value) (BME_OR32(&PORT_ISFR_REG(base), (uint32_t)(value)))
#define PORT_CLR_ISFR(base, value) (BME_AND32(&PORT_ISFR_REG(base), (uint32_t)(~(value))))
#define PORT_TOG_ISFR(base, value) (BME_XOR32(&PORT_ISFR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * MKV10Z7 RCM
 *
 * Reset Control Module
 *
 * Registers defined in this header file:
 * - RCM_SRS0 - System Reset Status Register 0
 * - RCM_SRS1 - System Reset Status Register 1
 * - RCM_RPFC - Reset Pin Filter Control register
 * - RCM_RPFW - Reset Pin Filter Width register
 */

#define RCM_INSTANCE_COUNT (1U) /*!< Number of instances of the RCM module. */
#define RCM_IDX (0U) /*!< Instance number for RCM. */

/*******************************************************************************
 * RCM_SRS0 - System Reset Status Register 0
 ******************************************************************************/

/*!
 * @brief RCM_SRS0 - System Reset Status Register 0 (RO)
 *
 * Reset value: 0x82U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x82 LVD (without POR) - 0x02 VLLS mode wakeup due to RESET
 * pin assertion - 0x41 VLLS mode wakeup due to other wakeup sources - 0x01 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS0 register
 */
/*@{*/
#define RCM_RD_SRS0(base)        (RCM_SRS0_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS0 bitfields
 */

/*!
 * @name Register RCM_SRS0, field WAKEUP[0] (RO)
 *
 * Indicates a reset has been caused by an enabled LLWU module wakeup source
 * while the chip was in a low leakage mode. Any enabled wakeup source in a VLLSx
 * mode causes a reset. This bit is cleared by any reset except WAKEUP.
 *
 * Values:
 * - 0 - Reset not caused by LLWU module wakeup source
 * - 1 - Reset caused by LLWU module wakeup source
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_WAKEUP field. */
#define RCM_RD_SRS0_WAKEUP(base) ((RCM_SRS0_REG(base) & RCM_SRS0_WAKEUP_MASK) >> RCM_SRS0_WAKEUP_SHIFT)
#define RCM_BRD_SRS0_WAKEUP(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_WAKEUP_SHIFT, RCM_SRS0_WAKEUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LVD[1] (RO)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0 - Reset not caused by LVD trip or POR
 * - 1 - Reset caused by LVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LVD field. */
#define RCM_RD_SRS0_LVD(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LVD_MASK) >> RCM_SRS0_LVD_SHIFT)
#define RCM_BRD_SRS0_LVD(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_LVD_SHIFT, RCM_SRS0_LVD_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LOC[2] (RO)
 *
 * Indicates a reset has been caused by a loss of external clock. The MCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the
 * detailed MCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0 - Reset not caused by a loss of external clock.
 * - 1 - Reset caused by a loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LOC field. */
#define RCM_RD_SRS0_LOC(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LOC_MASK) >> RCM_SRS0_LOC_SHIFT)
#define RCM_BRD_SRS0_LOC(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_LOC_SHIFT, RCM_SRS0_LOC_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field WDOG[5] (RO)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0 - Reset not caused by watchdog timeout
 * - 1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_WDOG field. */
#define RCM_RD_SRS0_WDOG(base) ((RCM_SRS0_REG(base) & RCM_SRS0_WDOG_MASK) >> RCM_SRS0_WDOG_SHIFT)
#define RCM_BRD_SRS0_WDOG(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_WDOG_SHIFT, RCM_SRS0_WDOG_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field PIN[6] (RO)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET pin.
 *
 * Values:
 * - 0 - Reset not caused by external reset pin
 * - 1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_PIN field. */
#define RCM_RD_SRS0_PIN(base) ((RCM_SRS0_REG(base) & RCM_SRS0_PIN_MASK) >> RCM_SRS0_PIN_SHIFT)
#define RCM_BRD_SRS0_PIN(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_PIN_SHIFT, RCM_SRS0_PIN_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field POR[7] (RO)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0 - Reset not caused by POR
 * - 1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_POR field. */
#define RCM_RD_SRS0_POR(base) ((RCM_SRS0_REG(base) & RCM_SRS0_POR_MASK) >> RCM_SRS0_POR_SHIFT)
#define RCM_BRD_SRS0_POR(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_POR_SHIFT, RCM_SRS0_POR_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_SRS1 - System Reset Status Register 1
 ******************************************************************************/

/*!
 * @brief RCM_SRS1 - System Reset Status Register 1 (RO)
 *
 * Reset value: 0x00U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x00 LVD (without POR) - 0x00 VLLS mode wakeup - 0x00 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS1 register
 */
/*@{*/
#define RCM_RD_SRS1(base)        (RCM_SRS1_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS1 bitfields
 */

/*!
 * @name Register RCM_SRS1, field LOCKUP[1] (RO)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0 - Reset not caused by core LOCKUP event
 * - 1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_LOCKUP field. */
#define RCM_RD_SRS1_LOCKUP(base) ((RCM_SRS1_REG(base) & RCM_SRS1_LOCKUP_MASK) >> RCM_SRS1_LOCKUP_SHIFT)
#define RCM_BRD_SRS1_LOCKUP(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_LOCKUP_SHIFT, RCM_SRS1_LOCKUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SW[2] (RO)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core.
 *
 * Values:
 * - 0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_SW field. */
#define RCM_RD_SRS1_SW(base) ((RCM_SRS1_REG(base) & RCM_SRS1_SW_MASK) >> RCM_SRS1_SW_SHIFT)
#define RCM_BRD_SRS1_SW(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_SW_SHIFT, RCM_SRS1_SW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field MDM_AP[3] (RO)
 *
 * Indicates a reset has been caused by the host debugger system setting of the
 * System Reset Request bit in the MDM-AP Control Register.
 *
 * Values:
 * - 0 - Reset not caused by host debugger system setting of the System Reset
 *     Request bit
 * - 1 - Reset caused by host debugger system setting of the System Reset
 *     Request bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_MDM_AP field. */
#define RCM_RD_SRS1_MDM_AP(base) ((RCM_SRS1_REG(base) & RCM_SRS1_MDM_AP_MASK) >> RCM_SRS1_MDM_AP_SHIFT)
#define RCM_BRD_SRS1_MDM_AP(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_MDM_AP_SHIFT, RCM_SRS1_MDM_AP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SACKERR[5] (RO)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0 - Reset not caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 * - 1 - Reset caused by peripheral failure to acknowledge attempt to enter stop
 *     mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_SACKERR field. */
#define RCM_RD_SRS1_SACKERR(base) ((RCM_SRS1_REG(base) & RCM_SRS1_SACKERR_MASK) >> RCM_SRS1_SACKERR_SHIFT)
#define RCM_BRD_SRS1_SACKERR(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_SACKERR_SHIFT, RCM_SRS1_SACKERR_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_RPFC - Reset Pin Filter Control register
 ******************************************************************************/

/*!
 * @brief RCM_RPFC - Reset Pin Filter Control register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of bits 2-0 are for Chip POR only. They are unaffected by
 * other reset types. The bus clock filter is reset when disabled or when entering
 * stop mode. The LPO filter is reset when disabled .
 */
/*!
 * @name Constants and macros for entire RCM_RPFC register
 */
/*@{*/
#define RCM_RD_RPFC(base)        (RCM_RPFC_REG(base))
#define RCM_WR_RPFC(base, value) (RCM_RPFC_REG(base) = (value))
#define RCM_RMW_RPFC(base, mask, value) (RCM_WR_RPFC(base, (RCM_RD_RPFC(base) & ~(mask)) | (value)))
#define RCM_SET_RPFC(base, value) (BME_OR8(&RCM_RPFC_REG(base), (uint8_t)(value)))
#define RCM_CLR_RPFC(base, value) (BME_AND8(&RCM_RPFC_REG(base), (uint8_t)(~(value))))
#define RCM_TOG_RPFC(base, value) (BME_XOR8(&RCM_RPFC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFC bitfields
 */

/*!
 * @name Register RCM_RPFC, field RSTFLTSRW[1:0] (RW)
 *
 * Selects how the reset pin filter is enabled in run and wait modes.
 *
 * Values:
 * - 00 - All filtering disabled
 * - 01 - Bus clock filter enabled for normal operation
 * - 10 - LPO clock filter enabled for normal operation
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFC_RSTFLTSRW field. */
#define RCM_RD_RPFC_RSTFLTSRW(base) ((RCM_RPFC_REG(base) & RCM_RPFC_RSTFLTSRW_MASK) >> RCM_RPFC_RSTFLTSRW_SHIFT)
#define RCM_BRD_RPFC_RSTFLTSRW(base) (BME_UBFX8(&RCM_RPFC_REG(base), RCM_RPFC_RSTFLTSRW_SHIFT, RCM_RPFC_RSTFLTSRW_WIDTH))

/*! @brief Set the RSTFLTSRW field to a new value. */
#define RCM_WR_RPFC_RSTFLTSRW(base, value) (RCM_RMW_RPFC(base, RCM_RPFC_RSTFLTSRW_MASK, RCM_RPFC_RSTFLTSRW(value)))
#define RCM_BWR_RPFC_RSTFLTSRW(base, value) (BME_BFI8(&RCM_RPFC_REG(base), ((uint8_t)(value) << RCM_RPFC_RSTFLTSRW_SHIFT), RCM_RPFC_RSTFLTSRW_SHIFT, RCM_RPFC_RSTFLTSRW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_RPFC, field RSTFLTSS[2] (RW)
 *
 * Selects how the reset pin filter is enabled in Stop and VLPS modes , and also
 * during VLLS mode. On exit from VLLS mode, this bit should be reconfigured
 * before clearing PMC_REGSC[ACKISO].
 *
 * Values:
 * - 0 - All filtering disabled
 * - 1 - LPO clock filter enabled
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFC_RSTFLTSS field. */
#define RCM_RD_RPFC_RSTFLTSS(base) ((RCM_RPFC_REG(base) & RCM_RPFC_RSTFLTSS_MASK) >> RCM_RPFC_RSTFLTSS_SHIFT)
#define RCM_BRD_RPFC_RSTFLTSS(base) (BME_UBFX8(&RCM_RPFC_REG(base), RCM_RPFC_RSTFLTSS_SHIFT, RCM_RPFC_RSTFLTSS_WIDTH))

/*! @brief Set the RSTFLTSS field to a new value. */
#define RCM_WR_RPFC_RSTFLTSS(base, value) (RCM_RMW_RPFC(base, RCM_RPFC_RSTFLTSS_MASK, RCM_RPFC_RSTFLTSS(value)))
#define RCM_BWR_RPFC_RSTFLTSS(base, value) (BME_BFI8(&RCM_RPFC_REG(base), ((uint8_t)(value) << RCM_RPFC_RSTFLTSS_SHIFT), RCM_RPFC_RSTFLTSS_SHIFT, RCM_RPFC_RSTFLTSS_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_RPFW - Reset Pin Filter Width register
 ******************************************************************************/

/*!
 * @brief RCM_RPFW - Reset Pin Filter Width register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of the bits in the RSTFLTSEL field are for Chip POR only.
 * They are unaffected by other reset types.
 */
/*!
 * @name Constants and macros for entire RCM_RPFW register
 */
/*@{*/
#define RCM_RD_RPFW(base)        (RCM_RPFW_REG(base))
#define RCM_WR_RPFW(base, value) (RCM_RPFW_REG(base) = (value))
#define RCM_RMW_RPFW(base, mask, value) (RCM_WR_RPFW(base, (RCM_RD_RPFW(base) & ~(mask)) | (value)))
#define RCM_SET_RPFW(base, value) (BME_OR8(&RCM_RPFW_REG(base), (uint8_t)(value)))
#define RCM_CLR_RPFW(base, value) (BME_AND8(&RCM_RPFW_REG(base), (uint8_t)(~(value))))
#define RCM_TOG_RPFW(base, value) (BME_XOR8(&RCM_RPFW_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFW bitfields
 */

/*!
 * @name Register RCM_RPFW, field RSTFLTSEL[4:0] (RW)
 *
 * Selects the reset pin bus clock filter width.
 *
 * Values:
 * - 00000 - Bus clock filter count is 1
 * - 00001 - Bus clock filter count is 2
 * - 00010 - Bus clock filter count is 3
 * - 00011 - Bus clock filter count is 4
 * - 00100 - Bus clock filter count is 5
 * - 00101 - Bus clock filter count is 6
 * - 00110 - Bus clock filter count is 7
 * - 00111 - Bus clock filter count is 8
 * - 01000 - Bus clock filter count is 9
 * - 01001 - Bus clock filter count is 10
 * - 01010 - Bus clock filter count is 11
 * - 01011 - Bus clock filter count is 12
 * - 01100 - Bus clock filter count is 13
 * - 01101 - Bus clock filter count is 14
 * - 01110 - Bus clock filter count is 15
 * - 01111 - Bus clock filter count is 16
 * - 10000 - Bus clock filter count is 17
 * - 10001 - Bus clock filter count is 18
 * - 10010 - Bus clock filter count is 19
 * - 10011 - Bus clock filter count is 20
 * - 10100 - Bus clock filter count is 21
 * - 10101 - Bus clock filter count is 22
 * - 10110 - Bus clock filter count is 23
 * - 10111 - Bus clock filter count is 24
 * - 11000 - Bus clock filter count is 25
 * - 11001 - Bus clock filter count is 26
 * - 11010 - Bus clock filter count is 27
 * - 11011 - Bus clock filter count is 28
 * - 11100 - Bus clock filter count is 29
 * - 11101 - Bus clock filter count is 30
 * - 11110 - Bus clock filter count is 31
 * - 11111 - Bus clock filter count is 32
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFW_RSTFLTSEL field. */
#define RCM_RD_RPFW_RSTFLTSEL(base) ((RCM_RPFW_REG(base) & RCM_RPFW_RSTFLTSEL_MASK) >> RCM_RPFW_RSTFLTSEL_SHIFT)
#define RCM_BRD_RPFW_RSTFLTSEL(base) (BME_UBFX8(&RCM_RPFW_REG(base), RCM_RPFW_RSTFLTSEL_SHIFT, RCM_RPFW_RSTFLTSEL_WIDTH))

/*! @brief Set the RSTFLTSEL field to a new value. */
#define RCM_WR_RPFW_RSTFLTSEL(base, value) (RCM_RMW_RPFW(base, RCM_RPFW_RSTFLTSEL_MASK, RCM_RPFW_RSTFLTSEL(value)))
#define RCM_BWR_RPFW_RSTFLTSEL(base, value) (BME_BFI8(&RCM_RPFW_REG(base), ((uint8_t)(value) << RCM_RPFW_RSTFLTSEL_SHIFT), RCM_RPFW_RSTFLTSEL_SHIFT, RCM_RPFW_RSTFLTSEL_WIDTH))
/*@}*/

/*
 * MKV10Z7 ROM
 *
 * System ROM
 *
 * Registers defined in this header file:
 * - ROM_ENTRY - Entry
 * - ROM_TABLEMARK - End of Table Marker Register
 * - ROM_SYSACCESS - System Access Register
 * - ROM_PERIPHID4 - Peripheral ID Register
 * - ROM_PERIPHID5 - Peripheral ID Register
 * - ROM_PERIPHID6 - Peripheral ID Register
 * - ROM_PERIPHID7 - Peripheral ID Register
 * - ROM_PERIPHID0 - Peripheral ID Register
 * - ROM_PERIPHID1 - Peripheral ID Register
 * - ROM_PERIPHID2 - Peripheral ID Register
 * - ROM_PERIPHID3 - Peripheral ID Register
 * - ROM_COMPID - Component ID Register
 */

#define ROM_INSTANCE_COUNT (1U) /*!< Number of instances of the ROM module. */
#define ROM_IDX (0U) /*!< Instance number for ROM. */

/*******************************************************************************
 * ROM_ENTRY - Entry
 ******************************************************************************/

/*!
 * @brief ROM_ENTRY - Entry (RO)
 *
 * Reset value: 0x00000000U
 *
 * The System ROM Table begins with "n" relative 32-bit addresses, one for each
 * debug component present in the device and terminating with an all-zero value
 * signaling the end of the table at the "n+1"-th value. It is hardwired to
 * specific values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_ENTRY register
 */
/*@{*/
#define ROM_RD_ENTRY(base, index) (ROM_ENTRY_REG(base, index))
/*@}*/

/*******************************************************************************
 * ROM_TABLEMARK - End of Table Marker Register
 ******************************************************************************/

/*!
 * @brief ROM_TABLEMARK - End of Table Marker Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates end of table marker. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_TABLEMARK register
 */
/*@{*/
#define ROM_RD_TABLEMARK(base)   (ROM_TABLEMARK_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_SYSACCESS - System Access Register
 ******************************************************************************/

/*!
 * @brief ROM_SYSACCESS - System Access Register (RO)
 *
 * Reset value: 0x00000001U
 *
 * This register indicates system access. It is hardwired to specific values
 * used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_SYSACCESS register
 */
/*@{*/
#define ROM_RD_SYSACCESS(base)   (ROM_SYSACCESS_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID4 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID4 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID4 register
 */
/*@{*/
#define ROM_RD_PERIPHID4(base)   (ROM_PERIPHID4_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID5 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID5 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID5 register
 */
/*@{*/
#define ROM_RD_PERIPHID5(base)   (ROM_PERIPHID5_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID6 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID6 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID6 register
 */
/*@{*/
#define ROM_RD_PERIPHID6(base)   (ROM_PERIPHID6_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID7 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID7 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID7 register
 */
/*@{*/
#define ROM_RD_PERIPHID7(base)   (ROM_PERIPHID7_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID0 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID0 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID0 register
 */
/*@{*/
#define ROM_RD_PERIPHID0(base)   (ROM_PERIPHID0_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID1 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID1 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID1 register
 */
/*@{*/
#define ROM_RD_PERIPHID1(base)   (ROM_PERIPHID1_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID2 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID2 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID2 register
 */
/*@{*/
#define ROM_RD_PERIPHID2(base)   (ROM_PERIPHID2_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID3 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID3 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID3 register
 */
/*@{*/
#define ROM_RD_PERIPHID3(base)   (ROM_PERIPHID3_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_COMPID - Component ID Register
 ******************************************************************************/

/*!
 * @brief ROM_COMPID - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_COMPID register
 */
/*@{*/
#define ROM_RD_COMPID(base, index) (ROM_COMPID_REG(base, index))
/*@}*/

/*
 * MKV10Z7 SIM
 *
 * System Integration Module
 *
 * Registers defined in this header file:
 * - SIM_SOPT1 - System Options Register 1
 * - SIM_SOPT2 - System Options Register 2
 * - SIM_SOPT4 - System Options Register 4
 * - SIM_SOPT5 - System Options Register 5
 * - SIM_SOPT7 - System Options Register 7
 * - SIM_SOPT8 - System Options Register 8
 * - SIM_SDID - System Device Identification Register
 * - SIM_SCGC4 - System Clock Gating Control Register 4
 * - SIM_SCGC5 - System Clock Gating Control Register 5
 * - SIM_SCGC6 - System Clock Gating Control Register 6
 * - SIM_SCGC7 - System Clock Gating Control Register 7
 * - SIM_CLKDIV1 - System Clock Divider Register 1
 * - SIM_FCFG1 - Flash Configuration Register 1
 * - SIM_FCFG2 - Flash Configuration Register 2
 * - SIM_UIDMH - Unique Identification Register Mid-High
 * - SIM_UIDML - Unique Identification Register Mid Low
 * - SIM_UIDL - Unique Identification Register Low
 * - SIM_WDOGCTRL - WDOG Control Register
 */

#define SIM_INSTANCE_COUNT (1U) /*!< Number of instances of the SIM module. */
#define SIM_IDX (0U) /*!< Instance number for SIM. */

/*******************************************************************************
 * SIM_SOPT1 - System Options Register 1
 ******************************************************************************/

/*!
 * @brief SIM_SOPT1 - System Options Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The reset value of the SOPT1 register is as follows: Exit from POR and LVD:
 * OSC32KSEL is cleared. Exit from VLLS or other system reset: OSC32KSEL are
 * unaffected
 */
/*!
 * @name Constants and macros for entire SIM_SOPT1 register
 */
/*@{*/
#define SIM_RD_SOPT1(base)       (SIM_SOPT1_REG(base))
#define SIM_WR_SOPT1(base, value) (SIM_SOPT1_REG(base) = (value))
#define SIM_RMW_SOPT1(base, mask, value) (SIM_WR_SOPT1(base, (SIM_RD_SOPT1(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT1(base, value) (BME_OR32(&SIM_SOPT1_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT1(base, value) (BME_AND32(&SIM_SOPT1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT1(base, value) (BME_XOR32(&SIM_SOPT1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1 bitfields
 */

/*!
 * @name Register SIM_SOPT1, field OSC32KSEL[19:18] (RW)
 *
 * Selects the 32 kHz clock source (ERCLK32K) for LPTMR. This field is reset
 * only for POR/LVD.
 *
 * Values:
 * - 00 - System oscillator (OSC32KCLK)
 * - 01 - Reserved
 * - 10 - Reserved
 * - 11 - LPO 1 kHz
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_OSC32KSEL field. */
#define SIM_RD_SOPT1_OSC32KSEL(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_OSC32KSEL_MASK) >> SIM_SOPT1_OSC32KSEL_SHIFT)
#define SIM_BRD_SOPT1_OSC32KSEL(base) (BME_UBFX32(&SIM_SOPT1_REG(base), SIM_SOPT1_OSC32KSEL_SHIFT, SIM_SOPT1_OSC32KSEL_WIDTH))

/*! @brief Set the OSC32KSEL field to a new value. */
#define SIM_WR_SOPT1_OSC32KSEL(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_OSC32KSEL_MASK, SIM_SOPT1_OSC32KSEL(value)))
#define SIM_BWR_SOPT1_OSC32KSEL(base, value) (BME_BFI32(&SIM_SOPT1_REG(base), ((uint32_t)(value) << SIM_SOPT1_OSC32KSEL_SHIFT), SIM_SOPT1_OSC32KSEL_SHIFT, SIM_SOPT1_OSC32KSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT2 - System Options Register 2
 ******************************************************************************/

/*!
 * @brief SIM_SOPT2 - System Options Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * SOPT2 contains the controls for selecting many of the module clock source
 * options on this device. See the Clock Distribution chapter for more information
 * including clocking diagrams and definitions of device clocks.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT2 register
 */
/*@{*/
#define SIM_RD_SOPT2(base)       (SIM_SOPT2_REG(base))
#define SIM_WR_SOPT2(base, value) (SIM_SOPT2_REG(base) = (value))
#define SIM_RMW_SOPT2(base, mask, value) (SIM_WR_SOPT2(base, (SIM_RD_SOPT2(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT2(base, value) (BME_OR32(&SIM_SOPT2_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT2(base, value) (BME_AND32(&SIM_SOPT2_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT2(base, value) (BME_XOR32(&SIM_SOPT2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT2 bitfields
 */

/*!
 * @name Register SIM_SOPT2, field CLKOUTSEL[7:5] (RW)
 *
 * Selects the clock to output on the CLKOUT pin.
 *
 * Values:
 * - 000 - Reserved
 * - 001 - Reserved
 * - 010 - Bus clock
 * - 011 - LPO clock (1 kHz)
 * - 100 - MCGIRCLK
 * - 101 - Reserved
 * - 110 - OSCERCLK
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_CLKOUTSEL field. */
#define SIM_RD_SOPT2_CLKOUTSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_CLKOUTSEL_MASK) >> SIM_SOPT2_CLKOUTSEL_SHIFT)
#define SIM_BRD_SOPT2_CLKOUTSEL(base) (BME_UBFX32(&SIM_SOPT2_REG(base), SIM_SOPT2_CLKOUTSEL_SHIFT, SIM_SOPT2_CLKOUTSEL_WIDTH))

/*! @brief Set the CLKOUTSEL field to a new value. */
#define SIM_WR_SOPT2_CLKOUTSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_CLKOUTSEL_MASK, SIM_SOPT2_CLKOUTSEL(value)))
#define SIM_BWR_SOPT2_CLKOUTSEL(base, value) (BME_BFI32(&SIM_SOPT2_REG(base), ((uint32_t)(value) << SIM_SOPT2_CLKOUTSEL_SHIFT), SIM_SOPT2_CLKOUTSEL_SHIFT, SIM_SOPT2_CLKOUTSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field FTMFFCLKSEL[25:24] (RW)
 *
 * Selects the fixed frequency clock for FTM0, FTM1, and FTM2.
 *
 * Values:
 * - 00 - MCGFFCLK
 * - 01 - MCGIRCLK
 * - 10 - OSCERCLK
 * - 11 - MCGFFCLK
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_FTMFFCLKSEL field. */
#define SIM_RD_SOPT2_FTMFFCLKSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_FTMFFCLKSEL_MASK) >> SIM_SOPT2_FTMFFCLKSEL_SHIFT)
#define SIM_BRD_SOPT2_FTMFFCLKSEL(base) (BME_UBFX32(&SIM_SOPT2_REG(base), SIM_SOPT2_FTMFFCLKSEL_SHIFT, SIM_SOPT2_FTMFFCLKSEL_WIDTH))

/*! @brief Set the FTMFFCLKSEL field to a new value. */
#define SIM_WR_SOPT2_FTMFFCLKSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_FTMFFCLKSEL_MASK, SIM_SOPT2_FTMFFCLKSEL(value)))
#define SIM_BWR_SOPT2_FTMFFCLKSEL(base, value) (BME_BFI32(&SIM_SOPT2_REG(base), ((uint32_t)(value) << SIM_SOPT2_FTMFFCLKSEL_SHIFT), SIM_SOPT2_FTMFFCLKSEL_SHIFT, SIM_SOPT2_FTMFFCLKSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT4 - System Options Register 4
 ******************************************************************************/

/*!
 * @brief SIM_SOPT4 - System Options Register 4 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT4 register
 */
/*@{*/
#define SIM_RD_SOPT4(base)       (SIM_SOPT4_REG(base))
#define SIM_WR_SOPT4(base, value) (SIM_SOPT4_REG(base) = (value))
#define SIM_RMW_SOPT4(base, mask, value) (SIM_WR_SOPT4(base, (SIM_RD_SOPT4(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT4(base, value) (BME_OR32(&SIM_SOPT4_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT4(base, value) (BME_AND32(&SIM_SOPT4_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT4(base, value) (BME_XOR32(&SIM_SOPT4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT4 bitfields
 */

/*!
 * @name Register SIM_SOPT4, field FTM0FLT0[0] (RW)
 *
 * Selects the source of FTM0 fault 0.The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0 - FTM0_FLT0 pin
 * - 1 - CMP0 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0FLT0 field. */
#define SIM_RD_SOPT4_FTM0FLT0(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0FLT0_MASK) >> SIM_SOPT4_FTM0FLT0_SHIFT)
#define SIM_BRD_SOPT4_FTM0FLT0(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0FLT0_SHIFT, SIM_SOPT4_FTM0FLT0_WIDTH))

/*! @brief Set the FTM0FLT0 field to a new value. */
#define SIM_WR_SOPT4_FTM0FLT0(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0FLT0_MASK, SIM_SOPT4_FTM0FLT0(value)))
#define SIM_BWR_SOPT4_FTM0FLT0(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0FLT0_SHIFT), SIM_SOPT4_FTM0FLT0_SHIFT, SIM_SOPT4_FTM0FLT0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0FLT1[1] (RW)
 *
 * Selects the source of FTM0 fault 1.The pin source for fault 1 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0 - FTM0_FLT1 pin
 * - 1 - CMP1 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0FLT1 field. */
#define SIM_RD_SOPT4_FTM0FLT1(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0FLT1_MASK) >> SIM_SOPT4_FTM0FLT1_SHIFT)
#define SIM_BRD_SOPT4_FTM0FLT1(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0FLT1_SHIFT, SIM_SOPT4_FTM0FLT1_WIDTH))

/*! @brief Set the FTM0FLT1 field to a new value. */
#define SIM_WR_SOPT4_FTM0FLT1(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0FLT1_MASK, SIM_SOPT4_FTM0FLT1(value)))
#define SIM_BWR_SOPT4_FTM0FLT1(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0FLT1_SHIFT), SIM_SOPT4_FTM0FLT1_SHIFT, SIM_SOPT4_FTM0FLT1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1FLT0[2] (RW)
 *
 * Selects the source of FTM1 fault 0.The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0 - FTM1_FLT0 pin
 * - 1 - CMP0 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM1FLT0 field. */
#define SIM_RD_SOPT4_FTM1FLT0(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM1FLT0_MASK) >> SIM_SOPT4_FTM1FLT0_SHIFT)
#define SIM_BRD_SOPT4_FTM1FLT0(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1FLT0_SHIFT, SIM_SOPT4_FTM1FLT0_WIDTH))

/*! @brief Set the FTM1FLT0 field to a new value. */
#define SIM_WR_SOPT4_FTM1FLT0(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM1FLT0_MASK, SIM_SOPT4_FTM1FLT0(value)))
#define SIM_BWR_SOPT4_FTM1FLT0(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM1FLT0_SHIFT), SIM_SOPT4_FTM1FLT0_SHIFT, SIM_SOPT4_FTM1FLT0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2FLT0[3] (RW)
 *
 * Selects the source of FTM2 fault 0. The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0 - FTM2_FLT0 pin
 * - 1 - CMP0 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM2FLT0 field. */
#define SIM_RD_SOPT4_FTM2FLT0(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM2FLT0_MASK) >> SIM_SOPT4_FTM2FLT0_SHIFT)
#define SIM_BRD_SOPT4_FTM2FLT0(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM2FLT0_SHIFT, SIM_SOPT4_FTM2FLT0_WIDTH))

/*! @brief Set the FTM2FLT0 field to a new value. */
#define SIM_WR_SOPT4_FTM2FLT0(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM2FLT0_MASK, SIM_SOPT4_FTM2FLT0(value)))
#define SIM_BWR_SOPT4_FTM2FLT0(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM2FLT0_SHIFT), SIM_SOPT4_FTM2FLT0_SHIFT, SIM_SOPT4_FTM2FLT0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0TRG0SRC[7] (RW)
 *
 * Selects the source of FTM0 hardware trigger 0.
 *
 * Values:
 * - 0 - HSCMP0 output drives FTM0 hardware trigger 0
 * - 1 - FTM1 channel match drives FTM0 hardware trigger 0
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0TRG0SRC field. */
#define SIM_RD_SOPT4_FTM0TRG0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0TRG0SRC_MASK) >> SIM_SOPT4_FTM0TRG0SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM0TRG0SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0TRG0SRC_SHIFT, SIM_SOPT4_FTM0TRG0SRC_WIDTH))

/*! @brief Set the FTM0TRG0SRC field to a new value. */
#define SIM_WR_SOPT4_FTM0TRG0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0TRG0SRC_MASK, SIM_SOPT4_FTM0TRG0SRC(value)))
#define SIM_BWR_SOPT4_FTM0TRG0SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0TRG0SRC_SHIFT), SIM_SOPT4_FTM0TRG0SRC_SHIFT, SIM_SOPT4_FTM0TRG0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0TRG1SRC[8] (RW)
 *
 * Selects the source of FTM0 hardware trigger 1.
 *
 * Values:
 * - 0 - PDB channel 1 trigger drives FTM0 hardware trigger 1
 * - 1 - FTM2 channel match drives FTM0 hardware trigger 1
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0TRG1SRC field. */
#define SIM_RD_SOPT4_FTM0TRG1SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0TRG1SRC_MASK) >> SIM_SOPT4_FTM0TRG1SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM0TRG1SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0TRG1SRC_SHIFT, SIM_SOPT4_FTM0TRG1SRC_WIDTH))

/*! @brief Set the FTM0TRG1SRC field to a new value. */
#define SIM_WR_SOPT4_FTM0TRG1SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0TRG1SRC_MASK, SIM_SOPT4_FTM0TRG1SRC(value)))
#define SIM_BWR_SOPT4_FTM0TRG1SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0TRG1SRC_SHIFT), SIM_SOPT4_FTM0TRG1SRC_SHIFT, SIM_SOPT4_FTM0TRG1SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0TRG2SRC[9] (RW)
 *
 * Selects the source of FTM0 hardware trigger 2.
 *
 * Values:
 * - 0 - HSCMP0 output drives FTM0 hardware trigger 2
 * - 1 - HSCMP1 output drives FTM0 hardware trigger 2
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0TRG2SRC field. */
#define SIM_RD_SOPT4_FTM0TRG2SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0TRG2SRC_MASK) >> SIM_SOPT4_FTM0TRG2SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM0TRG2SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0TRG2SRC_SHIFT, SIM_SOPT4_FTM0TRG2SRC_WIDTH))

/*! @brief Set the FTM0TRG2SRC field to a new value. */
#define SIM_WR_SOPT4_FTM0TRG2SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0TRG2SRC_MASK, SIM_SOPT4_FTM0TRG2SRC(value)))
#define SIM_BWR_SOPT4_FTM0TRG2SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0TRG2SRC_SHIFT), SIM_SOPT4_FTM0TRG2SRC_SHIFT, SIM_SOPT4_FTM0TRG2SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1TRG0SRC[10] (RW)
 *
 * Selects the source of FTM1 hardware trigger 0.
 *
 * Values:
 * - 0 - HSCMP0 output drives FTM1 hardware trigger 0
 * - 1 - FTM0 channel match drives FTM1 hardware trigger 0
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM1TRG0SRC field. */
#define SIM_RD_SOPT4_FTM1TRG0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM1TRG0SRC_MASK) >> SIM_SOPT4_FTM1TRG0SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM1TRG0SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1TRG0SRC_SHIFT, SIM_SOPT4_FTM1TRG0SRC_WIDTH))

/*! @brief Set the FTM1TRG0SRC field to a new value. */
#define SIM_WR_SOPT4_FTM1TRG0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM1TRG0SRC_MASK, SIM_SOPT4_FTM1TRG0SRC(value)))
#define SIM_BWR_SOPT4_FTM1TRG0SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM1TRG0SRC_SHIFT), SIM_SOPT4_FTM1TRG0SRC_SHIFT, SIM_SOPT4_FTM1TRG0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1TRG1SRC[11] (RW)
 *
 * Selects the source of FTM1 hardware trigger 1.
 *
 * Values:
 * - 0 - PDB channel 1 trigger drives FTM1 hardware trigger 1
 * - 1 - FTM2 channel match drives FTM1 hardware trigger 1
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM1TRG1SRC field. */
#define SIM_RD_SOPT4_FTM1TRG1SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM1TRG1SRC_MASK) >> SIM_SOPT4_FTM1TRG1SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM1TRG1SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1TRG1SRC_SHIFT, SIM_SOPT4_FTM1TRG1SRC_WIDTH))

/*! @brief Set the FTM1TRG1SRC field to a new value. */
#define SIM_WR_SOPT4_FTM1TRG1SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM1TRG1SRC_MASK, SIM_SOPT4_FTM1TRG1SRC(value)))
#define SIM_BWR_SOPT4_FTM1TRG1SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM1TRG1SRC_SHIFT), SIM_SOPT4_FTM1TRG1SRC_SHIFT, SIM_SOPT4_FTM1TRG1SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1TRG2SRC[12] (RW)
 *
 * Selects the source of FTM1 hardware trigger 2.
 *
 * Values:
 * - 0 - HSCMP0 output drives FTM1 hardware trigger 2
 * - 1 - HSCMP1 output drives FTM1 hardware trigger 2
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM1TRG2SRC field. */
#define SIM_RD_SOPT4_FTM1TRG2SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM1TRG2SRC_MASK) >> SIM_SOPT4_FTM1TRG2SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM1TRG2SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1TRG2SRC_SHIFT, SIM_SOPT4_FTM1TRG2SRC_WIDTH))

/*! @brief Set the FTM1TRG2SRC field to a new value. */
#define SIM_WR_SOPT4_FTM1TRG2SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM1TRG2SRC_MASK, SIM_SOPT4_FTM1TRG2SRC(value)))
#define SIM_BWR_SOPT4_FTM1TRG2SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM1TRG2SRC_SHIFT), SIM_SOPT4_FTM1TRG2SRC_SHIFT, SIM_SOPT4_FTM1TRG2SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2TRG0SRC[13] (RW)
 *
 * Selects the source of FTM2 hardware trigger 0.
 *
 * Values:
 * - 0 - HSCMP0 output drives FTM2 hardware trigger 0
 * - 1 - FTM0 channel match drives FTM2 hardware trigger 0
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM2TRG0SRC field. */
#define SIM_RD_SOPT4_FTM2TRG0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM2TRG0SRC_MASK) >> SIM_SOPT4_FTM2TRG0SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM2TRG0SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM2TRG0SRC_SHIFT, SIM_SOPT4_FTM2TRG0SRC_WIDTH))

/*! @brief Set the FTM2TRG0SRC field to a new value. */
#define SIM_WR_SOPT4_FTM2TRG0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM2TRG0SRC_MASK, SIM_SOPT4_FTM2TRG0SRC(value)))
#define SIM_BWR_SOPT4_FTM2TRG0SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM2TRG0SRC_SHIFT), SIM_SOPT4_FTM2TRG0SRC_SHIFT, SIM_SOPT4_FTM2TRG0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2TRG1SRC[14] (RW)
 *
 * Selects the source of FTM2 hardware trigger 1.
 *
 * Values:
 * - 0 - PDB output trigger 1 drives FTM2 hardware trigger 1
 * - 1 - FTM1 channel match drives FTM2 hardware trigger 1
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM2TRG1SRC field. */
#define SIM_RD_SOPT4_FTM2TRG1SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM2TRG1SRC_MASK) >> SIM_SOPT4_FTM2TRG1SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM2TRG1SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM2TRG1SRC_SHIFT, SIM_SOPT4_FTM2TRG1SRC_WIDTH))

/*! @brief Set the FTM2TRG1SRC field to a new value. */
#define SIM_WR_SOPT4_FTM2TRG1SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM2TRG1SRC_MASK, SIM_SOPT4_FTM2TRG1SRC(value)))
#define SIM_BWR_SOPT4_FTM2TRG1SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM2TRG1SRC_SHIFT), SIM_SOPT4_FTM2TRG1SRC_SHIFT, SIM_SOPT4_FTM2TRG1SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2TRG2SRC[15] (RW)
 *
 * Selects the source of FTM2 hardware trigger 2.
 *
 * Values:
 * - 0 - HSCMP0 output drives FTM2 hardware trigger 2
 * - 1 - HSCMP1 output drives FTM2 hardware trigger 2
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM2TRG2SRC field. */
#define SIM_RD_SOPT4_FTM2TRG2SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM2TRG2SRC_MASK) >> SIM_SOPT4_FTM2TRG2SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM2TRG2SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM2TRG2SRC_SHIFT, SIM_SOPT4_FTM2TRG2SRC_WIDTH))

/*! @brief Set the FTM2TRG2SRC field to a new value. */
#define SIM_WR_SOPT4_FTM2TRG2SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM2TRG2SRC_MASK, SIM_SOPT4_FTM2TRG2SRC(value)))
#define SIM_BWR_SOPT4_FTM2TRG2SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM2TRG2SRC_SHIFT), SIM_SOPT4_FTM2TRG2SRC_SHIFT, SIM_SOPT4_FTM2TRG2SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1ICH0SRC[19:18] (RW)
 *
 * Selects the source for FTM1 channel 0 input capture. When the FTM is not in
 * Input Capture mode, clear this field.
 *
 * Values:
 * - 00 - FTM1_CH0 signal
 * - 01 - CMP0 output
 * - 10 - CMP1 output
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM1ICH0SRC field. */
#define SIM_RD_SOPT4_FTM1ICH0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM1ICH0SRC_MASK) >> SIM_SOPT4_FTM1ICH0SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM1ICH0SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1ICH0SRC_SHIFT, SIM_SOPT4_FTM1ICH0SRC_WIDTH))

/*! @brief Set the FTM1ICH0SRC field to a new value. */
#define SIM_WR_SOPT4_FTM1ICH0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM1ICH0SRC_MASK, SIM_SOPT4_FTM1ICH0SRC(value)))
#define SIM_BWR_SOPT4_FTM1ICH0SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM1ICH0SRC_SHIFT), SIM_SOPT4_FTM1ICH0SRC_SHIFT, SIM_SOPT4_FTM1ICH0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2ICH0SRC[21:20] (RW)
 *
 * Selects the source for FTM2 channel 0 input capture. When the FTM is not in
 * Input Capture mode, clear this field.
 *
 * Values:
 * - 00 - FTM2_CH0 signal
 * - 01 - CMP0 output
 * - 10 - CMP1 output
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM2ICH0SRC field. */
#define SIM_RD_SOPT4_FTM2ICH0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM2ICH0SRC_MASK) >> SIM_SOPT4_FTM2ICH0SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM2ICH0SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM2ICH0SRC_SHIFT, SIM_SOPT4_FTM2ICH0SRC_WIDTH))

/*! @brief Set the FTM2ICH0SRC field to a new value. */
#define SIM_WR_SOPT4_FTM2ICH0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM2ICH0SRC_MASK, SIM_SOPT4_FTM2ICH0SRC(value)))
#define SIM_BWR_SOPT4_FTM2ICH0SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM2ICH0SRC_SHIFT), SIM_SOPT4_FTM2ICH0SRC_SHIFT, SIM_SOPT4_FTM2ICH0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2ICH1SRC[22] (RW)
 *
 * Selects the source for FTM2 channel 1 input capture. When the FTM is not in
 * Input Capture mode, clear this field.
 *
 * Values:
 * - 0 - FTM2_CH1 pin is fed to FTM2 CH1
 * - 1 - FTM2_CH1 pin XOR FTM2_CH0 pin XOR FTM1_CH1 pin is fed to FTM2 CH1 If
 *     this field is set, then the three input pins feed FTM2 channel 1 input
 *     capture. In this case, FTM1 channel 1 cannot be used for input capture of FTM1,
 *     as it has no pin. FTM1 channel1 can be used for Output Compare mode of
 *     FTM1, though without an output.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM2ICH1SRC field. */
#define SIM_RD_SOPT4_FTM2ICH1SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM2ICH1SRC_MASK) >> SIM_SOPT4_FTM2ICH1SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM2ICH1SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM2ICH1SRC_SHIFT, SIM_SOPT4_FTM2ICH1SRC_WIDTH))

/*! @brief Set the FTM2ICH1SRC field to a new value. */
#define SIM_WR_SOPT4_FTM2ICH1SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM2ICH1SRC_MASK, SIM_SOPT4_FTM2ICH1SRC(value)))
#define SIM_BWR_SOPT4_FTM2ICH1SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM2ICH1SRC_SHIFT), SIM_SOPT4_FTM2ICH1SRC_SHIFT, SIM_SOPT4_FTM2ICH1SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0CLKSEL[25:24] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM0 module. The
 * selected pin must also be configured for the FTM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 00 - FTM0 external clock driven by FTM_CLKIN0 pin
 * - 01 - FTM0 external clock driven by FTM_CLKIN1 pin
 * - 10 - FTM0 external clock driven by FTM_CLKIN2 pin
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0CLKSEL field. */
#define SIM_RD_SOPT4_FTM0CLKSEL(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0CLKSEL_MASK) >> SIM_SOPT4_FTM0CLKSEL_SHIFT)
#define SIM_BRD_SOPT4_FTM0CLKSEL(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0CLKSEL_SHIFT, SIM_SOPT4_FTM0CLKSEL_WIDTH))

/*! @brief Set the FTM0CLKSEL field to a new value. */
#define SIM_WR_SOPT4_FTM0CLKSEL(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0CLKSEL_MASK, SIM_SOPT4_FTM0CLKSEL(value)))
#define SIM_BWR_SOPT4_FTM0CLKSEL(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0CLKSEL_SHIFT), SIM_SOPT4_FTM0CLKSEL_SHIFT, SIM_SOPT4_FTM0CLKSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1CLKSEL[27:26] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM1 module. The
 * selected pin must also be configured for the FTM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 00 - FTM1 external clock driven by FTM_CLKIN0 pin
 * - 01 - FTM1 external clock driven by FTM_CLKIN1 pin
 * - 10 - FTM1 external clock driven by FTM_CLKIN2 pin
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM1CLKSEL field. */
#define SIM_RD_SOPT4_FTM1CLKSEL(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM1CLKSEL_MASK) >> SIM_SOPT4_FTM1CLKSEL_SHIFT)
#define SIM_BRD_SOPT4_FTM1CLKSEL(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1CLKSEL_SHIFT, SIM_SOPT4_FTM1CLKSEL_WIDTH))

/*! @brief Set the FTM1CLKSEL field to a new value. */
#define SIM_WR_SOPT4_FTM1CLKSEL(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM1CLKSEL_MASK, SIM_SOPT4_FTM1CLKSEL(value)))
#define SIM_BWR_SOPT4_FTM1CLKSEL(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM1CLKSEL_SHIFT), SIM_SOPT4_FTM1CLKSEL_SHIFT, SIM_SOPT4_FTM1CLKSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2CLKSEL[29:28] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM2 module. The
 * selected pin must also be configured for the FTM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 00 - FTM2 external clock driven by FTM_CLKIN0 pin
 * - 01 - FTM2 external clock driven by FTM_CLKIN1 pin
 * - 10 - FTM2 external clock driven by FTM_CLKIN2 pin
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM2CLKSEL field. */
#define SIM_RD_SOPT4_FTM2CLKSEL(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM2CLKSEL_MASK) >> SIM_SOPT4_FTM2CLKSEL_SHIFT)
#define SIM_BRD_SOPT4_FTM2CLKSEL(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM2CLKSEL_SHIFT, SIM_SOPT4_FTM2CLKSEL_WIDTH))

/*! @brief Set the FTM2CLKSEL field to a new value. */
#define SIM_WR_SOPT4_FTM2CLKSEL(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM2CLKSEL_MASK, SIM_SOPT4_FTM2CLKSEL(value)))
#define SIM_BWR_SOPT4_FTM2CLKSEL(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM2CLKSEL_SHIFT), SIM_SOPT4_FTM2CLKSEL_SHIFT, SIM_SOPT4_FTM2CLKSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT5 - System Options Register 5
 ******************************************************************************/

/*!
 * @brief SIM_SOPT5 - System Options Register 5 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT5 register
 */
/*@{*/
#define SIM_RD_SOPT5(base)       (SIM_SOPT5_REG(base))
#define SIM_WR_SOPT5(base, value) (SIM_SOPT5_REG(base) = (value))
#define SIM_RMW_SOPT5(base, mask, value) (SIM_WR_SOPT5(base, (SIM_RD_SOPT5(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT5(base, value) (BME_OR32(&SIM_SOPT5_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT5(base, value) (BME_AND32(&SIM_SOPT5_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT5(base, value) (BME_XOR32(&SIM_SOPT5_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT5 bitfields
 */

/*!
 * @name Register SIM_SOPT5, field UART0TXSRC[1:0] (RW)
 *
 * Selects the source for the UART 0 transmit data.
 *
 * Values:
 * - 00 - UART0_TX pin
 * - 01 - UART0_TX pin modulated with FTM1 channel 0 output
 * - 10 - UART0_TX pin modulated with FTM2 channel 0 output
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART0TXSRC field. */
#define SIM_RD_SOPT5_UART0TXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART0TXSRC_MASK) >> SIM_SOPT5_UART0TXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART0TXSRC(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART0TXSRC_SHIFT, SIM_SOPT5_UART0TXSRC_WIDTH))

/*! @brief Set the UART0TXSRC field to a new value. */
#define SIM_WR_SOPT5_UART0TXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART0TXSRC_MASK, SIM_SOPT5_UART0TXSRC(value)))
#define SIM_BWR_SOPT5_UART0TXSRC(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_UART0TXSRC_SHIFT), SIM_SOPT5_UART0TXSRC_SHIFT, SIM_SOPT5_UART0TXSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART0RXSRC[3:2] (RW)
 *
 * Selects the source for the UART 0 receive data.
 *
 * Values:
 * - 00 - UART0_RX pin
 * - 01 - CMP0
 * - 10 - CMP1
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART0RXSRC field. */
#define SIM_RD_SOPT5_UART0RXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART0RXSRC_MASK) >> SIM_SOPT5_UART0RXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART0RXSRC(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART0RXSRC_SHIFT, SIM_SOPT5_UART0RXSRC_WIDTH))

/*! @brief Set the UART0RXSRC field to a new value. */
#define SIM_WR_SOPT5_UART0RXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART0RXSRC_MASK, SIM_SOPT5_UART0RXSRC(value)))
#define SIM_BWR_SOPT5_UART0RXSRC(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_UART0RXSRC_SHIFT), SIM_SOPT5_UART0RXSRC_SHIFT, SIM_SOPT5_UART0RXSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART1TXSRC[5:4] (RW)
 *
 * Selects the source for the UART 1 transmit data.
 *
 * Values:
 * - 00 - UART1_TX pin
 * - 01 - UART1_TX pin modulated with FTM1 channel 0 output
 * - 10 - UART1_TX pin modulated with FTM2 channel 0 output
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART1TXSRC field. */
#define SIM_RD_SOPT5_UART1TXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART1TXSRC_MASK) >> SIM_SOPT5_UART1TXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART1TXSRC(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART1TXSRC_SHIFT, SIM_SOPT5_UART1TXSRC_WIDTH))

/*! @brief Set the UART1TXSRC field to a new value. */
#define SIM_WR_SOPT5_UART1TXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART1TXSRC_MASK, SIM_SOPT5_UART1TXSRC(value)))
#define SIM_BWR_SOPT5_UART1TXSRC(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_UART1TXSRC_SHIFT), SIM_SOPT5_UART1TXSRC_SHIFT, SIM_SOPT5_UART1TXSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART1RXSRC[7:6] (RW)
 *
 * Selects the source for the UART 1 receive data.
 *
 * Values:
 * - 00 - UART1_RX pin
 * - 01 - CMP0
 * - 10 - CMP1
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART1RXSRC field. */
#define SIM_RD_SOPT5_UART1RXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART1RXSRC_MASK) >> SIM_SOPT5_UART1RXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART1RXSRC(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART1RXSRC_SHIFT, SIM_SOPT5_UART1RXSRC_WIDTH))

/*! @brief Set the UART1RXSRC field to a new value. */
#define SIM_WR_SOPT5_UART1RXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART1RXSRC_MASK, SIM_SOPT5_UART1RXSRC(value)))
#define SIM_BWR_SOPT5_UART1RXSRC(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_UART1RXSRC_SHIFT), SIM_SOPT5_UART1RXSRC_SHIFT, SIM_SOPT5_UART1RXSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART0ODE[16] (RW)
 *
 * Values:
 * - 0 - Open drain is disabled on UART0
 * - 1 - Open drain is enabled on UART0
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART0ODE field. */
#define SIM_RD_SOPT5_UART0ODE(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART0ODE_MASK) >> SIM_SOPT5_UART0ODE_SHIFT)
#define SIM_BRD_SOPT5_UART0ODE(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART0ODE_SHIFT, SIM_SOPT5_UART0ODE_WIDTH))

/*! @brief Set the UART0ODE field to a new value. */
#define SIM_WR_SOPT5_UART0ODE(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART0ODE_MASK, SIM_SOPT5_UART0ODE(value)))
#define SIM_BWR_SOPT5_UART0ODE(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_UART0ODE_SHIFT), SIM_SOPT5_UART0ODE_SHIFT, SIM_SOPT5_UART0ODE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART1ODE[17] (RW)
 *
 * Values:
 * - 0 - Open drain is disabled on UART1
 * - 1 - Open drain is enabled on UART1
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART1ODE field. */
#define SIM_RD_SOPT5_UART1ODE(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART1ODE_MASK) >> SIM_SOPT5_UART1ODE_SHIFT)
#define SIM_BRD_SOPT5_UART1ODE(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART1ODE_SHIFT, SIM_SOPT5_UART1ODE_WIDTH))

/*! @brief Set the UART1ODE field to a new value. */
#define SIM_WR_SOPT5_UART1ODE(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART1ODE_MASK, SIM_SOPT5_UART1ODE(value)))
#define SIM_BWR_SOPT5_UART1ODE(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_UART1ODE_SHIFT), SIM_SOPT5_UART1ODE_SHIFT, SIM_SOPT5_UART1ODE_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT7 - System Options Register 7
 ******************************************************************************/

/*!
 * @brief SIM_SOPT7 - System Options Register 7 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT7 register
 */
/*@{*/
#define SIM_RD_SOPT7(base)       (SIM_SOPT7_REG(base))
#define SIM_WR_SOPT7(base, value) (SIM_SOPT7_REG(base) = (value))
#define SIM_RMW_SOPT7(base, mask, value) (SIM_WR_SOPT7(base, (SIM_RD_SOPT7(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT7(base, value) (BME_OR32(&SIM_SOPT7_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT7(base, value) (BME_AND32(&SIM_SOPT7_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT7(base, value) (BME_XOR32(&SIM_SOPT7_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT7 bitfields
 */

/*!
 * @name Register SIM_SOPT7, field ADC0TRGSEL[3:0] (RW)
 *
 * Selects the ADC0 trigger source when alternative triggers are functional in
 * Stop and VLPS modes. .
 *
 * Values:
 * - 0000 - External trigger pin input (PDB0_EXTRG)
 * - 0001 - HSCMP0 output
 * - 0010 - HSCMP1 output
 * - 0011 - Reserved
 * - 0100 - DMA channel 0 transfer last write complete
 * - 0101 - DMA channel 1 transfer last write complete
 * - 0110 - DMA channel 2 transfer last write complete
 * - 0111 - DMA channel 3 transfer last write complete
 * - 1000 - FTM0 trigger
 * - 1001 - FTM1 trigger
 * - 1010 - FTM2 trigger
 * - 1011 - Reserved
 * - 1100 - Reserved
 * - 1101 - Reserved
 * - 1110 - LPTMR0 trigger
 * - 1011 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0TRGSEL field. */
#define SIM_RD_SOPT7_ADC0TRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0TRGSEL_MASK) >> SIM_SOPT7_ADC0TRGSEL_SHIFT)
#define SIM_BRD_SOPT7_ADC0TRGSEL(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0TRGSEL_SHIFT, SIM_SOPT7_ADC0TRGSEL_WIDTH))

/*! @brief Set the ADC0TRGSEL field to a new value. */
#define SIM_WR_SOPT7_ADC0TRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0TRGSEL_MASK, SIM_SOPT7_ADC0TRGSEL(value)))
#define SIM_BWR_SOPT7_ADC0TRGSEL(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_ADC0TRGSEL_SHIFT), SIM_SOPT7_ADC0TRGSEL_SHIFT, SIM_SOPT7_ADC0TRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0PRETRGSEL[4] (RW)
 *
 * Selects the ADC0 pre-trigger source when alternative triggers are enabled
 * through ADC0ALTTRGEN.
 *
 * Values:
 * - 0 - Pre-trigger A for ADC0. Clearing this field will result in ADHWTSA=1
 *     and ADHWTSB=0.
 * - 1 - Pre-trigger B for ADC0. Setting this bit will result in ADHWTSA=0 and
 *     ADHWTSB=1.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0PRETRGSEL field. */
#define SIM_RD_SOPT7_ADC0PRETRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0PRETRGSEL_MASK) >> SIM_SOPT7_ADC0PRETRGSEL_SHIFT)
#define SIM_BRD_SOPT7_ADC0PRETRGSEL(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0PRETRGSEL_SHIFT, SIM_SOPT7_ADC0PRETRGSEL_WIDTH))

/*! @brief Set the ADC0PRETRGSEL field to a new value. */
#define SIM_WR_SOPT7_ADC0PRETRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0PRETRGSEL_MASK, SIM_SOPT7_ADC0PRETRGSEL(value)))
#define SIM_BWR_SOPT7_ADC0PRETRGSEL(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_ADC0PRETRGSEL_SHIFT), SIM_SOPT7_ADC0PRETRGSEL_SHIFT, SIM_SOPT7_ADC0PRETRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0ALTTRGEN[7] (RW)
 *
 * Enable alternative conversion triggers for ADC0.
 *
 * Values:
 * - 0 - PDB trigger selected for ADC0
 * - 1 - Alternate trigger selected for ADC0 as defined by ADC0TRGSEL
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0ALTTRGEN field. */
#define SIM_RD_SOPT7_ADC0ALTTRGEN(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0ALTTRGEN_MASK) >> SIM_SOPT7_ADC0ALTTRGEN_SHIFT)
#define SIM_BRD_SOPT7_ADC0ALTTRGEN(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0ALTTRGEN_SHIFT, SIM_SOPT7_ADC0ALTTRGEN_WIDTH))

/*! @brief Set the ADC0ALTTRGEN field to a new value. */
#define SIM_WR_SOPT7_ADC0ALTTRGEN(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0ALTTRGEN_MASK, SIM_SOPT7_ADC0ALTTRGEN(value)))
#define SIM_BWR_SOPT7_ADC0ALTTRGEN(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_ADC0ALTTRGEN_SHIFT), SIM_SOPT7_ADC0ALTTRGEN_SHIFT, SIM_SOPT7_ADC0ALTTRGEN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC1TRGSEL[11:8] (RW)
 *
 * Selects the ADC1 trigger source when alternative triggers are functional in
 * Stop and VLPS modes.
 *
 * Values:
 * - 0000 - External trigger pin input (PDB0_EXTRG)
 * - 0001 - HSCMP0 output
 * - 0010 - HSCMP1 output
 * - 0011 - Reserved
 * - 0100 - DMA channel 0 transfer last write complete
 * - 0101 - DMA channel 1 transfer last write complete
 * - 0110 - DMA channel 2 transfer last write complete
 * - 0111 - DMA channel 3 transfer last write complete
 * - 1000 - FTM0 trigger
 * - 1001 - FTM1 trigger
 * - 1010 - FTM2 trigger
 * - 1011 - Reserved
 * - 1100 - Reserved
 * - 1101 - Reserved
 * - 1110 - LPTMR0 trigger
 * - 1011 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC1TRGSEL field. */
#define SIM_RD_SOPT7_ADC1TRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC1TRGSEL_MASK) >> SIM_SOPT7_ADC1TRGSEL_SHIFT)
#define SIM_BRD_SOPT7_ADC1TRGSEL(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC1TRGSEL_SHIFT, SIM_SOPT7_ADC1TRGSEL_WIDTH))

/*! @brief Set the ADC1TRGSEL field to a new value. */
#define SIM_WR_SOPT7_ADC1TRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC1TRGSEL_MASK, SIM_SOPT7_ADC1TRGSEL(value)))
#define SIM_BWR_SOPT7_ADC1TRGSEL(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_ADC1TRGSEL_SHIFT), SIM_SOPT7_ADC1TRGSEL_SHIFT, SIM_SOPT7_ADC1TRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC1PRETRGSEL[12] (RW)
 *
 * Selects the ADC1 pre-trigger source when alternative triggers are enabled
 * through ADC1ALTTRGEN.
 *
 * Values:
 * - 0 - Pre-trigger A for ADC1. Clearing this field will result in ADHWTSA=1
 *     and ADHWTSB=0.
 * - 1 - Pre-trigger B for ADC1. Setting this bit will result in ADHWTSA=0 and
 *     ADHWTSB=1.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC1PRETRGSEL field. */
#define SIM_RD_SOPT7_ADC1PRETRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC1PRETRGSEL_MASK) >> SIM_SOPT7_ADC1PRETRGSEL_SHIFT)
#define SIM_BRD_SOPT7_ADC1PRETRGSEL(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC1PRETRGSEL_SHIFT, SIM_SOPT7_ADC1PRETRGSEL_WIDTH))

/*! @brief Set the ADC1PRETRGSEL field to a new value. */
#define SIM_WR_SOPT7_ADC1PRETRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC1PRETRGSEL_MASK, SIM_SOPT7_ADC1PRETRGSEL(value)))
#define SIM_BWR_SOPT7_ADC1PRETRGSEL(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_ADC1PRETRGSEL_SHIFT), SIM_SOPT7_ADC1PRETRGSEL_SHIFT, SIM_SOPT7_ADC1PRETRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC1ALTTRGEN[15] (RW)
 *
 * Enable alternative conversion triggers for ADC1.
 *
 * Values:
 * - 0 - PDB trigger selected for ADC1
 * - 1 - Alternate trigger selected for ADC1 as defined by ADC1TRGSEL.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC1ALTTRGEN field. */
#define SIM_RD_SOPT7_ADC1ALTTRGEN(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC1ALTTRGEN_MASK) >> SIM_SOPT7_ADC1ALTTRGEN_SHIFT)
#define SIM_BRD_SOPT7_ADC1ALTTRGEN(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC1ALTTRGEN_SHIFT, SIM_SOPT7_ADC1ALTTRGEN_WIDTH))

/*! @brief Set the ADC1ALTTRGEN field to a new value. */
#define SIM_WR_SOPT7_ADC1ALTTRGEN(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC1ALTTRGEN_MASK, SIM_SOPT7_ADC1ALTTRGEN(value)))
#define SIM_BWR_SOPT7_ADC1ALTTRGEN(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_ADC1ALTTRGEN_SHIFT), SIM_SOPT7_ADC1ALTTRGEN_SHIFT, SIM_SOPT7_ADC1ALTTRGEN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0ALTCLKSRC[25:24] (RW)
 *
 * Selects the source for the ADC0 ALT clock.
 *
 * Values:
 * - 00 - OUTDIV5 output
 * - 01 - MCGIRCLK
 * - 10 - OSCERCLK
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0ALTCLKSRC field. */
#define SIM_RD_SOPT7_ADC0ALTCLKSRC(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0ALTCLKSRC_MASK) >> SIM_SOPT7_ADC0ALTCLKSRC_SHIFT)
#define SIM_BRD_SOPT7_ADC0ALTCLKSRC(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0ALTCLKSRC_SHIFT, SIM_SOPT7_ADC0ALTCLKSRC_WIDTH))

/*! @brief Set the ADC0ALTCLKSRC field to a new value. */
#define SIM_WR_SOPT7_ADC0ALTCLKSRC(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0ALTCLKSRC_MASK, SIM_SOPT7_ADC0ALTCLKSRC(value)))
#define SIM_BWR_SOPT7_ADC0ALTCLKSRC(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_ADC0ALTCLKSRC_SHIFT), SIM_SOPT7_ADC0ALTCLKSRC_SHIFT, SIM_SOPT7_ADC0ALTCLKSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC1ALTCLKSRC[27:26] (RW)
 *
 * Selects the source for the ADC1 ALT clock.
 *
 * Values:
 * - 00 - OUTDIV5 output
 * - 01 - MCGIRCLK
 * - 10 - OSCERCLK
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC1ALTCLKSRC field. */
#define SIM_RD_SOPT7_ADC1ALTCLKSRC(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC1ALTCLKSRC_MASK) >> SIM_SOPT7_ADC1ALTCLKSRC_SHIFT)
#define SIM_BRD_SOPT7_ADC1ALTCLKSRC(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC1ALTCLKSRC_SHIFT, SIM_SOPT7_ADC1ALTCLKSRC_WIDTH))

/*! @brief Set the ADC1ALTCLKSRC field to a new value. */
#define SIM_WR_SOPT7_ADC1ALTCLKSRC(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC1ALTCLKSRC_MASK, SIM_SOPT7_ADC1ALTCLKSRC(value)))
#define SIM_BWR_SOPT7_ADC1ALTCLKSRC(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_ADC1ALTCLKSRC_SHIFT), SIM_SOPT7_ADC1ALTCLKSRC_SHIFT, SIM_SOPT7_ADC1ALTCLKSRC_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT8 - System Options Register 8
 ******************************************************************************/

/*!
 * @brief SIM_SOPT8 - System Options Register 8 (RW)
 *
 * Reset value: 0x00000000U
 *
 * SOPT8[FTMxSYNCBIT] provides a mechanism to allow two or more FTMs to be
 * initialized at the same time. Each of the FTMs needs FTMx_SYNC[TRIG0] to be set
 * before software synchronization can occur. The user can perform a simultaneous
 * write of logic "1" to SOPT8[FTMxSYNCBIT], which sets FTMx_SYNC[TRIG0] input to
 * the corresponding FTM on the same bus clock cycle . The TRIGx inputs react to a
 * rising edge and the user must clear SOPT8[FTMxSYNCBIT] to allow other
 * hardware trigger inputs to force a synchronization/refresh event via FTMx_SYNC[TRIG0]
 * input.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT8 register
 */
/*@{*/
#define SIM_RD_SOPT8(base)       (SIM_SOPT8_REG(base))
#define SIM_WR_SOPT8(base, value) (SIM_SOPT8_REG(base) = (value))
#define SIM_RMW_SOPT8(base, mask, value) (SIM_WR_SOPT8(base, (SIM_RD_SOPT8(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT8(base, value) (BME_OR32(&SIM_SOPT8_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT8(base, value) (BME_AND32(&SIM_SOPT8_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT8(base, value) (BME_XOR32(&SIM_SOPT8_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT8 bitfields
 */

/*!
 * @name Register SIM_SOPT8, field FTM0SYNCBIT[0] (RW)
 *
 * Values:
 * - 0 - No effect to FTM0; this allow the hardware trigger options to function
 *     as expected. See SOPT4[FTM0TRG0SRC].
 * - 1 - If TRIG0 enabled, this refreshes the FTM0CNTIN and all buffered
 *     registers of the FTM0 (must write 0 first then write 1); this masks the hardware
 *     trigger.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0SYNCBIT field. */
#define SIM_RD_SOPT8_FTM0SYNCBIT(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0SYNCBIT_MASK) >> SIM_SOPT8_FTM0SYNCBIT_SHIFT)
#define SIM_BRD_SOPT8_FTM0SYNCBIT(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0SYNCBIT_SHIFT, SIM_SOPT8_FTM0SYNCBIT_WIDTH))

/*! @brief Set the FTM0SYNCBIT field to a new value. */
#define SIM_WR_SOPT8_FTM0SYNCBIT(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0SYNCBIT_MASK, SIM_SOPT8_FTM0SYNCBIT(value)))
#define SIM_BWR_SOPT8_FTM0SYNCBIT(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0SYNCBIT_SHIFT), SIM_SOPT8_FTM0SYNCBIT_SHIFT, SIM_SOPT8_FTM0SYNCBIT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM1SYNCBIT[1] (RW)
 *
 * Values:
 * - 0 - No effect to FTM1; this allows the hardware trigger options to function
 *     as expected. See SOPT4[FTM1TRG0SRC].
 * - 1 - If TRIG0 enabled, this refreshes the FTM1CNTIN and all buffered
 *     registers of the FTM1 (must write 0 first then write 1); this masks the hardware
 *     trigger.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM1SYNCBIT field. */
#define SIM_RD_SOPT8_FTM1SYNCBIT(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM1SYNCBIT_MASK) >> SIM_SOPT8_FTM1SYNCBIT_SHIFT)
#define SIM_BRD_SOPT8_FTM1SYNCBIT(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM1SYNCBIT_SHIFT, SIM_SOPT8_FTM1SYNCBIT_WIDTH))

/*! @brief Set the FTM1SYNCBIT field to a new value. */
#define SIM_WR_SOPT8_FTM1SYNCBIT(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM1SYNCBIT_MASK, SIM_SOPT8_FTM1SYNCBIT(value)))
#define SIM_BWR_SOPT8_FTM1SYNCBIT(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM1SYNCBIT_SHIFT), SIM_SOPT8_FTM1SYNCBIT_SHIFT, SIM_SOPT8_FTM1SYNCBIT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM2SYNCBIT[2] (RW)
 *
 * Values:
 * - 0 - No effect to FTM2; this allows the hardware trigger options to function
 *     as expected. See SOPT4[FTM2TRG0SRC].
 * - 1 - If TRIG0 is enabled, this refreshes the FTM2CNTIN and all buffered
 *     registers of the FTM2 (must write 0 first then write 1); this masks the
 *     hardware trigger.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM2SYNCBIT field. */
#define SIM_RD_SOPT8_FTM2SYNCBIT(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM2SYNCBIT_MASK) >> SIM_SOPT8_FTM2SYNCBIT_SHIFT)
#define SIM_BRD_SOPT8_FTM2SYNCBIT(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM2SYNCBIT_SHIFT, SIM_SOPT8_FTM2SYNCBIT_WIDTH))

/*! @brief Set the FTM2SYNCBIT field to a new value. */
#define SIM_WR_SOPT8_FTM2SYNCBIT(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM2SYNCBIT_MASK, SIM_SOPT8_FTM2SYNCBIT(value)))
#define SIM_BWR_SOPT8_FTM2SYNCBIT(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM2SYNCBIT_SHIFT), SIM_SOPT8_FTM2SYNCBIT_SHIFT, SIM_SOPT8_FTM2SYNCBIT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field CARRIER_SELECT[8] (RW)
 *
 * Values:
 * - 0 - FTM1_CH1 output provides the carrier signal for Timer Modulation mode
 * - 1 - LPTMR0 prescaler output provides the carrier signal for Timer
 *     Modulation mode
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_CARRIER_SELECT field. */
#define SIM_RD_SOPT8_CARRIER_SELECT(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_CARRIER_SELECT_MASK) >> SIM_SOPT8_CARRIER_SELECT_SHIFT)
#define SIM_BRD_SOPT8_CARRIER_SELECT(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_CARRIER_SELECT_SHIFT, SIM_SOPT8_CARRIER_SELECT_WIDTH))

/*! @brief Set the CARRIER_SELECT field to a new value. */
#define SIM_WR_SOPT8_CARRIER_SELECT(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_CARRIER_SELECT_MASK, SIM_SOPT8_CARRIER_SELECT(value)))
#define SIM_BWR_SOPT8_CARRIER_SELECT(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_CARRIER_SELECT_SHIFT), SIM_SOPT8_CARRIER_SELECT_SHIFT, SIM_SOPT8_CARRIER_SELECT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH0SRC[16] (RW)
 *
 * Selects the source for FTM0 channel 0 PWM/OCMP mode. When the FTM is not in
 * output PWM/OCMP mode, clear this field.
 *
 * Values:
 * - 0 - FTM0CH0 pin is the output of FTM0 channel 0 PWM/OCMP
 * - 1 - FTM0CH0 pin is the output of FTM0 channel 0 PWM/OCMP modulating the
 *     carrier frequency, as per CARRIER_SELECT
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH0SRC field. */
#define SIM_RD_SOPT8_FTM0OCH0SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH0SRC_MASK) >> SIM_SOPT8_FTM0OCH0SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH0SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH0SRC_SHIFT, SIM_SOPT8_FTM0OCH0SRC_WIDTH))

/*! @brief Set the FTM0OCH0SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH0SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH0SRC_MASK, SIM_SOPT8_FTM0OCH0SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH0SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH0SRC_SHIFT), SIM_SOPT8_FTM0OCH0SRC_SHIFT, SIM_SOPT8_FTM0OCH0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH1SRC[17] (RW)
 *
 * Selects the source for FTM0 channel 1 PWM/OCMP mode. When the FTM is not in
 * output PWM/OCMP mode, clear this field.
 *
 * Values:
 * - 0 - FTM0CH1 pin is the output of FTM0 channel 1 PWM/OCMP
 * - 1 - FTM0CH1 pin is the output of FTM0 channel 1 PWM/OCMP modulating the
 *     carrier frequency, as per CARRIER_SELECT
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH1SRC field. */
#define SIM_RD_SOPT8_FTM0OCH1SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH1SRC_MASK) >> SIM_SOPT8_FTM0OCH1SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH1SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH1SRC_SHIFT, SIM_SOPT8_FTM0OCH1SRC_WIDTH))

/*! @brief Set the FTM0OCH1SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH1SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH1SRC_MASK, SIM_SOPT8_FTM0OCH1SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH1SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH1SRC_SHIFT), SIM_SOPT8_FTM0OCH1SRC_SHIFT, SIM_SOPT8_FTM0OCH1SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH2SRC[18] (RW)
 *
 * Selects the source for FTM0 channel 2 PWM/OCMP mode. When the FTM is not in
 * output PWM/OCMP mode, clear this field.
 *
 * Values:
 * - 0 - FTM0CH2 pin is the output of FTM0 channel 2 PWM/OCMP
 * - 1 - FTM0CH2 pin is the output of FTM0 channel 2 PWM/OCMP modulating the
 *     carrier frequency, as per CARRIER_SELECT
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH2SRC field. */
#define SIM_RD_SOPT8_FTM0OCH2SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH2SRC_MASK) >> SIM_SOPT8_FTM0OCH2SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH2SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH2SRC_SHIFT, SIM_SOPT8_FTM0OCH2SRC_WIDTH))

/*! @brief Set the FTM0OCH2SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH2SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH2SRC_MASK, SIM_SOPT8_FTM0OCH2SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH2SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH2SRC_SHIFT), SIM_SOPT8_FTM0OCH2SRC_SHIFT, SIM_SOPT8_FTM0OCH2SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH3SRC[19] (RW)
 *
 * Selects the source for FTM0 channel 3 PWM/OCMP mode. When the FTM is not in
 * output PWM/OCMP mode, clear this field.
 *
 * Values:
 * - 0 - FTM0CH3 pin is the output of FTM0 channel 3 PWM/OCMP
 * - 1 - FTM0CH3 pin is the output of FTM0 channel 3 PWM/OCMP modulating the
 *     carrier frequency, as per CARRIER_SELECT
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH3SRC field. */
#define SIM_RD_SOPT8_FTM0OCH3SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH3SRC_MASK) >> SIM_SOPT8_FTM0OCH3SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH3SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH3SRC_SHIFT, SIM_SOPT8_FTM0OCH3SRC_WIDTH))

/*! @brief Set the FTM0OCH3SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH3SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH3SRC_MASK, SIM_SOPT8_FTM0OCH3SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH3SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH3SRC_SHIFT), SIM_SOPT8_FTM0OCH3SRC_SHIFT, SIM_SOPT8_FTM0OCH3SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH4SRC[20] (RW)
 *
 * Selects the source for FTM0 channel 4 PWM/OCMP mode. When the FTM is not in
 * output PWM/OCMP mode, clear this field.
 *
 * Values:
 * - 0 - FTM0CH4 pin is the output of FTM0 channel 4 PWM/OCMP
 * - 1 - FTM0CH4 pin is the output of FTM0 channel 4 PWM/OCMP modulating the
 *     carrier frequency, as per CARRIER_SELECT
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH4SRC field. */
#define SIM_RD_SOPT8_FTM0OCH4SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH4SRC_MASK) >> SIM_SOPT8_FTM0OCH4SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH4SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH4SRC_SHIFT, SIM_SOPT8_FTM0OCH4SRC_WIDTH))

/*! @brief Set the FTM0OCH4SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH4SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH4SRC_MASK, SIM_SOPT8_FTM0OCH4SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH4SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH4SRC_SHIFT), SIM_SOPT8_FTM0OCH4SRC_SHIFT, SIM_SOPT8_FTM0OCH4SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH5SRC[21] (RW)
 *
 * Selects the source for FTM0 channel 5 PWM/OCMP mode. When the FTM is not in
 * output PWM/OCMP mode, clear this field.
 *
 * Values:
 * - 0 - FTM0CH5 pin is the output of FTM0 channel 5 PWM/OCMP
 * - 1 - FTM0CH5 pin is the output of FTM0 channel 5 PWM/OCMP modulating the
 *     carrier frequency, as per CARRIER_SELECT
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH5SRC field. */
#define SIM_RD_SOPT8_FTM0OCH5SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH5SRC_MASK) >> SIM_SOPT8_FTM0OCH5SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH5SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH5SRC_SHIFT, SIM_SOPT8_FTM0OCH5SRC_WIDTH))

/*! @brief Set the FTM0OCH5SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH5SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH5SRC_MASK, SIM_SOPT8_FTM0OCH5SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH5SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH5SRC_SHIFT), SIM_SOPT8_FTM0OCH5SRC_SHIFT, SIM_SOPT8_FTM0OCH5SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM2OCH0SRC[22] (RW)
 *
 * Selects the source for FTM2 channel 0 PWM/OCMP mode. When the FTM is not in
 * output PWM/OCMP mode, clear this field.
 *
 * Values:
 * - 0 - FTM2CH0 pin is the output of FTM2 channel 0 PWM/OCMP
 * - 1 - FTM2CH0 pin is the output of FTM2 channel 0 PWM/OCMP modulating the
 *     carrier frequency, as per CARRIER_SELECT
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM2OCH0SRC field. */
#define SIM_RD_SOPT8_FTM2OCH0SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM2OCH0SRC_MASK) >> SIM_SOPT8_FTM2OCH0SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM2OCH0SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM2OCH0SRC_SHIFT, SIM_SOPT8_FTM2OCH0SRC_WIDTH))

/*! @brief Set the FTM2OCH0SRC field to a new value. */
#define SIM_WR_SOPT8_FTM2OCH0SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM2OCH0SRC_MASK, SIM_SOPT8_FTM2OCH0SRC(value)))
#define SIM_BWR_SOPT8_FTM2OCH0SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM2OCH0SRC_SHIFT), SIM_SOPT8_FTM2OCH0SRC_SHIFT, SIM_SOPT8_FTM2OCH0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM2OCH1SRC[23] (RW)
 *
 * Selects the source for FTM2 channel 1 PWM/OCMP mode. When the FTM is not in
 * output PWM/OCMP mode, clear this field.
 *
 * Values:
 * - 0 - FTM2CH1 pin is the output of FTM2 channel 1 PWM/OCMP
 * - 1 - FTM2CH1 pin is the output of FTM2 channel 1 PWM/OCMP modulating the
 *     carrier frequency, as per CARRIER_SELECT
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM2OCH1SRC field. */
#define SIM_RD_SOPT8_FTM2OCH1SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM2OCH1SRC_MASK) >> SIM_SOPT8_FTM2OCH1SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM2OCH1SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM2OCH1SRC_SHIFT, SIM_SOPT8_FTM2OCH1SRC_WIDTH))

/*! @brief Set the FTM2OCH1SRC field to a new value. */
#define SIM_WR_SOPT8_FTM2OCH1SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM2OCH1SRC_MASK, SIM_SOPT8_FTM2OCH1SRC(value)))
#define SIM_BWR_SOPT8_FTM2OCH1SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM2OCH1SRC_SHIFT), SIM_SOPT8_FTM2OCH1SRC_SHIFT, SIM_SOPT8_FTM2OCH1SRC_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SDID - System Device Identification Register
 ******************************************************************************/

/*!
 * @brief SIM_SDID - System Device Identification Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SDID register
 */
/*@{*/
#define SIM_RD_SDID(base)        (SIM_SDID_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_SDID bitfields
 */

/*!
 * @name Register SIM_SDID, field PINID[3:0] (RO)
 *
 * Specifies the pincount of the device.
 *
 * Values:
 * - 0000 - Reserved
 * - 0001 - Reserved
 * - 0010 - 32-pin
 * - 0011 - 44-pin
 * - 0100 - 48-pin
 * - 0101 - Reserved
 * - 0110 - Reserved
 * - 0111 - Reserved
 * - 1000 - Reserved
 * - 1001 - Reserved
 * - 1010 - Reserved
 * - 1011 - Reserved
 * - 1100 - Reserved
 * - 1101 - Reserved
 * - 1110 - Reserved
 * - 1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_PINID field. */
#define SIM_RD_SDID_PINID(base) ((SIM_SDID_REG(base) & SIM_SDID_PINID_MASK) >> SIM_SDID_PINID_SHIFT)
#define SIM_BRD_SDID_PINID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_PINID_SHIFT, SIM_SDID_PINID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field DIEID[11:7] (RO)
 *
 * Specifies the silicon implementation number for the device. This field always
 * reads as 00001.
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_DIEID field. */
#define SIM_RD_SDID_DIEID(base) ((SIM_SDID_REG(base) & SIM_SDID_DIEID_MASK) >> SIM_SDID_DIEID_SHIFT)
#define SIM_BRD_SDID_DIEID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_DIEID_SHIFT, SIM_SDID_DIEID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field REVID[15:12] (RO)
 *
 * Specifies the silicon implementation number for the device.
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_REVID field. */
#define SIM_RD_SDID_REVID(base) ((SIM_SDID_REG(base) & SIM_SDID_REVID_MASK) >> SIM_SDID_REVID_SHIFT)
#define SIM_BRD_SDID_REVID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_REVID_SHIFT, SIM_SDID_REVID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SRAMSIZE[19:16] (RO)
 *
 * Specifies the size of the System SRAM.
 *
 * Values:
 * - 0000 - Reserved
 * - 0001 - Reserved
 * - 0010 - Reserved
 * - 0011 - 4 KB
 * - 0100 - 8 KB
 * - 0101 - Reserved
 * - 0110 - Reserved
 * - 0111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SRAMSIZE field. */
#define SIM_RD_SDID_SRAMSIZE(base) ((SIM_SDID_REG(base) & SIM_SDID_SRAMSIZE_MASK) >> SIM_SDID_SRAMSIZE_SHIFT)
#define SIM_BRD_SDID_SRAMSIZE(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SRAMSIZE_SHIFT, SIM_SDID_SRAMSIZE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SERIERID[23:20] (RO)
 *
 * Values:
 * - 0110 - V-family - Motor control
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SERIERID field. */
#define SIM_RD_SDID_SERIERID(base) ((SIM_SDID_REG(base) & SIM_SDID_SERIERID_MASK) >> SIM_SDID_SERIERID_SHIFT)
#define SIM_BRD_SDID_SERIERID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SERIERID_SHIFT, SIM_SDID_SERIERID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SUBFAMID[27:24] (RO)
 *
 * Specifies the V sub-family of the device.
 *
 * Values:
 * - 0000 - MKV10xxxx
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SUBFAMID field. */
#define SIM_RD_SDID_SUBFAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_SUBFAMID_MASK) >> SIM_SDID_SUBFAMID_SHIFT)
#define SIM_BRD_SDID_SUBFAMID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SUBFAMID_SHIFT, SIM_SDID_SUBFAMID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field FAMID[31:28] (RO)
 *
 * Specifies the V-family of the device.
 *
 * Values:
 * - 0001 - MKV10Zx
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_FAMID field. */
#define SIM_RD_SDID_FAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_FAMID_MASK) >> SIM_SDID_FAMID_SHIFT)
#define SIM_BRD_SDID_FAMID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_FAMID_SHIFT, SIM_SDID_FAMID_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC4 - System Clock Gating Control Register 4
 ******************************************************************************/

/*!
 * @brief SIM_SCGC4 - System Clock Gating Control Register 4 (RW)
 *
 * Reset value: 0xF0000030U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC4 register
 */
/*@{*/
#define SIM_RD_SCGC4(base)       (SIM_SCGC4_REG(base))
#define SIM_WR_SCGC4(base, value) (SIM_SCGC4_REG(base) = (value))
#define SIM_RMW_SCGC4(base, mask, value) (SIM_WR_SCGC4(base, (SIM_RD_SCGC4(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC4(base, value) (BME_OR32(&SIM_SCGC4_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC4(base, value) (BME_AND32(&SIM_SCGC4_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC4(base, value) (BME_XOR32(&SIM_SCGC4_REG(base), (uint32_t)(value)))
/*@}*/

/* Unified clock gate bit access macros */
#define SIM_SCGC_BIT_REG(base, index)        (*((volatile uint32_t *)&SIM_SCGC4_REG(base) + (((uint32_t)(index) >> 5) - 3U)))
#define SIM_SCGC_BIT_SHIFT(index)            ((uint32_t)(index) & ((1U << 5) - 1U))
#define SIM_RD_SCGC_BIT(base, index)         (SIM_SCGC_BIT_REG((base), (index)) & (1U << SIM_SCGC_BIT_SHIFT(index)))
#define SIM_BRD_SCGC_BIT(base, index)        (BME_UBFX32(&SIM_SCGC_BIT_REG((base), (index)), SIM_SCGC_BIT_SHIFT(index), 1))
#define SIM_WR_SCGC_BIT(base, index, value)  (SIM_SCGC_BIT_REG((base), (index)) = (SIM_SCGC_BIT_REG((base), (index)) & ~(1U << SIM_SCGC_BIT_SHIFT(index))) | ((uint32_t)(value) << SIM_SCGC_BIT_SHIFT(index)))
#define SIM_BWR_SCGC_BIT(base, index, value) (BME_BFI32(&SIM_SCGC_BIT_REG((base), (index)), ((uint32_t)(value) << SIM_SCGC_BIT_SHIFT(index)), SIM_SCGC_BIT_SHIFT(index), 1))

/*
 * Constants & macros for individual SIM_SCGC4 bitfields
 */

/*!
 * @name Register SIM_SCGC4, field EWM[1] (RW)
 *
 * This bit controls the clock gate to the EWM module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_EWM field. */
#define SIM_RD_SCGC4_EWM(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_EWM_MASK) >> SIM_SCGC4_EWM_SHIFT)
#define SIM_BRD_SCGC4_EWM(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_EWM_SHIFT, SIM_SCGC4_EWM_WIDTH))

/*! @brief Set the EWM field to a new value. */
#define SIM_WR_SCGC4_EWM(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_EWM_MASK, SIM_SCGC4_EWM(value)))
#define SIM_BWR_SCGC4_EWM(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_EWM_SHIFT), SIM_SCGC4_EWM_SHIFT, SIM_SCGC4_EWM_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field I2C0[6] (RW)
 *
 * This bit controls the clock gate to the I2C0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_I2C0 field. */
#define SIM_RD_SCGC4_I2C0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_I2C0_MASK) >> SIM_SCGC4_I2C0_SHIFT)
#define SIM_BRD_SCGC4_I2C0(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_I2C0_SHIFT, SIM_SCGC4_I2C0_WIDTH))

/*! @brief Set the I2C0 field to a new value. */
#define SIM_WR_SCGC4_I2C0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_I2C0_MASK, SIM_SCGC4_I2C0(value)))
#define SIM_BWR_SCGC4_I2C0(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_I2C0_SHIFT), SIM_SCGC4_I2C0_SHIFT, SIM_SCGC4_I2C0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART0[10] (RW)
 *
 * This bit controls the clock gate to the UART0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART0 field. */
#define SIM_RD_SCGC4_UART0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART0_MASK) >> SIM_SCGC4_UART0_SHIFT)
#define SIM_BRD_SCGC4_UART0(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART0_SHIFT, SIM_SCGC4_UART0_WIDTH))

/*! @brief Set the UART0 field to a new value. */
#define SIM_WR_SCGC4_UART0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART0_MASK, SIM_SCGC4_UART0(value)))
#define SIM_BWR_SCGC4_UART0(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_UART0_SHIFT), SIM_SCGC4_UART0_SHIFT, SIM_SCGC4_UART0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART1[11] (RW)
 *
 * This bit controls the clock gate to the UART1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART1 field. */
#define SIM_RD_SCGC4_UART1(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART1_MASK) >> SIM_SCGC4_UART1_SHIFT)
#define SIM_BRD_SCGC4_UART1(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART1_SHIFT, SIM_SCGC4_UART1_WIDTH))

/*! @brief Set the UART1 field to a new value. */
#define SIM_WR_SCGC4_UART1(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART1_MASK, SIM_SCGC4_UART1(value)))
#define SIM_BWR_SCGC4_UART1(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_UART1_SHIFT), SIM_SCGC4_UART1_SHIFT, SIM_SCGC4_UART1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field CMP[19] (RW)
 *
 * Controls the clock gate to both the comparator modules (CMP0 and CMP1).
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_CMP field. */
#define SIM_RD_SCGC4_CMP(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_CMP_MASK) >> SIM_SCGC4_CMP_SHIFT)
#define SIM_BRD_SCGC4_CMP(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_CMP_SHIFT, SIM_SCGC4_CMP_WIDTH))

/*! @brief Set the CMP field to a new value. */
#define SIM_WR_SCGC4_CMP(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_CMP_MASK, SIM_SCGC4_CMP(value)))
#define SIM_BWR_SCGC4_CMP(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_CMP_SHIFT), SIM_SCGC4_CMP_SHIFT, SIM_SCGC4_CMP_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC5 - System Clock Gating Control Register 5
 ******************************************************************************/

/*!
 * @brief SIM_SCGC5 - System Clock Gating Control Register 5 (RW)
 *
 * Reset value: 0x00040180U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC5 register
 */
/*@{*/
#define SIM_RD_SCGC5(base)       (SIM_SCGC5_REG(base))
#define SIM_WR_SCGC5(base, value) (SIM_SCGC5_REG(base) = (value))
#define SIM_RMW_SCGC5(base, mask, value) (SIM_WR_SCGC5(base, (SIM_RD_SCGC5(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC5(base, value) (BME_OR32(&SIM_SCGC5_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC5(base, value) (BME_AND32(&SIM_SCGC5_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC5(base, value) (BME_XOR32(&SIM_SCGC5_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC5 bitfields
 */

/*!
 * @name Register SIM_SCGC5, field LPTMR[0] (RW)
 *
 * Controls the clock software access to the Low Power Timer module.
 *
 * Values:
 * - 0 - Access disabled
 * - 1 - Access enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_LPTMR field. */
#define SIM_RD_SCGC5_LPTMR(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_LPTMR_MASK) >> SIM_SCGC5_LPTMR_SHIFT)
#define SIM_BRD_SCGC5_LPTMR(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_LPTMR_SHIFT, SIM_SCGC5_LPTMR_WIDTH))

/*! @brief Set the LPTMR field to a new value. */
#define SIM_WR_SCGC5_LPTMR(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_LPTMR_MASK, SIM_SCGC5_LPTMR(value)))
#define SIM_BWR_SCGC5_LPTMR(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_LPTMR_SHIFT), SIM_SCGC5_LPTMR_SHIFT, SIM_SCGC5_LPTMR_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTA[9] (RW)
 *
 * Controls the clock gate to the Port A module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTA field. */
#define SIM_RD_SCGC5_PORTA(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTA_MASK) >> SIM_SCGC5_PORTA_SHIFT)
#define SIM_BRD_SCGC5_PORTA(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTA_SHIFT, SIM_SCGC5_PORTA_WIDTH))

/*! @brief Set the PORTA field to a new value. */
#define SIM_WR_SCGC5_PORTA(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTA_MASK, SIM_SCGC5_PORTA(value)))
#define SIM_BWR_SCGC5_PORTA(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTA_SHIFT), SIM_SCGC5_PORTA_SHIFT, SIM_SCGC5_PORTA_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTB[10] (RW)
 *
 * Controls the clock gate to the Port B module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTB field. */
#define SIM_RD_SCGC5_PORTB(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTB_MASK) >> SIM_SCGC5_PORTB_SHIFT)
#define SIM_BRD_SCGC5_PORTB(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTB_SHIFT, SIM_SCGC5_PORTB_WIDTH))

/*! @brief Set the PORTB field to a new value. */
#define SIM_WR_SCGC5_PORTB(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTB_MASK, SIM_SCGC5_PORTB(value)))
#define SIM_BWR_SCGC5_PORTB(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTB_SHIFT), SIM_SCGC5_PORTB_SHIFT, SIM_SCGC5_PORTB_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTC[11] (RW)
 *
 * Controls the clock gate to the Port C module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTC field. */
#define SIM_RD_SCGC5_PORTC(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTC_MASK) >> SIM_SCGC5_PORTC_SHIFT)
#define SIM_BRD_SCGC5_PORTC(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTC_SHIFT, SIM_SCGC5_PORTC_WIDTH))

/*! @brief Set the PORTC field to a new value. */
#define SIM_WR_SCGC5_PORTC(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTC_MASK, SIM_SCGC5_PORTC(value)))
#define SIM_BWR_SCGC5_PORTC(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTC_SHIFT), SIM_SCGC5_PORTC_SHIFT, SIM_SCGC5_PORTC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTD[12] (RW)
 *
 * Controls the clock gate to the Port D module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTD field. */
#define SIM_RD_SCGC5_PORTD(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTD_MASK) >> SIM_SCGC5_PORTD_SHIFT)
#define SIM_BRD_SCGC5_PORTD(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTD_SHIFT, SIM_SCGC5_PORTD_WIDTH))

/*! @brief Set the PORTD field to a new value. */
#define SIM_WR_SCGC5_PORTD(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTD_MASK, SIM_SCGC5_PORTD(value)))
#define SIM_BWR_SCGC5_PORTD(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTD_SHIFT), SIM_SCGC5_PORTD_SHIFT, SIM_SCGC5_PORTD_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTE[13] (RW)
 *
 * Controls the clock gate to the Port E module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTE field. */
#define SIM_RD_SCGC5_PORTE(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTE_MASK) >> SIM_SCGC5_PORTE_SHIFT)
#define SIM_BRD_SCGC5_PORTE(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTE_SHIFT, SIM_SCGC5_PORTE_WIDTH))

/*! @brief Set the PORTE field to a new value. */
#define SIM_WR_SCGC5_PORTE(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTE_MASK, SIM_SCGC5_PORTE(value)))
#define SIM_BWR_SCGC5_PORTE(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTE_SHIFT), SIM_SCGC5_PORTE_SHIFT, SIM_SCGC5_PORTE_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC6 - System Clock Gating Control Register 6
 ******************************************************************************/

/*!
 * @brief SIM_SCGC6 - System Clock Gating Control Register 6 (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC6 register
 */
/*@{*/
#define SIM_RD_SCGC6(base)       (SIM_SCGC6_REG(base))
#define SIM_WR_SCGC6(base, value) (SIM_SCGC6_REG(base) = (value))
#define SIM_RMW_SCGC6(base, mask, value) (SIM_WR_SCGC6(base, (SIM_RD_SCGC6(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC6(base, value) (BME_OR32(&SIM_SCGC6_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC6(base, value) (BME_AND32(&SIM_SCGC6_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC6(base, value) (BME_XOR32(&SIM_SCGC6_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC6 bitfields
 */

/*!
 * @name Register SIM_SCGC6, field FTF[0] (RW)
 *
 * Controls the clock gate to the flash memory. Flash reads are still supported
 * while the flash memory is clock gated, but entry into low power modes is
 * blocked.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTF field. */
#define SIM_RD_SCGC6_FTF(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTF_MASK) >> SIM_SCGC6_FTF_SHIFT)
#define SIM_BRD_SCGC6_FTF(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTF_SHIFT, SIM_SCGC6_FTF_WIDTH))

/*! @brief Set the FTF field to a new value. */
#define SIM_WR_SCGC6_FTF(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTF_MASK, SIM_SCGC6_FTF(value)))
#define SIM_BWR_SCGC6_FTF(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FTF_SHIFT), SIM_SCGC6_FTF_SHIFT, SIM_SCGC6_FTF_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DMAMUX[1] (RW)
 *
 * Controls the clock gate to the DMA Mux module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_DMAMUX field. */
#define SIM_RD_SCGC6_DMAMUX(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_DMAMUX_MASK) >> SIM_SCGC6_DMAMUX_SHIFT)
#define SIM_BRD_SCGC6_DMAMUX(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_DMAMUX_SHIFT, SIM_SCGC6_DMAMUX_WIDTH))

/*! @brief Set the DMAMUX field to a new value. */
#define SIM_WR_SCGC6_DMAMUX(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_DMAMUX_MASK, SIM_SCGC6_DMAMUX(value)))
#define SIM_BWR_SCGC6_DMAMUX(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_DMAMUX_SHIFT), SIM_SCGC6_DMAMUX_SHIFT, SIM_SCGC6_DMAMUX_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field SPI0[12] (RW)
 *
 * Controls the clock gate to the SPI0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_SPI0 field. */
#define SIM_RD_SCGC6_SPI0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_SPI0_MASK) >> SIM_SCGC6_SPI0_SHIFT)
#define SIM_BRD_SCGC6_SPI0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_SPI0_SHIFT, SIM_SCGC6_SPI0_WIDTH))

/*! @brief Set the SPI0 field to a new value. */
#define SIM_WR_SCGC6_SPI0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_SPI0_MASK, SIM_SCGC6_SPI0(value)))
#define SIM_BWR_SCGC6_SPI0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_SPI0_SHIFT), SIM_SCGC6_SPI0_SHIFT, SIM_SCGC6_SPI0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field CRC[18] (RW)
 *
 * Controls the clock gate to the CRC module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_CRC field. */
#define SIM_RD_SCGC6_CRC(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_CRC_MASK) >> SIM_SCGC6_CRC_SHIFT)
#define SIM_BRD_SCGC6_CRC(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_CRC_SHIFT, SIM_SCGC6_CRC_WIDTH))

/*! @brief Set the CRC field to a new value. */
#define SIM_WR_SCGC6_CRC(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_CRC_MASK, SIM_SCGC6_CRC(value)))
#define SIM_BWR_SCGC6_CRC(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_CRC_SHIFT), SIM_SCGC6_CRC_SHIFT, SIM_SCGC6_CRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PDB[22] (RW)
 *
 * Controls the clock gate to the PDB module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PDB field. */
#define SIM_RD_SCGC6_PDB(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PDB_MASK) >> SIM_SCGC6_PDB_SHIFT)
#define SIM_BRD_SCGC6_PDB(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_PDB_SHIFT, SIM_SCGC6_PDB_WIDTH))

/*! @brief Set the PDB field to a new value. */
#define SIM_WR_SCGC6_PDB(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PDB_MASK, SIM_SCGC6_PDB(value)))
#define SIM_BWR_SCGC6_PDB(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_PDB_SHIFT), SIM_SCGC6_PDB_SHIFT, SIM_SCGC6_PDB_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FTM0[24] (RW)
 *
 * Controls the clock gate to the FTM0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTM0 field. */
#define SIM_RD_SCGC6_FTM0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTM0_MASK) >> SIM_SCGC6_FTM0_SHIFT)
#define SIM_BRD_SCGC6_FTM0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTM0_SHIFT, SIM_SCGC6_FTM0_WIDTH))

/*! @brief Set the FTM0 field to a new value. */
#define SIM_WR_SCGC6_FTM0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTM0_MASK, SIM_SCGC6_FTM0(value)))
#define SIM_BWR_SCGC6_FTM0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FTM0_SHIFT), SIM_SCGC6_FTM0_SHIFT, SIM_SCGC6_FTM0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FTM1[25] (RW)
 *
 * Controls the clock gate to the FTM1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTM1 field. */
#define SIM_RD_SCGC6_FTM1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTM1_MASK) >> SIM_SCGC6_FTM1_SHIFT)
#define SIM_BRD_SCGC6_FTM1(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTM1_SHIFT, SIM_SCGC6_FTM1_WIDTH))

/*! @brief Set the FTM1 field to a new value. */
#define SIM_WR_SCGC6_FTM1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTM1_MASK, SIM_SCGC6_FTM1(value)))
#define SIM_BWR_SCGC6_FTM1(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FTM1_SHIFT), SIM_SCGC6_FTM1_SHIFT, SIM_SCGC6_FTM1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FTM2[26] (RW)
 *
 * Controls the clock gate to the FTM2 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTM2 field. */
#define SIM_RD_SCGC6_FTM2(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTM2_MASK) >> SIM_SCGC6_FTM2_SHIFT)
#define SIM_BRD_SCGC6_FTM2(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTM2_SHIFT, SIM_SCGC6_FTM2_WIDTH))

/*! @brief Set the FTM2 field to a new value. */
#define SIM_WR_SCGC6_FTM2(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTM2_MASK, SIM_SCGC6_FTM2(value)))
#define SIM_BWR_SCGC6_FTM2(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FTM2_SHIFT), SIM_SCGC6_FTM2_SHIFT, SIM_SCGC6_FTM2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field ADC0[27] (RW)
 *
 * Controls the clock gate to the ADC0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_ADC0 field. */
#define SIM_RD_SCGC6_ADC0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_ADC0_MASK) >> SIM_SCGC6_ADC0_SHIFT)
#define SIM_BRD_SCGC6_ADC0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_ADC0_SHIFT, SIM_SCGC6_ADC0_WIDTH))

/*! @brief Set the ADC0 field to a new value. */
#define SIM_WR_SCGC6_ADC0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_ADC0_MASK, SIM_SCGC6_ADC0(value)))
#define SIM_BWR_SCGC6_ADC0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_ADC0_SHIFT), SIM_SCGC6_ADC0_SHIFT, SIM_SCGC6_ADC0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field ADC1[28] (RW)
 *
 * Controls the clock gate to the ADC1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_ADC1 field. */
#define SIM_RD_SCGC6_ADC1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_ADC1_MASK) >> SIM_SCGC6_ADC1_SHIFT)
#define SIM_BRD_SCGC6_ADC1(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_ADC1_SHIFT, SIM_SCGC6_ADC1_WIDTH))

/*! @brief Set the ADC1 field to a new value. */
#define SIM_WR_SCGC6_ADC1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_ADC1_MASK, SIM_SCGC6_ADC1(value)))
#define SIM_BWR_SCGC6_ADC1(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_ADC1_SHIFT), SIM_SCGC6_ADC1_SHIFT, SIM_SCGC6_ADC1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DAC0[31] (RW)
 *
 * Controls the clock gate to the DAC0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_DAC0 field. */
#define SIM_RD_SCGC6_DAC0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_DAC0_MASK) >> SIM_SCGC6_DAC0_SHIFT)
#define SIM_BRD_SCGC6_DAC0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_DAC0_SHIFT, SIM_SCGC6_DAC0_WIDTH))

/*! @brief Set the DAC0 field to a new value. */
#define SIM_WR_SCGC6_DAC0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_DAC0_MASK, SIM_SCGC6_DAC0(value)))
#define SIM_BWR_SCGC6_DAC0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_DAC0_SHIFT), SIM_SCGC6_DAC0_SHIFT, SIM_SCGC6_DAC0_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC7 - System Clock Gating Control Register 7
 ******************************************************************************/

/*!
 * @brief SIM_SCGC7 - System Clock Gating Control Register 7 (RW)
 *
 * Reset value: 0x00000100U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC7 register
 */
/*@{*/
#define SIM_RD_SCGC7(base)       (SIM_SCGC7_REG(base))
#define SIM_WR_SCGC7(base, value) (SIM_SCGC7_REG(base) = (value))
#define SIM_RMW_SCGC7(base, mask, value) (SIM_WR_SCGC7(base, (SIM_RD_SCGC7(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC7(base, value) (BME_OR32(&SIM_SCGC7_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC7(base, value) (BME_AND32(&SIM_SCGC7_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC7(base, value) (BME_XOR32(&SIM_SCGC7_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC7 bitfields
 */

/*!
 * @name Register SIM_SCGC7, field DMA[8] (RW)
 *
 * Controls the clock gate to the DMA module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC7_DMA field. */
#define SIM_RD_SCGC7_DMA(base) ((SIM_SCGC7_REG(base) & SIM_SCGC7_DMA_MASK) >> SIM_SCGC7_DMA_SHIFT)
#define SIM_BRD_SCGC7_DMA(base) (BME_UBFX32(&SIM_SCGC7_REG(base), SIM_SCGC7_DMA_SHIFT, SIM_SCGC7_DMA_WIDTH))

/*! @brief Set the DMA field to a new value. */
#define SIM_WR_SCGC7_DMA(base, value) (SIM_RMW_SCGC7(base, SIM_SCGC7_DMA_MASK, SIM_SCGC7_DMA(value)))
#define SIM_BWR_SCGC7_DMA(base, value) (BME_BFI32(&SIM_SCGC7_REG(base), ((uint32_t)(value) << SIM_SCGC7_DMA_SHIFT), SIM_SCGC7_DMA_SHIFT, SIM_SCGC7_DMA_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_CLKDIV1 - System Clock Divider Register 1
 ******************************************************************************/

/*!
 * @brief SIM_CLKDIV1 - System Clock Divider Register 1 (RW)
 *
 * Reset value: 0x00011000U
 *
 * The CLKDIV1 register cannot be written to when the device is in VLPR mode.
 */
/*!
 * @name Constants and macros for entire SIM_CLKDIV1 register
 */
/*@{*/
#define SIM_RD_CLKDIV1(base)     (SIM_CLKDIV1_REG(base))
#define SIM_WR_CLKDIV1(base, value) (SIM_CLKDIV1_REG(base) = (value))
#define SIM_RMW_CLKDIV1(base, mask, value) (SIM_WR_CLKDIV1(base, (SIM_RD_CLKDIV1(base) & ~(mask)) | (value)))
#define SIM_SET_CLKDIV1(base, value) (BME_OR32(&SIM_CLKDIV1_REG(base), (uint32_t)(value)))
#define SIM_CLR_CLKDIV1(base, value) (BME_AND32(&SIM_CLKDIV1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_CLKDIV1(base, value) (BME_XOR32(&SIM_CLKDIV1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV1 bitfields
 */

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV5[14:12] (RW)
 *
 * Sets the divide value for the alternative ADC clock and is in addition to the
 * System clock divide ratio. At the end of reset, it is loaded with 001 (divide
 * by two).
 *
 * Values:
 * - 000 - Divide-by-1
 * - 001 - Divide-by-2
 * - 010 - Divide-by-3
 * - 011 - Divide-by-4
 * - 100 - Divide-by-5
 * - 101 - Divide-by-6
 * - 110 - Divide-by-7
 * - 111 - Divide-by-8
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV5 field. */
#define SIM_RD_CLKDIV1_OUTDIV5(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV5_MASK) >> SIM_CLKDIV1_OUTDIV5_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV5(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_OUTDIV5_SHIFT, SIM_CLKDIV1_OUTDIV5_WIDTH))

/*! @brief Set the OUTDIV5 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV5(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV5_MASK, SIM_CLKDIV1_OUTDIV5(value)))
#define SIM_BWR_CLKDIV1_OUTDIV5(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_OUTDIV5_SHIFT), SIM_CLKDIV1_OUTDIV5_SHIFT, SIM_CLKDIV1_OUTDIV5_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV5EN[15] (RW)
 *
 * This bit controls the OUTDIV5 divider.
 *
 * Values:
 * - 0 - OUTDIV5 disabled
 * - 1 - OUTDIV5 enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV5EN field. */
#define SIM_RD_CLKDIV1_OUTDIV5EN(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV5EN_MASK) >> SIM_CLKDIV1_OUTDIV5EN_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV5EN(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_OUTDIV5EN_SHIFT, SIM_CLKDIV1_OUTDIV5EN_WIDTH))

/*! @brief Set the OUTDIV5EN field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV5EN(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV5EN_MASK, SIM_CLKDIV1_OUTDIV5EN(value)))
#define SIM_BWR_CLKDIV1_OUTDIV5EN(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_OUTDIV5EN_SHIFT), SIM_CLKDIV1_OUTDIV5EN_SHIFT, SIM_CLKDIV1_OUTDIV5EN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV4[18:16] (RW)
 *
 * This field sets the divide value for the bus and flash clock and is in
 * addition to the System clock divide ratio. At the end of reset, it is loaded with
 * 001 (divide by two).
 *
 * Values:
 * - 000 - Divide-by-1.
 * - 001 - Divide-by-2.
 * - 010 - Divide-by-3.
 * - 011 - Divide-by-4.
 * - 100 - Divide-by-5.
 * - 101 - Divide-by-6.
 * - 110 - Divide-by-7.
 * - 111 - Divide-by-8.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV4 field. */
#define SIM_RD_CLKDIV1_OUTDIV4(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV4(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_OUTDIV4_SHIFT, SIM_CLKDIV1_OUTDIV4_WIDTH))

/*! @brief Set the OUTDIV4 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV4(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV4_MASK, SIM_CLKDIV1_OUTDIV4(value)))
#define SIM_BWR_CLKDIV1_OUTDIV4(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_OUTDIV4_SHIFT), SIM_CLKDIV1_OUTDIV4_SHIFT, SIM_CLKDIV1_OUTDIV4_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV1[31:28] (RW)
 *
 * This field sets the divide value for the core/system clock. At the end of
 * reset, it is loaded with 0000 (divide by one), 0001 (divide by two), 0011 (divide
 * by four), or 0111 (divide by eight) depending on the setting of the two
 * FTF_FOPT[LPBOOT] configuration bits.
 *
 * Values:
 * - 0000 - Divide-by-1.
 * - 0001 - Divide-by-2.
 * - 0010 - Divide-by-3.
 * - 0011 - Divide-by-4.
 * - 0100 - Divide-by-5.
 * - 0101 - Divide-by-6.
 * - 0110 - Divide-by-7.
 * - 0111 - Divide-by-8.
 * - 1000 - Divide-by-9.
 * - 1001 - Divide-by-10.
 * - 1010 - Divide-by-11.
 * - 1011 - Divide-by-12.
 * - 1100 - Divide-by-13.
 * - 1101 - Divide-by-14.
 * - 1110 - Divide-by-15.
 * - 1111 - Divide-by-16.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV1 field. */
#define SIM_RD_CLKDIV1_OUTDIV1(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV1(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_OUTDIV1_SHIFT, SIM_CLKDIV1_OUTDIV1_WIDTH))

/*! @brief Set the OUTDIV1 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV1(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV1_MASK, SIM_CLKDIV1_OUTDIV1(value)))
#define SIM_BWR_CLKDIV1_OUTDIV1(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_OUTDIV1_SHIFT), SIM_CLKDIV1_OUTDIV1_SHIFT, SIM_CLKDIV1_OUTDIV1_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_FCFG1 - Flash Configuration Register 1
 ******************************************************************************/

/*!
 * @brief SIM_FCFG1 - Flash Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The EESIZE and DEPART filelds are not applicable.
 */
/*!
 * @name Constants and macros for entire SIM_FCFG1 register
 */
/*@{*/
#define SIM_RD_FCFG1(base)       (SIM_FCFG1_REG(base))
#define SIM_WR_FCFG1(base, value) (SIM_FCFG1_REG(base) = (value))
#define SIM_RMW_FCFG1(base, mask, value) (SIM_WR_FCFG1(base, (SIM_RD_FCFG1(base) & ~(mask)) | (value)))
#define SIM_SET_FCFG1(base, value) (BME_OR32(&SIM_FCFG1_REG(base), (uint32_t)(value)))
#define SIM_CLR_FCFG1(base, value) (BME_AND32(&SIM_FCFG1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_FCFG1(base, value) (BME_XOR32(&SIM_FCFG1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG1 bitfields
 */

/*!
 * @name Register SIM_FCFG1, field FLASHDIS[0] (RW)
 *
 * Flash accesses are disabled (and generate a bus error) and the Flash memory
 * is placed in a low power state. This field should not be changed during VLP
 * modes. Relocate the interrupt vectors out of Flash memory before disabling the
 * Flash.
 *
 * Values:
 * - 0 - Flash is enabled
 * - 1 - Flash is disabled
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDIS field. */
#define SIM_RD_FCFG1_FLASHDIS(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDIS_MASK) >> SIM_FCFG1_FLASHDIS_SHIFT)
#define SIM_BRD_FCFG1_FLASHDIS(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDIS_SHIFT, SIM_FCFG1_FLASHDIS_WIDTH))

/*! @brief Set the FLASHDIS field to a new value. */
#define SIM_WR_FCFG1_FLASHDIS(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDIS_MASK, SIM_FCFG1_FLASHDIS(value)))
#define SIM_BWR_FCFG1_FLASHDIS(base, value) (BME_BFI32(&SIM_FCFG1_REG(base), ((uint32_t)(value) << SIM_FCFG1_FLASHDIS_SHIFT), SIM_FCFG1_FLASHDIS_SHIFT, SIM_FCFG1_FLASHDIS_WIDTH))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field FLASHDOZE[1] (RW)
 *
 * When set, Flash memory is disabled for the duration of Doze mode. An attempt
 * by the DMA or other bus master to access the Flash when the Flash is disabled
 * will result in a bus error. This field should be clear during VLP modes. The
 * Flash will be automatically enabled again at the end of Doze mode so interrupt
 * vectors do not need to be relocated out of Flash memory. The wakeup time from
 * Doze mode is extended when this field is set.
 *
 * Values:
 * - 0 - Flash remains enabled during Doze mode
 * - 1 - Flash is disabled for the duration of Doze mode
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDOZE field. */
#define SIM_RD_FCFG1_FLASHDOZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDOZE_MASK) >> SIM_FCFG1_FLASHDOZE_SHIFT)
#define SIM_BRD_FCFG1_FLASHDOZE(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDOZE_SHIFT, SIM_FCFG1_FLASHDOZE_WIDTH))

/*! @brief Set the FLASHDOZE field to a new value. */
#define SIM_WR_FCFG1_FLASHDOZE(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDOZE_MASK, SIM_FCFG1_FLASHDOZE(value)))
#define SIM_BWR_FCFG1_FLASHDOZE(base, value) (BME_BFI32(&SIM_FCFG1_REG(base), ((uint32_t)(value) << SIM_FCFG1_FLASHDOZE_SHIFT), SIM_FCFG1_FLASHDOZE_SHIFT, SIM_FCFG1_FLASHDOZE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field PFSIZE[27:24] (RO)
 *
 * This field specifies the amount of program flash memory available on the
 * device.
 *
 * Values:
 * - 0000 - 8 KB of program flash memory, 0.25 KB protection region
 * - 0001 - 16 KB of program flash memory, 0.5 KB protection region
 * - 0011 - 32 KB of program flash memory, 1 KB protection region
 * - 0101 - 64 KB of program flash memory, 2 KB protection region
 * - 0111 - 128 KB of program flash memory, 4 KB protection region
 * - 1001 - 256 KB of program flash memory, 4 KB protection region
 * - 1111 - 32 KB of program flash memory, 1 KB protection region
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_PFSIZE field. */
#define SIM_RD_FCFG1_PFSIZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT)
#define SIM_BRD_FCFG1_PFSIZE(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_PFSIZE_SHIFT, SIM_FCFG1_PFSIZE_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_FCFG2 - Flash Configuration Register 2
 ******************************************************************************/

/*!
 * @brief SIM_FCFG2 - Flash Configuration Register 2 (RO)
 *
 * Reset value: 0x00800000U
 */
/*!
 * @name Constants and macros for entire SIM_FCFG2 register
 */
/*@{*/
#define SIM_RD_FCFG2(base)       (SIM_FCFG2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG2 bitfields
 */

/*!
 * @name Register SIM_FCFG2, field MAXADDR[30:24] (RO)
 *
 * This field concatenated with 13 leading zeros indicates the first invalid
 * address of program flash. For example, if MAXADDR = 0x20, the first invalid
 * address of flash block 0 is 0x0004_0000. This would be the MAXADDR value for a
 * device with 256 KB program flash.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_MAXADDR field. */
#define SIM_RD_FCFG2_MAXADDR(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_MAXADDR_MASK) >> SIM_FCFG2_MAXADDR_SHIFT)
#define SIM_BRD_FCFG2_MAXADDR(base) (BME_UBFX32(&SIM_FCFG2_REG(base), SIM_FCFG2_MAXADDR_SHIFT, SIM_FCFG2_MAXADDR_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_UIDMH - Unique Identification Register Mid-High
 ******************************************************************************/

/*!
 * @brief SIM_UIDMH - Unique Identification Register Mid-High (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDMH register
 */
/*@{*/
#define SIM_RD_UIDMH(base)       (SIM_UIDMH_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_UIDMH bitfields
 */

/*!
 * @name Register SIM_UIDMH, field UID[15:0] (RO)
 *
 * Unique identification for the device.
 */
/*@{*/
/*! @brief Read current value of the SIM_UIDMH_UID field. */
#define SIM_RD_UIDMH_UID(base) ((SIM_UIDMH_REG(base) & SIM_UIDMH_UID_MASK) >> SIM_UIDMH_UID_SHIFT)
#define SIM_BRD_UIDMH_UID(base) (BME_UBFX32(&SIM_UIDMH_REG(base), SIM_UIDMH_UID_SHIFT, SIM_UIDMH_UID_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_UIDML - Unique Identification Register Mid Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDML - Unique Identification Register Mid Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDML register
 */
/*@{*/
#define SIM_RD_UIDML(base)       (SIM_UIDML_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDL - Unique Identification Register Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDL - Unique Identification Register Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDL register
 */
/*@{*/
#define SIM_RD_UIDL(base)        (SIM_UIDL_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_WDOGCTRL - WDOG Control Register
 ******************************************************************************/

/*!
 * @brief SIM_WDOGCTRL - WDOG Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_WDOGCTRL register
 */
/*@{*/
#define SIM_RD_WDOGCTRL(base)    (SIM_WDOGCTRL_REG(base))
#define SIM_WR_WDOGCTRL(base, value) (SIM_WDOGCTRL_REG(base) = (value))
#define SIM_RMW_WDOGCTRL(base, mask, value) (SIM_WR_WDOGCTRL(base, (SIM_RD_WDOGCTRL(base) & ~(mask)) | (value)))
#define SIM_SET_WDOGCTRL(base, value) (BME_OR32(&SIM_WDOGCTRL_REG(base), (uint32_t)(value)))
#define SIM_CLR_WDOGCTRL(base, value) (BME_AND32(&SIM_WDOGCTRL_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_WDOGCTRL(base, value) (BME_XOR32(&SIM_WDOGCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_WDOGCTRL bitfields
 */

/*!
 * @name Register SIM_WDOGCTRL, field WDOGCLKS[1] (RW)
 *
 * Selects the default clock source of the WDOG watchdog. On reset it will be
 * the 1kHZ LPO. The software can change this to the MCGIRCLK, which can be 32KHz
 * or 4Mhz, depending on the MCG configuration.
 *
 * Values:
 * - 0 - Internal 1 kHz clock is source to WDOG
 * - 1 - MCGIRCLK is source to WDOG
 */
/*@{*/
/*! @brief Read current value of the SIM_WDOGCTRL_WDOGCLKS field. */
#define SIM_RD_WDOGCTRL_WDOGCLKS(base) ((SIM_WDOGCTRL_REG(base) & SIM_WDOGCTRL_WDOGCLKS_MASK) >> SIM_WDOGCTRL_WDOGCLKS_SHIFT)
#define SIM_BRD_WDOGCTRL_WDOGCLKS(base) (BME_UBFX32(&SIM_WDOGCTRL_REG(base), SIM_WDOGCTRL_WDOGCLKS_SHIFT, SIM_WDOGCTRL_WDOGCLKS_WIDTH))

/*! @brief Set the WDOGCLKS field to a new value. */
#define SIM_WR_WDOGCTRL_WDOGCLKS(base, value) (SIM_RMW_WDOGCTRL(base, SIM_WDOGCTRL_WDOGCLKS_MASK, SIM_WDOGCTRL_WDOGCLKS(value)))
#define SIM_BWR_WDOGCTRL_WDOGCLKS(base, value) (BME_BFI32(&SIM_WDOGCTRL_REG(base), ((uint32_t)(value) << SIM_WDOGCTRL_WDOGCLKS_SHIFT), SIM_WDOGCTRL_WDOGCLKS_SHIFT, SIM_WDOGCTRL_WDOGCLKS_WIDTH))
/*@}*/

/*
 * MKV10Z7 SMC
 *
 * System Mode Controller
 *
 * Registers defined in this header file:
 * - SMC_PMPROT - Power Mode Protection register
 * - SMC_PMCTRL - Power Mode Control register
 * - SMC_STOPCTRL - Stop Control Register
 * - SMC_PMSTAT - Power Mode Status register
 */

#define SMC_INSTANCE_COUNT (1U) /*!< Number of instances of the SMC module. */
#define SMC_IDX (0U) /*!< Instance number for SMC. */

/*******************************************************************************
 * SMC_PMPROT - Power Mode Protection register
 ******************************************************************************/

/*!
 * @brief SMC_PMPROT - Power Mode Protection register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides protection for entry into any low-power run or stop
 * mode. The enabling of the low-power run or stop mode occurs by configuring the
 * Power Mode Control register (PMCTRL). The PMPROT register can be written only
 * once after any system reset. If the MCU is configured for a disallowed or
 * reserved power mode, the MCU remains in its current power mode. For example, if the
 * MCU is in normal RUN mode and AVLP is 0, an attempt to enter VLPR mode using
 * PMCTRL[RUNM] is blocked and PMCTRL[RUNM] remains 00b, indicating the MCU is
 * still in Normal Run mode. This register is reset on Chip Reset not VLLS and by
 * reset types that trigger Chip Reset not VLLS. It is unaffected by reset types
 * that do not trigger Chip Reset not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMPROT register
 */
/*@{*/
#define SMC_RD_PMPROT(base)      (SMC_PMPROT_REG(base))
#define SMC_WR_PMPROT(base, value) (SMC_PMPROT_REG(base) = (value))
#define SMC_RMW_PMPROT(base, mask, value) (SMC_WR_PMPROT(base, (SMC_RD_PMPROT(base) & ~(mask)) | (value)))
#define SMC_SET_PMPROT(base, value) (BME_OR8(&SMC_PMPROT_REG(base), (uint8_t)(value)))
#define SMC_CLR_PMPROT(base, value) (BME_AND8(&SMC_PMPROT_REG(base), (uint8_t)(~(value))))
#define SMC_TOG_PMPROT(base, value) (BME_XOR8(&SMC_PMPROT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMPROT bitfields
 */

/*!
 * @name Register SMC_PMPROT, field AVLLS[1] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write once
 * bit allows the MCU to enter any very-low-leakage stop mode (VLLSx).
 *
 * Values:
 * - 0 - Any VLLSx mode is not allowed
 * - 1 - Any VLLSx mode is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLLS field. */
#define SMC_RD_PMPROT_AVLLS(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLLS_MASK) >> SMC_PMPROT_AVLLS_SHIFT)
#define SMC_BRD_PMPROT_AVLLS(base) (BME_UBFX8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLLS_SHIFT, SMC_PMPROT_AVLLS_WIDTH))

/*! @brief Set the AVLLS field to a new value. */
#define SMC_WR_PMPROT_AVLLS(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLLS_MASK, SMC_PMPROT_AVLLS(value)))
#define SMC_BWR_PMPROT_AVLLS(base, value) (BME_BFI8(&SMC_PMPROT_REG(base), ((uint8_t)(value) << SMC_PMPROT_AVLLS_SHIFT), SMC_PMPROT_AVLLS_SHIFT, SMC_PMPROT_AVLLS_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AVLP[5] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any very-low-power mode (VLPR, VLPW, and VLPS).
 *
 * Values:
 * - 0 - VLPR, VLPW, and VLPS are not allowed.
 * - 1 - VLPR, VLPW, and VLPS are allowed.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLP field. */
#define SMC_RD_PMPROT_AVLP(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLP_MASK) >> SMC_PMPROT_AVLP_SHIFT)
#define SMC_BRD_PMPROT_AVLP(base) (BME_UBFX8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLP_SHIFT, SMC_PMPROT_AVLP_WIDTH))

/*! @brief Set the AVLP field to a new value. */
#define SMC_WR_PMPROT_AVLP(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLP_MASK, SMC_PMPROT_AVLP(value)))
#define SMC_BWR_PMPROT_AVLP(base, value) (BME_BFI8(&SMC_PMPROT_REG(base), ((uint8_t)(value) << SMC_PMPROT_AVLP_SHIFT), SMC_PMPROT_AVLP_SHIFT, SMC_PMPROT_AVLP_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_PMCTRL - Power Mode Control register
 ******************************************************************************/

/*!
 * @brief SMC_PMCTRL - Power Mode Control register (RW)
 *
 * Reset value: 0x00U
 *
 * The PMCTRL register controls entry into low-power Run and Stop modes,
 * provided that the selected power mode is allowed via an appropriate setting of the
 * protection (PMPROT) register. This register is reset on Chip POR not VLLS and by
 * reset types that trigger Chip POR not VLLS. It is unaffected by reset types
 * that do not trigger Chip POR not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMCTRL register
 */
/*@{*/
#define SMC_RD_PMCTRL(base)      (SMC_PMCTRL_REG(base))
#define SMC_WR_PMCTRL(base, value) (SMC_PMCTRL_REG(base) = (value))
#define SMC_RMW_PMCTRL(base, mask, value) (SMC_WR_PMCTRL(base, (SMC_RD_PMCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_PMCTRL(base, value) (BME_OR8(&SMC_PMCTRL_REG(base), (uint8_t)(value)))
#define SMC_CLR_PMCTRL(base, value) (BME_AND8(&SMC_PMCTRL_REG(base), (uint8_t)(~(value))))
#define SMC_TOG_PMCTRL(base, value) (BME_XOR8(&SMC_PMCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMCTRL bitfields
 */

/*!
 * @name Register SMC_PMCTRL, field STOPM[2:0] (RW)
 *
 * When written, controls entry into the selected stop mode when Sleep-Now or
 * Sleep-On-Exit mode is entered with SLEEPDEEP=1 . Writes to this field are
 * blocked if the protection level has not been enabled using the PMPROT register.
 * After any system reset, this field is cleared by hardware on any successful write
 * to the PMPROT register. When set to VLLSx, the VLLSM field in the STOPCTRL
 * register is used to further select the particular VLLS submode which will be
 * entered. When set to STOP, the PSTOPO bits in the STOPCTRL register can be used to
 * select a Partial Stop mode if desired.
 *
 * Values:
 * - 000 - Normal Stop (STOP)
 * - 001 - Reserved
 * - 010 - Very-Low-Power Stop (VLPS)
 * - 011 - Reserved
 * - 100 - Very-Low-Leakage Stop (VLLSx)
 * - 101 - Reserved
 * - 110 - Reseved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPM field. */
#define SMC_RD_PMCTRL_STOPM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPM_MASK) >> SMC_PMCTRL_STOPM_SHIFT)
#define SMC_BRD_PMCTRL_STOPM(base) (BME_UBFX8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPM_SHIFT, SMC_PMCTRL_STOPM_WIDTH))

/*! @brief Set the STOPM field to a new value. */
#define SMC_WR_PMCTRL_STOPM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_STOPM_MASK, SMC_PMCTRL_STOPM(value)))
#define SMC_BWR_PMCTRL_STOPM(base, value) (BME_BFI8(&SMC_PMCTRL_REG(base), ((uint8_t)(value) << SMC_PMCTRL_STOPM_SHIFT), SMC_PMCTRL_STOPM_SHIFT, SMC_PMCTRL_STOPM_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field STOPA[3] (RO)
 *
 * When set, this read-only status bit indicates an interrupt or reset occured
 * during the previous stop mode entry sequence, preventing the system from
 * entering that mode. This field is cleared by hardware at the beginning of any stop
 * mode entry sequence and is set if the sequence was aborted.
 *
 * Values:
 * - 0 - The previous stop mode entry was successsful.
 * - 1 - The previous stop mode entry was aborted.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPA field. */
#define SMC_RD_PMCTRL_STOPA(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPA_MASK) >> SMC_PMCTRL_STOPA_SHIFT)
#define SMC_BRD_PMCTRL_STOPA(base) (BME_UBFX8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPA_SHIFT, SMC_PMCTRL_STOPA_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field RUNM[6:5] (RW)
 *
 * When written, causes entry into the selected run mode. Writes to this field
 * are blocked if the protection level has not been enabled using the PMPROT
 * register. RUNM may be set to VLPR only when PMSTAT=RUN. After being written to
 * VLPR, RUNM should not be written back to RUN until PMSTAT=VLPR.
 *
 * Values:
 * - 00 - Normal Run mode (RUN)
 * - 01 - Reserved
 * - 10 - Very-Low-Power Run mode (VLPR)
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_RUNM field. */
#define SMC_RD_PMCTRL_RUNM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_RUNM_MASK) >> SMC_PMCTRL_RUNM_SHIFT)
#define SMC_BRD_PMCTRL_RUNM(base) (BME_UBFX8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_RUNM_SHIFT, SMC_PMCTRL_RUNM_WIDTH))

/*! @brief Set the RUNM field to a new value. */
#define SMC_WR_PMCTRL_RUNM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_RUNM_MASK, SMC_PMCTRL_RUNM(value)))
#define SMC_BWR_PMCTRL_RUNM(base, value) (BME_BFI8(&SMC_PMCTRL_REG(base), ((uint8_t)(value) << SMC_PMCTRL_RUNM_SHIFT), SMC_PMCTRL_RUNM_SHIFT, SMC_PMCTRL_RUNM_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_STOPCTRL - Stop Control Register
 ******************************************************************************/

/*!
 * @brief SMC_STOPCTRL - Stop Control Register (RW)
 *
 * Reset value: 0x03U
 *
 * The STOPCTRL register provides various control bits allowing the user to fine
 * tune power consumption during the stop mode selected by the STOPM field. This
 * register is reset on Chip POR not VLLS and by reset types that trigger Chip
 * POR not VLLS. It is unaffected by reset types that do not trigger Chip POR not
 * VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_STOPCTRL register
 */
/*@{*/
#define SMC_RD_STOPCTRL(base)    (SMC_STOPCTRL_REG(base))
#define SMC_WR_STOPCTRL(base, value) (SMC_STOPCTRL_REG(base) = (value))
#define SMC_RMW_STOPCTRL(base, mask, value) (SMC_WR_STOPCTRL(base, (SMC_RD_STOPCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_STOPCTRL(base, value) (BME_OR8(&SMC_STOPCTRL_REG(base), (uint8_t)(value)))
#define SMC_CLR_STOPCTRL(base, value) (BME_AND8(&SMC_STOPCTRL_REG(base), (uint8_t)(~(value))))
#define SMC_TOG_STOPCTRL(base, value) (BME_XOR8(&SMC_STOPCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_STOPCTRL bitfields
 */

/*!
 * @name Register SMC_STOPCTRL, field VLLSM[2:0] (RW)
 *
 * This field controls which VLLS sub-mode to enter if STOPM = VLLSx.
 *
 * Values:
 * - 000 - VLLS0
 * - 001 - VLLS1
 * - 010 - Reserved
 * - 011 - VLLS3
 * - 100 - Reserved
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_VLLSM field. */
#define SMC_RD_STOPCTRL_VLLSM(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_VLLSM_MASK) >> SMC_STOPCTRL_VLLSM_SHIFT)
#define SMC_BRD_STOPCTRL_VLLSM(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_VLLSM_SHIFT, SMC_STOPCTRL_VLLSM_WIDTH))

/*! @brief Set the VLLSM field to a new value. */
#define SMC_WR_STOPCTRL_VLLSM(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_VLLSM_MASK, SMC_STOPCTRL_VLLSM(value)))
#define SMC_BWR_STOPCTRL_VLLSM(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_VLLSM_SHIFT), SMC_STOPCTRL_VLLSM_SHIFT, SMC_STOPCTRL_VLLSM_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field LPOPO[3] (RW)
 *
 * Controls whether the 1 kHz LPO clock is enabled in VLLSx modes. During VLLS0
 * mode, the LPO clock is disabled by hardware and this bit has no effect.
 *
 * Values:
 * - 0 - LPO clock is enabled in VLLSx
 * - 1 - LPO clock is disabled in VLLSx
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_LPOPO field. */
#define SMC_RD_STOPCTRL_LPOPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_LPOPO_MASK) >> SMC_STOPCTRL_LPOPO_SHIFT)
#define SMC_BRD_STOPCTRL_LPOPO(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_LPOPO_SHIFT, SMC_STOPCTRL_LPOPO_WIDTH))

/*! @brief Set the LPOPO field to a new value. */
#define SMC_WR_STOPCTRL_LPOPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_LPOPO_MASK, SMC_STOPCTRL_LPOPO(value)))
#define SMC_BWR_STOPCTRL_LPOPO(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_LPOPO_SHIFT), SMC_STOPCTRL_LPOPO_SHIFT, SMC_STOPCTRL_LPOPO_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PORPO[5] (RW)
 *
 * This bit controls whether the POR detect circuit is enabled in VLLS0 mode.
 *
 * Values:
 * - 0 - POR detect circuit is enabled in VLLS0
 * - 1 - POR detect circuit is disabled in VLLS0
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PORPO field. */
#define SMC_RD_STOPCTRL_PORPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PORPO_MASK) >> SMC_STOPCTRL_PORPO_SHIFT)
#define SMC_BRD_STOPCTRL_PORPO(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_PORPO_SHIFT, SMC_STOPCTRL_PORPO_WIDTH))

/*! @brief Set the PORPO field to a new value. */
#define SMC_WR_STOPCTRL_PORPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PORPO_MASK, SMC_STOPCTRL_PORPO(value)))
#define SMC_BWR_STOPCTRL_PORPO(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_PORPO_SHIFT), SMC_STOPCTRL_PORPO_SHIFT, SMC_STOPCTRL_PORPO_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PSTOPO[7:6] (RW)
 *
 * These bits control whether a Partial Stop mode is entered when STOPM=STOP.
 * When entering a Partial Stop mode from RUN mode, the PMC, MCG and flash remain
 * fully powered, allowing the device to wakeup almost instantaneously at the
 * expense of higher power consumption. In PSTOP2, only system clocks are gated
 * allowing peripherals running on bus clock to remain fully functional. In PSTOP1,
 * both system and bus clocks are gated.
 *
 * Values:
 * - 00 - STOP - Normal Stop mode
 * - 01 - PSTOP1 - Partial Stop with both system and bus clocks disabled
 * - 10 - PSTOP2 - Partial Stop with system clock disabled and bus clock enabled
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PSTOPO field. */
#define SMC_RD_STOPCTRL_PSTOPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PSTOPO_MASK) >> SMC_STOPCTRL_PSTOPO_SHIFT)
#define SMC_BRD_STOPCTRL_PSTOPO(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_PSTOPO_SHIFT, SMC_STOPCTRL_PSTOPO_WIDTH))

/*! @brief Set the PSTOPO field to a new value. */
#define SMC_WR_STOPCTRL_PSTOPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PSTOPO_MASK, SMC_STOPCTRL_PSTOPO(value)))
#define SMC_BWR_STOPCTRL_PSTOPO(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_PSTOPO_SHIFT), SMC_STOPCTRL_PSTOPO_SHIFT, SMC_STOPCTRL_PSTOPO_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_PMSTAT - Power Mode Status register
 ******************************************************************************/

/*!
 * @brief SMC_PMSTAT - Power Mode Status register (RO)
 *
 * Reset value: 0x01U
 *
 * PMSTAT is a read-only, one-hot register which indicates the current power
 * mode of the system. This register is reset on Chip POR not VLLS and by reset
 * types that trigger Chip POR not VLLS. It is unaffected by reset types that do not
 * trigger Chip POR not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_PMSTAT register
 */
/*@{*/
#define SMC_RD_PMSTAT(base)      (SMC_PMSTAT_REG(base))
/*@}*/

/*
 * MKV10Z7 SPI
 *
 * Serial Peripheral Interface
 *
 * Registers defined in this header file:
 * - SPI_MCR - Module Configuration Register
 * - SPI_TCR - Transfer Count Register
 * - SPI_CTAR - Clock and Transfer Attributes Register (In Master Mode)
 * - SPI_CTAR_SLAVE - Clock and Transfer Attributes Register (In Slave Mode)
 * - SPI_SR - Status Register
 * - SPI_RSER - DMA/Interrupt Request Select and Enable Register
 * - SPI_PUSHR - PUSH TX FIFO Register In Master Mode
 * - SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode
 * - SPI_POPR - POP RX FIFO Register
 * - SPI_TXFR0 - Transmit FIFO Registers
 * - SPI_TXFR1 - Transmit FIFO Registers
 * - SPI_TXFR2 - Transmit FIFO Registers
 * - SPI_TXFR3 - Transmit FIFO Registers
 * - SPI_RXFR0 - Receive FIFO Registers
 * - SPI_RXFR1 - Receive FIFO Registers
 * - SPI_RXFR2 - Receive FIFO Registers
 * - SPI_RXFR3 - Receive FIFO Registers
 * - SPI_SREX - Status Register Extended
 */

#define SPI_INSTANCE_COUNT (1U) /*!< Number of instances of the SPI module. */
#define SPI0_IDX (0U) /*!< Instance number for SPI0. */

/*******************************************************************************
 * SPI_MCR - Module Configuration Register
 ******************************************************************************/

/*!
 * @brief SPI_MCR - Module Configuration Register (RW)
 *
 * Reset value: 0x00004001U
 *
 * Contains bits to configure various attributes associated with the module
 * operations. The HALT and MDIS bits can be changed at any time, but the effect
 * takes place only on the next frame boundary. Only the HALT and MDIS bits in the
 * MCR can be changed, while the module is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_MCR register
 */
/*@{*/
#define SPI_RD_MCR(base)         (SPI_MCR_REG(base))
#define SPI_WR_MCR(base, value)  (SPI_MCR_REG(base) = (value))
#define SPI_RMW_MCR(base, mask, value) (SPI_WR_MCR(base, (SPI_RD_MCR(base) & ~(mask)) | (value)))
#define SPI_SET_MCR(base, value) (BME_OR32(&SPI_MCR_REG(base), (uint32_t)(value)))
#define SPI_CLR_MCR(base, value) (BME_AND32(&SPI_MCR_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_MCR(base, value) (BME_XOR32(&SPI_MCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_MCR bitfields
 */

/*!
 * @name Register SPI_MCR, field HALT[0] (RW)
 *
 * The HALT bit starts and stops frame transfers. See Start and Stop of Module
 * transfers
 *
 * Values:
 * - 0 - Start transfers.
 * - 1 - Stop transfers.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_HALT field. */
#define SPI_RD_MCR_HALT(base) ((SPI_MCR_REG(base) & SPI_MCR_HALT_MASK) >> SPI_MCR_HALT_SHIFT)
#define SPI_BRD_MCR_HALT(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_HALT_SHIFT, SPI_MCR_HALT_WIDTH))

/*! @brief Set the HALT field to a new value. */
#define SPI_WR_MCR_HALT(base, value) (SPI_RMW_MCR(base, SPI_MCR_HALT_MASK, SPI_MCR_HALT(value)))
#define SPI_BWR_MCR_HALT(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_HALT_SHIFT), SPI_MCR_HALT_SHIFT, SPI_MCR_HALT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field SMPL_PT[9:8] (RW)
 *
 * Controls when the module master samples SIN in Modified Transfer Format. This
 * field is valid only when CPHA bit in CTARn[CPHA] is 0.
 *
 * Values:
 * - 00 - 0 protocol clock cycles between SCK edge and SIN sample
 * - 01 - 1 protocol clock cycle between SCK edge and SIN sample
 * - 10 - 2 protocol clock cycles between SCK edge and SIN sample
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_SMPL_PT field. */
#define SPI_RD_MCR_SMPL_PT(base) ((SPI_MCR_REG(base) & SPI_MCR_SMPL_PT_MASK) >> SPI_MCR_SMPL_PT_SHIFT)
#define SPI_BRD_MCR_SMPL_PT(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_SMPL_PT_SHIFT, SPI_MCR_SMPL_PT_WIDTH))

/*! @brief Set the SMPL_PT field to a new value. */
#define SPI_WR_MCR_SMPL_PT(base, value) (SPI_RMW_MCR(base, SPI_MCR_SMPL_PT_MASK, SPI_MCR_SMPL_PT(value)))
#define SPI_BWR_MCR_SMPL_PT(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_SMPL_PT_SHIFT), SPI_MCR_SMPL_PT_SHIFT, SPI_MCR_SMPL_PT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field CLR_RXF[10] (WORZ)
 *
 * Flushes the RX FIFO. Writing a 1 to CLR_RXF clears the RX Counter. The
 * CLR_RXF bit is always read as zero.
 *
 * Values:
 * - 0 - Do not clear the RX FIFO counter.
 * - 1 - Clear the RX FIFO counter.
 */
/*@{*/
/*! @brief Set the CLR_RXF field to a new value. */
#define SPI_WR_MCR_CLR_RXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_CLR_RXF_MASK, SPI_MCR_CLR_RXF(value)))
#define SPI_BWR_MCR_CLR_RXF(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_CLR_RXF_SHIFT), SPI_MCR_CLR_RXF_SHIFT, SPI_MCR_CLR_RXF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field CLR_TXF[11] (WORZ)
 *
 * Flushes the TX FIFO. Writing a 1 to CLR_TXF clears the TX FIFO Counter. The
 * CLR_TXF bit is always read as zero.
 *
 * Values:
 * - 0 - Do not clear the TX FIFO counter.
 * - 1 - Clear the TX FIFO counter.
 */
/*@{*/
/*! @brief Set the CLR_TXF field to a new value. */
#define SPI_WR_MCR_CLR_TXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_CLR_TXF_MASK, SPI_MCR_CLR_TXF(value)))
#define SPI_BWR_MCR_CLR_TXF(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_CLR_TXF_SHIFT), SPI_MCR_CLR_TXF_SHIFT, SPI_MCR_CLR_TXF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field DIS_RXF[12] (RW)
 *
 * When the RX FIFO is disabled, the receive part of the module operates as a
 * simplified double-buffered SPI. This bit can only be written when the MDIS bit
 * is cleared.
 *
 * Values:
 * - 0 - RX FIFO is enabled.
 * - 1 - RX FIFO is disabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DIS_RXF field. */
#define SPI_RD_MCR_DIS_RXF(base) ((SPI_MCR_REG(base) & SPI_MCR_DIS_RXF_MASK) >> SPI_MCR_DIS_RXF_SHIFT)
#define SPI_BRD_MCR_DIS_RXF(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_DIS_RXF_SHIFT, SPI_MCR_DIS_RXF_WIDTH))

/*! @brief Set the DIS_RXF field to a new value. */
#define SPI_WR_MCR_DIS_RXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_DIS_RXF_MASK, SPI_MCR_DIS_RXF(value)))
#define SPI_BWR_MCR_DIS_RXF(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_DIS_RXF_SHIFT), SPI_MCR_DIS_RXF_SHIFT, SPI_MCR_DIS_RXF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field DIS_TXF[13] (RW)
 *
 * When the TX FIFO is disabled, the transmit part of the module operates as a
 * simplified double-buffered SPI. This bit can be written only when the MDIS bit
 * is cleared.
 *
 * Values:
 * - 0 - TX FIFO is enabled.
 * - 1 - TX FIFO is disabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DIS_TXF field. */
#define SPI_RD_MCR_DIS_TXF(base) ((SPI_MCR_REG(base) & SPI_MCR_DIS_TXF_MASK) >> SPI_MCR_DIS_TXF_SHIFT)
#define SPI_BRD_MCR_DIS_TXF(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_DIS_TXF_SHIFT, SPI_MCR_DIS_TXF_WIDTH))

/*! @brief Set the DIS_TXF field to a new value. */
#define SPI_WR_MCR_DIS_TXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_DIS_TXF_MASK, SPI_MCR_DIS_TXF(value)))
#define SPI_BWR_MCR_DIS_TXF(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_DIS_TXF_SHIFT), SPI_MCR_DIS_TXF_SHIFT, SPI_MCR_DIS_TXF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field MDIS[14] (RW)
 *
 * Allows the clock to be stopped to the non-memory mapped logic in the module
 * effectively putting it in a software-controlled power-saving state. The reset
 * value of the MDIS bit is parameterized, with a default reset value of 0. When
 * the module is used in Slave Mode, it is recommended to leave this bit 0,
 * because a slave doesn't have control over master transactions.
 *
 * Values:
 * - 0 - Enables the module clocks.
 * - 1 - Allows external logic to disable the module clocks.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MDIS field. */
#define SPI_RD_MCR_MDIS(base) ((SPI_MCR_REG(base) & SPI_MCR_MDIS_MASK) >> SPI_MCR_MDIS_SHIFT)
#define SPI_BRD_MCR_MDIS(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_MDIS_SHIFT, SPI_MCR_MDIS_WIDTH))

/*! @brief Set the MDIS field to a new value. */
#define SPI_WR_MCR_MDIS(base, value) (SPI_RMW_MCR(base, SPI_MCR_MDIS_MASK, SPI_MCR_MDIS(value)))
#define SPI_BWR_MCR_MDIS(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_MDIS_SHIFT), SPI_MCR_MDIS_SHIFT, SPI_MCR_MDIS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field DOZE[15] (RW)
 *
 * Provides support for an externally controlled Doze mode power-saving
 * mechanism.
 *
 * Values:
 * - 0 - Doze mode has no effect on the module.
 * - 1 - Doze mode disables the module.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DOZE field. */
#define SPI_RD_MCR_DOZE(base) ((SPI_MCR_REG(base) & SPI_MCR_DOZE_MASK) >> SPI_MCR_DOZE_SHIFT)
#define SPI_BRD_MCR_DOZE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_DOZE_SHIFT, SPI_MCR_DOZE_WIDTH))

/*! @brief Set the DOZE field to a new value. */
#define SPI_WR_MCR_DOZE(base, value) (SPI_RMW_MCR(base, SPI_MCR_DOZE_MASK, SPI_MCR_DOZE(value)))
#define SPI_BWR_MCR_DOZE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_DOZE_SHIFT), SPI_MCR_DOZE_SHIFT, SPI_MCR_DOZE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field PCSIS[20:16] (RW)
 *
 * Determines the inactive state of PCSx. Refer to the chip configuration
 * details for the number of PCS signals used in this MCU.
 *
 * Values:
 * - 0 - The inactive state of PCSx is low.
 * - 1 - The inactive state of PCSx is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_PCSIS field. */
#define SPI_RD_MCR_PCSIS(base) ((SPI_MCR_REG(base) & SPI_MCR_PCSIS_MASK) >> SPI_MCR_PCSIS_SHIFT)
#define SPI_BRD_MCR_PCSIS(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_PCSIS_SHIFT, SPI_MCR_PCSIS_WIDTH))

/*! @brief Set the PCSIS field to a new value. */
#define SPI_WR_MCR_PCSIS(base, value) (SPI_RMW_MCR(base, SPI_MCR_PCSIS_MASK, SPI_MCR_PCSIS(value)))
#define SPI_BWR_MCR_PCSIS(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_PCSIS_SHIFT), SPI_MCR_PCSIS_SHIFT, SPI_MCR_PCSIS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field ROOE[24] (RW)
 *
 * In the RX FIFO overflow condition, configures the module to ignore the
 * incoming serial data or overwrite existing data. If the RX FIFO is full and new data
 * is received, the data from the transfer, generating the overflow, is ignored
 * or shifted into the shift register.
 *
 * Values:
 * - 0 - Incoming data is ignored.
 * - 1 - Incoming data is shifted into the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_ROOE field. */
#define SPI_RD_MCR_ROOE(base) ((SPI_MCR_REG(base) & SPI_MCR_ROOE_MASK) >> SPI_MCR_ROOE_SHIFT)
#define SPI_BRD_MCR_ROOE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_ROOE_SHIFT, SPI_MCR_ROOE_WIDTH))

/*! @brief Set the ROOE field to a new value. */
#define SPI_WR_MCR_ROOE(base, value) (SPI_RMW_MCR(base, SPI_MCR_ROOE_MASK, SPI_MCR_ROOE(value)))
#define SPI_BWR_MCR_ROOE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_ROOE_SHIFT), SPI_MCR_ROOE_SHIFT, SPI_MCR_ROOE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field MTFE[26] (RW)
 *
 * Enables a modified transfer format to be used.
 *
 * Values:
 * - 0 - Modified SPI transfer format disabled.
 * - 1 - Modified SPI transfer format enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MTFE field. */
#define SPI_RD_MCR_MTFE(base) ((SPI_MCR_REG(base) & SPI_MCR_MTFE_MASK) >> SPI_MCR_MTFE_SHIFT)
#define SPI_BRD_MCR_MTFE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_MTFE_SHIFT, SPI_MCR_MTFE_WIDTH))

/*! @brief Set the MTFE field to a new value. */
#define SPI_WR_MCR_MTFE(base, value) (SPI_RMW_MCR(base, SPI_MCR_MTFE_MASK, SPI_MCR_MTFE(value)))
#define SPI_BWR_MCR_MTFE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_MTFE_SHIFT), SPI_MCR_MTFE_SHIFT, SPI_MCR_MTFE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field FRZ[27] (RW)
 *
 * Enables transfers to be stopped on the next frame boundary when the device
 * enters Debug mode.
 *
 * Values:
 * - 0 - Do not halt serial transfers in Debug mode.
 * - 1 - Halt serial transfers in Debug mode.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_FRZ field. */
#define SPI_RD_MCR_FRZ(base) ((SPI_MCR_REG(base) & SPI_MCR_FRZ_MASK) >> SPI_MCR_FRZ_SHIFT)
#define SPI_BRD_MCR_FRZ(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_FRZ_SHIFT, SPI_MCR_FRZ_WIDTH))

/*! @brief Set the FRZ field to a new value. */
#define SPI_WR_MCR_FRZ(base, value) (SPI_RMW_MCR(base, SPI_MCR_FRZ_MASK, SPI_MCR_FRZ(value)))
#define SPI_BWR_MCR_FRZ(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_FRZ_SHIFT), SPI_MCR_FRZ_SHIFT, SPI_MCR_FRZ_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field DCONF[29:28] (RO)
 *
 * Selects among the different configurations of the module.
 *
 * Values:
 * - 00 - SPI
 * - 01 - Reserved
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DCONF field. */
#define SPI_RD_MCR_DCONF(base) ((SPI_MCR_REG(base) & SPI_MCR_DCONF_MASK) >> SPI_MCR_DCONF_SHIFT)
#define SPI_BRD_MCR_DCONF(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_DCONF_SHIFT, SPI_MCR_DCONF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field CONT_SCKE[30] (RW)
 *
 * Enables the Serial Communication Clock (SCK) to run continuously.
 *
 * Values:
 * - 0 - Continuous SCK disabled.
 * - 1 - Continuous SCK enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_CONT_SCKE field. */
#define SPI_RD_MCR_CONT_SCKE(base) ((SPI_MCR_REG(base) & SPI_MCR_CONT_SCKE_MASK) >> SPI_MCR_CONT_SCKE_SHIFT)
#define SPI_BRD_MCR_CONT_SCKE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_CONT_SCKE_SHIFT, SPI_MCR_CONT_SCKE_WIDTH))

/*! @brief Set the CONT_SCKE field to a new value. */
#define SPI_WR_MCR_CONT_SCKE(base, value) (SPI_RMW_MCR(base, SPI_MCR_CONT_SCKE_MASK, SPI_MCR_CONT_SCKE(value)))
#define SPI_BWR_MCR_CONT_SCKE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_CONT_SCKE_SHIFT), SPI_MCR_CONT_SCKE_SHIFT, SPI_MCR_CONT_SCKE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field MSTR[31] (RW)
 *
 * Enables either Master mode (if supported) or Slave mode (if supported)
 * operation.
 *
 * Values:
 * - 0 - Enables Slave mode
 * - 1 - Enables Master mode
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MSTR field. */
#define SPI_RD_MCR_MSTR(base) ((SPI_MCR_REG(base) & SPI_MCR_MSTR_MASK) >> SPI_MCR_MSTR_SHIFT)
#define SPI_BRD_MCR_MSTR(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_MSTR_SHIFT, SPI_MCR_MSTR_WIDTH))

/*! @brief Set the MSTR field to a new value. */
#define SPI_WR_MCR_MSTR(base, value) (SPI_RMW_MCR(base, SPI_MCR_MSTR_MASK, SPI_MCR_MSTR(value)))
#define SPI_BWR_MCR_MSTR(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_MSTR_SHIFT), SPI_MCR_MSTR_SHIFT, SPI_MCR_MSTR_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_TCR - Transfer Count Register
 ******************************************************************************/

/*!
 * @brief SPI_TCR - Transfer Count Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TCR contains a counter that indicates the number of SPI transfers made. The
 * transfer counter is intended to assist in queue management. Do not write the
 * TCR when the module is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_TCR register
 */
/*@{*/
#define SPI_RD_TCR(base)         (SPI_TCR_REG(base))
#define SPI_WR_TCR(base, value)  (SPI_TCR_REG(base) = (value))
#define SPI_RMW_TCR(base, mask, value) (SPI_WR_TCR(base, (SPI_RD_TCR(base) & ~(mask)) | (value)))
#define SPI_SET_TCR(base, value) (BME_OR32(&SPI_TCR_REG(base), (uint32_t)(value)))
#define SPI_CLR_TCR(base, value) (BME_AND32(&SPI_TCR_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_TCR(base, value) (BME_XOR32(&SPI_TCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_TCR bitfields
 */

/*!
 * @name Register SPI_TCR, field SPI_TCNT[31:16] (RW)
 *
 * Counts the number of SPI transfers the module makes. The SPI_TCNT field
 * increments every time the last bit of an SPI frame is transmitted. A value written
 * to SPI_TCNT presets the counter to that value. SPI_TCNT is reset to zero at
 * the beginning of the frame when the CTCNT field is set in the executing SPI
 * command. The Transfer Counter wraps around; incrementing the counter past 65535
 * resets the counter to zero.
 */
/*@{*/
/*! @brief Read current value of the SPI_TCR_SPI_TCNT field. */
#define SPI_RD_TCR_SPI_TCNT(base) ((SPI_TCR_REG(base) & SPI_TCR_SPI_TCNT_MASK) >> SPI_TCR_SPI_TCNT_SHIFT)
#define SPI_BRD_TCR_SPI_TCNT(base) (BME_UBFX32(&SPI_TCR_REG(base), SPI_TCR_SPI_TCNT_SHIFT, SPI_TCR_SPI_TCNT_WIDTH))

/*! @brief Set the SPI_TCNT field to a new value. */
#define SPI_WR_TCR_SPI_TCNT(base, value) (SPI_RMW_TCR(base, SPI_TCR_SPI_TCNT_MASK, SPI_TCR_SPI_TCNT(value)))
#define SPI_BWR_TCR_SPI_TCNT(base, value) (BME_BFI32(&SPI_TCR_REG(base), ((uint32_t)(value) << SPI_TCR_SPI_TCNT_SHIFT), SPI_TCR_SPI_TCNT_SHIFT, SPI_TCR_SPI_TCNT_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_CTAR_SLAVE - Clock and Transfer Attributes Register (In Slave Mode)
 ******************************************************************************/

/*!
 * @brief SPI_CTAR_SLAVE - Clock and Transfer Attributes Register (In Slave Mode) (RW)
 *
 * Reset value: 0x78000000U
 *
 * When the module is configured as an SPI bus slave, the CTAR0 register is used.
 */
/*!
 * @name Constants and macros for entire SPI_CTAR_SLAVE register
 */
/*@{*/
#define SPI_RD_CTAR_SLAVE(base, index) (SPI_CTAR_SLAVE_REG(base, index))
#define SPI_WR_CTAR_SLAVE(base, index, value) (SPI_CTAR_SLAVE_REG(base, index) = (value))
#define SPI_RMW_CTAR_SLAVE(base, index, mask, value) (SPI_WR_CTAR_SLAVE(base, index, (SPI_RD_CTAR_SLAVE(base, index) & ~(mask)) | (value)))
#define SPI_SET_CTAR_SLAVE(base, index, value) (BME_OR32(&SPI_CTAR_SLAVE_REG(base, index), (uint32_t)(value)))
#define SPI_CLR_CTAR_SLAVE(base, index, value) (BME_AND32(&SPI_CTAR_SLAVE_REG(base, index), (uint32_t)(~(value))))
#define SPI_TOG_CTAR_SLAVE(base, index, value) (BME_XOR32(&SPI_CTAR_SLAVE_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_CTAR_SLAVE bitfields
 */

/*!
 * @name Register SPI_CTAR_SLAVE, field CPHA[25] (RW)
 *
 * Selects which edge of SCK causes data to change and which edge causes data to
 * be captured. This bit is used in both master and slave mode. For successful
 * communication between serial devices, the devices must have identical clock
 * phase settings. In Continuous SCK mode, the bit value is ignored and the
 * transfers are done as if the CPHA bit is set to 1.
 *
 * Values:
 * - 0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_CPHA field. */
#define SPI_RD_CTAR_SLAVE_CPHA(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_CPHA_MASK) >> SPI_CTAR_SLAVE_CPHA_SHIFT)
#define SPI_BRD_CTAR_SLAVE_CPHA(base, index) (BME_UBFX32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPHA_SHIFT, SPI_CTAR_SLAVE_CPHA_WIDTH))

/*! @brief Set the CPHA field to a new value. */
#define SPI_WR_CTAR_SLAVE_CPHA(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_CPHA_MASK, SPI_CTAR_SLAVE_CPHA(value)))
#define SPI_BWR_CTAR_SLAVE_CPHA(base, index, value) (BME_BFI32(&SPI_CTAR_SLAVE_REG(base, index), ((uint32_t)(value) << SPI_CTAR_SLAVE_CPHA_SHIFT), SPI_CTAR_SLAVE_CPHA_SHIFT, SPI_CTAR_SLAVE_CPHA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR_SLAVE, field CPOL[26] (RW)
 *
 * Selects the inactive state of the Serial Communications Clock (SCK). In case
 * of Continuous SCK mode, when the module goes in low power mode(disabled),
 * inactive state of SCK is not guaranted.
 *
 * Values:
 * - 0 - The inactive state value of SCK is low.
 * - 1 - The inactive state value of SCK is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_CPOL field. */
#define SPI_RD_CTAR_SLAVE_CPOL(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_CPOL_MASK) >> SPI_CTAR_SLAVE_CPOL_SHIFT)
#define SPI_BRD_CTAR_SLAVE_CPOL(base, index) (BME_UBFX32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPOL_SHIFT, SPI_CTAR_SLAVE_CPOL_WIDTH))

/*! @brief Set the CPOL field to a new value. */
#define SPI_WR_CTAR_SLAVE_CPOL(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_CPOL_MASK, SPI_CTAR_SLAVE_CPOL(value)))
#define SPI_BWR_CTAR_SLAVE_CPOL(base, index, value) (BME_BFI32(&SPI_CTAR_SLAVE_REG(base, index), ((uint32_t)(value) << SPI_CTAR_SLAVE_CPOL_SHIFT), SPI_CTAR_SLAVE_CPOL_SHIFT, SPI_CTAR_SLAVE_CPOL_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR_SLAVE, field FMSZ[30:27] (RW)
 *
 * The number of bits transfered per frame is equal to the FMSZ field value plus
 * 1. Note that the minimum valid value of frame size is 4.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_FMSZ field. */
#define SPI_RD_CTAR_SLAVE_FMSZ(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT)
#define SPI_BRD_CTAR_SLAVE_FMSZ(base, index) (BME_UBFX32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_FMSZ_SHIFT, SPI_CTAR_SLAVE_FMSZ_WIDTH))

/*! @brief Set the FMSZ field to a new value. */
#define SPI_WR_CTAR_SLAVE_FMSZ(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_FMSZ_MASK, SPI_CTAR_SLAVE_FMSZ(value)))
#define SPI_BWR_CTAR_SLAVE_FMSZ(base, index, value) (BME_BFI32(&SPI_CTAR_SLAVE_REG(base, index), ((uint32_t)(value) << SPI_CTAR_SLAVE_FMSZ_SHIFT), SPI_CTAR_SLAVE_FMSZ_SHIFT, SPI_CTAR_SLAVE_FMSZ_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_CTAR - Clock and Transfer Attributes Register (In Master Mode)
 ******************************************************************************/

/*!
 * @brief SPI_CTAR - Clock and Transfer Attributes Register (In Master Mode) (RW)
 *
 * Reset value: 0x78000000U
 *
 * CTAR registers are used to define different transfer attributes. Do not write
 * to the CTAR registers while the module is in the Running state. In Master
 * mode, the CTAR registers define combinations of transfer attributes such as frame
 * size, clock phase and polarity, data bit ordering, baud rate, and various
 * delays. In slave mode, a subset of the bitfields in CTAR0 are used to set the
 * slave transfer attributes. When the module is configured as an SPI master, the
 * CTAS field in the command portion of the TX FIFO entry selects which of the CTAR
 * registers is used. When the module is configured as an SPI bus slave, it uses
 * the CTAR0 register.
 */
/*!
 * @name Constants and macros for entire SPI_CTAR register
 */
/*@{*/
#define SPI_RD_CTAR(base, index) (SPI_CTAR_REG(base, index))
#define SPI_WR_CTAR(base, index, value) (SPI_CTAR_REG(base, index) = (value))
#define SPI_RMW_CTAR(base, index, mask, value) (SPI_WR_CTAR(base, index, (SPI_RD_CTAR(base, index) & ~(mask)) | (value)))
#define SPI_SET_CTAR(base, index, value) (BME_OR32(&SPI_CTAR_REG(base, index), (uint32_t)(value)))
#define SPI_CLR_CTAR(base, index, value) (BME_AND32(&SPI_CTAR_REG(base, index), (uint32_t)(~(value))))
#define SPI_TOG_CTAR(base, index, value) (BME_XOR32(&SPI_CTAR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_CTAR bitfields
 */

/*!
 * @name Register SPI_CTAR, field BR[3:0] (RW)
 *
 * Selects the scaler value for the baud rate. This field is used only in master
 * mode. The prescaled protocol clock is divided by the Baud Rate Scaler to
 * generate the frequency of the SCK. The baud rate is computed according to the
 * following equation: SCK baud rate = (fP /PBR) x [(1+DBR)/BR] The following table
 * lists the baud rate scaler values. Baud Rate Scaler CTARn[BR] Baud Rate Scaler
 * Value 0000 2 0001 4 0010 6 0011 8 0100 16 0101 32 0110 64 0111 128 1000 256
 * 1001 512 1010 1024 1011 2048 1100 4096 1101 8192 1110 16384 1111 32768
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_BR field. */
#define SPI_RD_CTAR_BR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_BR_MASK) >> SPI_CTAR_BR_SHIFT)
#define SPI_BRD_CTAR_BR(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_BR_SHIFT, SPI_CTAR_BR_WIDTH))

/*! @brief Set the BR field to a new value. */
#define SPI_WR_CTAR_BR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_BR_MASK, SPI_CTAR_BR(value)))
#define SPI_BWR_CTAR_BR(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_BR_SHIFT), SPI_CTAR_BR_SHIFT, SPI_CTAR_BR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field DT[7:4] (RW)
 *
 * Selects the Delay after Transfer Scaler. This field is used only in master
 * mode. The Delay after Transfer is the time between the negation of the PCS
 * signal at the end of a frame and the assertion of PCS at the beginning of the next
 * frame. In the Continuous Serial Communications Clock operation, the DT value
 * is fixed to one SCK clock period, The Delay after Transfer is a multiple of the
 * protocol clock period, and it is computed according to the following
 * equation: tDT = (1/fP ) x PDT x DT See Delay Scaler Encoding table in CTARn[CSSCK] bit
 * field description for scaler values.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_DT field. */
#define SPI_RD_CTAR_DT(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_DT_MASK) >> SPI_CTAR_DT_SHIFT)
#define SPI_BRD_CTAR_DT(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_DT_SHIFT, SPI_CTAR_DT_WIDTH))

/*! @brief Set the DT field to a new value. */
#define SPI_WR_CTAR_DT(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_DT_MASK, SPI_CTAR_DT(value)))
#define SPI_BWR_CTAR_DT(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_DT_SHIFT), SPI_CTAR_DT_SHIFT, SPI_CTAR_DT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field ASC[11:8] (RW)
 *
 * Selects the scaler value for the After SCK Delay. This field is used only in
 * master mode. The After SCK Delay is the delay between the last edge of SCK and
 * the negation of PCS. The delay is a multiple of the protocol clock period,
 * and it is computed according to the following equation: t ASC = (1/fP) x PASC x
 * ASC See Delay Scaler Encoding table in CTARn[CSSCK] bit field description for
 * scaler values. Refer After SCK Delay (tASC ) for more details.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_ASC field. */
#define SPI_RD_CTAR_ASC(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_ASC_MASK) >> SPI_CTAR_ASC_SHIFT)
#define SPI_BRD_CTAR_ASC(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_ASC_SHIFT, SPI_CTAR_ASC_WIDTH))

/*! @brief Set the ASC field to a new value. */
#define SPI_WR_CTAR_ASC(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_ASC_MASK, SPI_CTAR_ASC(value)))
#define SPI_BWR_CTAR_ASC(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_ASC_SHIFT), SPI_CTAR_ASC_SHIFT, SPI_CTAR_ASC_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CSSCK[15:12] (RW)
 *
 * Selects the scaler value for the PCS to SCK delay. This field is used only in
 * master mode. The PCS to SCK Delay is the delay between the assertion of PCS
 * and the first edge of the SCK. The delay is a multiple of the protocol clock
 * period, and it is computed according to the following equation: t CSC = (1/fP )
 * x PCSSCK x CSSCK. The following table lists the delay scaler values. Delay
 * Scaler Encoding Field Value Delay Scaler Value 0000 2 0001 4 0010 8 0011 16 0100
 * 32 0101 64 0110 128 0111 256 1000 512 1001 1024 1010 2048 1011 4096 1100 8192
 * 1101 16384 1110 32768 1111 65536 Refer PCS to SCK Delay (tCSC ) for more
 * details.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CSSCK field. */
#define SPI_RD_CTAR_CSSCK(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CSSCK_MASK) >> SPI_CTAR_CSSCK_SHIFT)
#define SPI_BRD_CTAR_CSSCK(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_CSSCK_SHIFT, SPI_CTAR_CSSCK_WIDTH))

/*! @brief Set the CSSCK field to a new value. */
#define SPI_WR_CTAR_CSSCK(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CSSCK_MASK, SPI_CTAR_CSSCK(value)))
#define SPI_BWR_CTAR_CSSCK(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_CSSCK_SHIFT), SPI_CTAR_CSSCK_SHIFT, SPI_CTAR_CSSCK_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PBR[17:16] (RW)
 *
 * Selects the prescaler value for the baud rate. This field is used only in
 * master mode. The baud rate is the frequency of the SCK. The protocol clock is
 * divided by the prescaler value before the baud rate selection takes place. See
 * the BR field description for details on how to compute the baud rate.
 *
 * Values:
 * - 00 - Baud Rate Prescaler value is 2.
 * - 01 - Baud Rate Prescaler value is 3.
 * - 10 - Baud Rate Prescaler value is 5.
 * - 11 - Baud Rate Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PBR field. */
#define SPI_RD_CTAR_PBR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PBR_MASK) >> SPI_CTAR_PBR_SHIFT)
#define SPI_BRD_CTAR_PBR(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_PBR_SHIFT, SPI_CTAR_PBR_WIDTH))

/*! @brief Set the PBR field to a new value. */
#define SPI_WR_CTAR_PBR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PBR_MASK, SPI_CTAR_PBR(value)))
#define SPI_BWR_CTAR_PBR(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_PBR_SHIFT), SPI_CTAR_PBR_SHIFT, SPI_CTAR_PBR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PDT[19:18] (RW)
 *
 * Selects the prescaler value for the delay between the negation of the PCS
 * signal at the end of a frame and the assertion of PCS at the beginning of the
 * next frame. The PDT field is only used in master mode. See the DT field
 * description for details on how to compute the Delay after Transfer. Refer Delay after
 * Transfer (tDT ) for more details.
 *
 * Values:
 * - 00 - Delay after Transfer Prescaler value is 1.
 * - 01 - Delay after Transfer Prescaler value is 3.
 * - 10 - Delay after Transfer Prescaler value is 5.
 * - 11 - Delay after Transfer Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PDT field. */
#define SPI_RD_CTAR_PDT(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PDT_MASK) >> SPI_CTAR_PDT_SHIFT)
#define SPI_BRD_CTAR_PDT(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_PDT_SHIFT, SPI_CTAR_PDT_WIDTH))

/*! @brief Set the PDT field to a new value. */
#define SPI_WR_CTAR_PDT(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PDT_MASK, SPI_CTAR_PDT(value)))
#define SPI_BWR_CTAR_PDT(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_PDT_SHIFT), SPI_CTAR_PDT_SHIFT, SPI_CTAR_PDT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PASC[21:20] (RW)
 *
 * Selects the prescaler value for the delay between the last edge of SCK and
 * the negation of PCS. See the ASC field description for information on how to
 * compute the After SCK Delay. Refer After SCK Delay (tASC ) for more details.
 *
 * Values:
 * - 00 - Delay after Transfer Prescaler value is 1.
 * - 01 - Delay after Transfer Prescaler value is 3.
 * - 10 - Delay after Transfer Prescaler value is 5.
 * - 11 - Delay after Transfer Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PASC field. */
#define SPI_RD_CTAR_PASC(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PASC_MASK) >> SPI_CTAR_PASC_SHIFT)
#define SPI_BRD_CTAR_PASC(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_PASC_SHIFT, SPI_CTAR_PASC_WIDTH))

/*! @brief Set the PASC field to a new value. */
#define SPI_WR_CTAR_PASC(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PASC_MASK, SPI_CTAR_PASC(value)))
#define SPI_BWR_CTAR_PASC(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_PASC_SHIFT), SPI_CTAR_PASC_SHIFT, SPI_CTAR_PASC_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PCSSCK[23:22] (RW)
 *
 * Selects the prescaler value for the delay between assertion of PCS and the
 * first edge of the SCK. See the CSSCK field description for information on how to
 * compute the PCS to SCK Delay. Refer PCS to SCK Delay (tCSC ) for more details.
 *
 * Values:
 * - 00 - PCS to SCK Prescaler value is 1.
 * - 01 - PCS to SCK Prescaler value is 3.
 * - 10 - PCS to SCK Prescaler value is 5.
 * - 11 - PCS to SCK Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PCSSCK field. */
#define SPI_RD_CTAR_PCSSCK(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PCSSCK_MASK) >> SPI_CTAR_PCSSCK_SHIFT)
#define SPI_BRD_CTAR_PCSSCK(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_PCSSCK_SHIFT, SPI_CTAR_PCSSCK_WIDTH))

/*! @brief Set the PCSSCK field to a new value. */
#define SPI_WR_CTAR_PCSSCK(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PCSSCK_MASK, SPI_CTAR_PCSSCK(value)))
#define SPI_BWR_CTAR_PCSSCK(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_PCSSCK_SHIFT), SPI_CTAR_PCSSCK_SHIFT, SPI_CTAR_PCSSCK_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field LSBFE[24] (RW)
 *
 * Specifies whether the LSB or MSB of the frame is transferred first.
 *
 * Values:
 * - 0 - Data is transferred MSB first.
 * - 1 - Data is transferred LSB first.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_LSBFE field. */
#define SPI_RD_CTAR_LSBFE(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_LSBFE_MASK) >> SPI_CTAR_LSBFE_SHIFT)
#define SPI_BRD_CTAR_LSBFE(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_LSBFE_SHIFT, SPI_CTAR_LSBFE_WIDTH))

/*! @brief Set the LSBFE field to a new value. */
#define SPI_WR_CTAR_LSBFE(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_LSBFE_MASK, SPI_CTAR_LSBFE(value)))
#define SPI_BWR_CTAR_LSBFE(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_LSBFE_SHIFT), SPI_CTAR_LSBFE_SHIFT, SPI_CTAR_LSBFE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CPHA[25] (RW)
 *
 * Selects which edge of SCK causes data to change and which edge causes data to
 * be captured. This bit is used in both master and slave mode. For successful
 * communication between serial devices, the devices must have identical clock
 * phase settings. In Continuous SCK mode, the bit value is ignored and the
 * transfers are done as if the CPHA bit is set to 1.
 *
 * Values:
 * - 0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CPHA field. */
#define SPI_RD_CTAR_CPHA(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CPHA_MASK) >> SPI_CTAR_CPHA_SHIFT)
#define SPI_BRD_CTAR_CPHA(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPHA_SHIFT, SPI_CTAR_CPHA_WIDTH))

/*! @brief Set the CPHA field to a new value. */
#define SPI_WR_CTAR_CPHA(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CPHA_MASK, SPI_CTAR_CPHA(value)))
#define SPI_BWR_CTAR_CPHA(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_CPHA_SHIFT), SPI_CTAR_CPHA_SHIFT, SPI_CTAR_CPHA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CPOL[26] (RW)
 *
 * Selects the inactive state of the Serial Communications Clock (SCK). This bit
 * is used in both master and slave mode. For successful communication between
 * serial devices, the devices must have identical clock polarities. When the
 * Continuous Selection Format is selected, switching between clock polarities
 * without stopping the module can cause errors in the transfer due to the peripheral
 * device interpreting the switch of clock polarity as a valid clock edge. In case
 * of Continuous SCK mode, when the module goes in low power mode(disabled),
 * inactive state of SCK is not guaranted.
 *
 * Values:
 * - 0 - The inactive state value of SCK is low.
 * - 1 - The inactive state value of SCK is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CPOL field. */
#define SPI_RD_CTAR_CPOL(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CPOL_MASK) >> SPI_CTAR_CPOL_SHIFT)
#define SPI_BRD_CTAR_CPOL(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPOL_SHIFT, SPI_CTAR_CPOL_WIDTH))

/*! @brief Set the CPOL field to a new value. */
#define SPI_WR_CTAR_CPOL(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CPOL_MASK, SPI_CTAR_CPOL(value)))
#define SPI_BWR_CTAR_CPOL(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_CPOL_SHIFT), SPI_CTAR_CPOL_SHIFT, SPI_CTAR_CPOL_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field FMSZ[30:27] (RW)
 *
 * The number of bits transferred per frame is equal to the FMSZ value plus 1.
 * Regardless of the transmission mode, the minimum valid frame size value is 4.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_FMSZ field. */
#define SPI_RD_CTAR_FMSZ(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_FMSZ_SHIFT)
#define SPI_BRD_CTAR_FMSZ(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_FMSZ_SHIFT, SPI_CTAR_FMSZ_WIDTH))

/*! @brief Set the FMSZ field to a new value. */
#define SPI_WR_CTAR_FMSZ(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_FMSZ_MASK, SPI_CTAR_FMSZ(value)))
#define SPI_BWR_CTAR_FMSZ(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_FMSZ_SHIFT), SPI_CTAR_FMSZ_SHIFT, SPI_CTAR_FMSZ_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field DBR[31] (RW)
 *
 * Doubles the effective baud rate of the Serial Communications Clock (SCK).
 * This field is used only in master mode. It effectively halves the Baud Rate
 * division ratio, supporting faster frequencies, and odd division ratios for the
 * Serial Communications Clock (SCK). When the DBR bit is set, the duty cycle of the
 * Serial Communications Clock (SCK) depends on the value in the Baud Rate
 * Prescaler and the Clock Phase bit as listed in the following table. See the BR field
 * description for details on how to compute the baud rate. SPI SCK Duty Cycle
 * DBR CPHA PBR SCK Duty Cycle 0 any any 50/50 1 0 00 50/50 1 0 01 33/66 1 0 10
 * 40/60 1 0 11 43/57 1 1 00 50/50 1 1 01 66/33 1 1 10 60/40 1 1 11 57/43
 *
 * Values:
 * - 0 - The baud rate is computed normally with a 50/50 duty cycle.
 * - 1 - The baud rate is doubled with the duty cycle depending on the Baud Rate
 *     Prescaler.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_DBR field. */
#define SPI_RD_CTAR_DBR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_DBR_MASK) >> SPI_CTAR_DBR_SHIFT)
#define SPI_BRD_CTAR_DBR(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_DBR_SHIFT, SPI_CTAR_DBR_WIDTH))

/*! @brief Set the DBR field to a new value. */
#define SPI_WR_CTAR_DBR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_DBR_MASK, SPI_CTAR_DBR(value)))
#define SPI_BWR_CTAR_DBR(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_DBR_SHIFT), SPI_CTAR_DBR_SHIFT, SPI_CTAR_DBR_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_SR - Status Register
 ******************************************************************************/

/*!
 * @brief SPI_SR - Status Register (RW)
 *
 * Reset value: 0x02000000U
 *
 * SR contains status and flag bits. The bits reflect the status of the module
 * and indicate the occurrence of events that can generate interrupt or DMA
 * requests. Software can clear flag bits in the SR by writing a 1 to them. Writing a 0
 * to a flag bit has no effect. This register may not be writable in Module
 * Disable mode due to the use of power saving mechanisms.
 */
/*!
 * @name Constants and macros for entire SPI_SR register
 */
/*@{*/
#define SPI_RD_SR(base)          (SPI_SR_REG(base))
#define SPI_WR_SR(base, value)   (SPI_SR_REG(base) = (value))
#define SPI_RMW_SR(base, mask, value) (SPI_WR_SR(base, (SPI_RD_SR(base) & ~(mask)) | (value)))
#define SPI_SET_SR(base, value)  (BME_OR32(&SPI_SR_REG(base), (uint32_t)(value)))
#define SPI_CLR_SR(base, value)  (BME_AND32(&SPI_SR_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_SR(base, value)  (BME_XOR32(&SPI_SR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_SR bitfields
 */

/*!
 * @name Register SPI_SR, field POPNXTPTR[3:0] (RO)
 *
 * Contains a pointer to the RX FIFO entry to be returned when the POPR is read.
 * The POPNXTPTR is updated when the POPR is read.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_POPNXTPTR field. */
#define SPI_RD_SR_POPNXTPTR(base) ((SPI_SR_REG(base) & SPI_SR_POPNXTPTR_MASK) >> SPI_SR_POPNXTPTR_SHIFT)
#define SPI_BRD_SR_POPNXTPTR(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_POPNXTPTR_SHIFT, SPI_SR_POPNXTPTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field RXCTR[7:4] (RO)
 *
 * Indicates the number of entries in the RX FIFO. The RXCTR is decremented
 * every time the POPR is read. The RXCTR is incremented every time data is
 * transferred from the shift register to the RX FIFO.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RXCTR field. */
#define SPI_RD_SR_RXCTR(base) ((SPI_SR_REG(base) & SPI_SR_RXCTR_MASK) >> SPI_SR_RXCTR_SHIFT)
#define SPI_BRD_SR_RXCTR(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_RXCTR_SHIFT, SPI_SR_RXCTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TXNXTPTR[11:8] (RO)
 *
 * Indicates which TX FIFO entry is transmitted during the next transfer. The
 * TXNXTPTR field is updated every time SPI data is transferred from the TX FIFO to
 * the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXNXTPTR field. */
#define SPI_RD_SR_TXNXTPTR(base) ((SPI_SR_REG(base) & SPI_SR_TXNXTPTR_MASK) >> SPI_SR_TXNXTPTR_SHIFT)
#define SPI_BRD_SR_TXNXTPTR(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TXNXTPTR_SHIFT, SPI_SR_TXNXTPTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TXCTR[15:12] (RO)
 *
 * Indicates the number of valid entries in the TX FIFO. The TXCTR is
 * incremented every time the PUSHR is written. The TXCTR is decremented every time an SPI
 * command is executed and the SPI data is transferred to the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXCTR field. */
#define SPI_RD_SR_TXCTR(base) ((SPI_SR_REG(base) & SPI_SR_TXCTR_MASK) >> SPI_SR_TXCTR_SHIFT)
#define SPI_BRD_SR_TXCTR(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TXCTR_SHIFT, SPI_SR_TXCTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field RFDF[17] (W1C)
 *
 * Provides a method for the module to request that entries be removed from the
 * RX FIFO. The bit is set while the RX FIFO is not empty. The RFDF bit can be
 * cleared by writing 1 to it or by acknowledgement from the DMA controller when
 * the RX FIFO is empty.
 *
 * Values:
 * - 0 - RX FIFO is empty.
 * - 1 - RX FIFO is not empty.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RFDF field. */
#define SPI_RD_SR_RFDF(base) ((SPI_SR_REG(base) & SPI_SR_RFDF_MASK) >> SPI_SR_RFDF_SHIFT)
#define SPI_BRD_SR_RFDF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_RFDF_SHIFT, SPI_SR_RFDF_WIDTH))

/*! @brief Set the RFDF field to a new value. */
#define SPI_WR_SR_RFDF(base, value) (SPI_RMW_SR(base, (SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_RFDF(value)))
#define SPI_BWR_SR_RFDF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_RFDF_SHIFT), SPI_SR_RFDF_SHIFT, SPI_SR_RFDF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field RFOF[19] (W1C)
 *
 * Indicates an overflow condition in the RX FIFO. The field is set when the RX
 * FIFO and shift register are full and a transfer is initiated. The bit remains
 * set until it is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No Rx FIFO overflow.
 * - 1 - Rx FIFO overflow has occurred.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RFOF field. */
#define SPI_RD_SR_RFOF(base) ((SPI_SR_REG(base) & SPI_SR_RFOF_MASK) >> SPI_SR_RFOF_SHIFT)
#define SPI_BRD_SR_RFOF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_RFOF_SHIFT, SPI_SR_RFOF_WIDTH))

/*! @brief Set the RFOF field to a new value. */
#define SPI_WR_SR_RFOF(base, value) (SPI_RMW_SR(base, (SPI_SR_RFOF_MASK | SPI_SR_RFDF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_RFOF(value)))
#define SPI_BWR_SR_RFOF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_RFOF_SHIFT), SPI_SR_RFOF_SHIFT, SPI_SR_RFOF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TFFF[25] (W1C)
 *
 * Provides a method for the module to request more entries to be added to the
 * TX FIFO. The TFFF bit is set while the TX FIFO is not full. The TFFF bit can be
 * cleared by writing 1 to it or by acknowledgement from the DMA controller to
 * the TX FIFO full request.
 *
 * Values:
 * - 0 - TX FIFO is full.
 * - 1 - TX FIFO is not full.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TFFF field. */
#define SPI_RD_SR_TFFF(base) ((SPI_SR_REG(base) & SPI_SR_TFFF_MASK) >> SPI_SR_TFFF_SHIFT)
#define SPI_BRD_SR_TFFF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TFFF_SHIFT, SPI_SR_TFFF_WIDTH))

/*! @brief Set the TFFF field to a new value. */
#define SPI_WR_SR_TFFF(base, value) (SPI_RMW_SR(base, (SPI_SR_TFFF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_TFFF(value)))
#define SPI_BWR_SR_TFFF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_TFFF_SHIFT), SPI_SR_TFFF_SHIFT, SPI_SR_TFFF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TFUF[27] (W1C)
 *
 * Indicates an underflow condition in the TX FIFO. The transmit underflow
 * condition is detected only for SPI blocks operating in Slave mode and SPI
 * configuration. TFUF is set when the TX FIFO of the module operating in SPI Slave mode
 * is empty and an external SPI master initiates a transfer. The TFUF bit remains
 * set until cleared by writing 1 to it.
 *
 * Values:
 * - 0 - No TX FIFO underflow.
 * - 1 - TX FIFO underflow has occurred.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TFUF field. */
#define SPI_RD_SR_TFUF(base) ((SPI_SR_REG(base) & SPI_SR_TFUF_MASK) >> SPI_SR_TFUF_SHIFT)
#define SPI_BRD_SR_TFUF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TFUF_SHIFT, SPI_SR_TFUF_WIDTH))

/*! @brief Set the TFUF field to a new value. */
#define SPI_WR_SR_TFUF(base, value) (SPI_RMW_SR(base, (SPI_SR_TFUF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_TFUF(value)))
#define SPI_BWR_SR_TFUF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_TFUF_SHIFT), SPI_SR_TFUF_SHIFT, SPI_SR_TFUF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field EOQF[28] (W1C)
 *
 * Indicates that the last entry in a queue has been transmitted when the module
 * is in Master mode. The EOQF bit is set when the TX FIFO entry has the EOQ bit
 * set in the command halfword and the end of the transfer is reached. The EOQF
 * bit remains set until cleared by writing a 1 to it. When the EOQF bit is set,
 * the TXRXS bit is automatically cleared.
 *
 * Values:
 * - 0 - EOQ is not set in the executing command.
 * - 1 - EOQ is set in the executing SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_EOQF field. */
#define SPI_RD_SR_EOQF(base) ((SPI_SR_REG(base) & SPI_SR_EOQF_MASK) >> SPI_SR_EOQF_SHIFT)
#define SPI_BRD_SR_EOQF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_EOQF_SHIFT, SPI_SR_EOQF_WIDTH))

/*! @brief Set the EOQF field to a new value. */
#define SPI_WR_SR_EOQF(base, value) (SPI_RMW_SR(base, (SPI_SR_EOQF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_EOQF(value)))
#define SPI_BWR_SR_EOQF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_EOQF_SHIFT), SPI_SR_EOQF_SHIFT, SPI_SR_EOQF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TXRXS[30] (W1C)
 *
 * Reflects the run status of the module.
 *
 * Values:
 * - 0 - Transmit and receive operations are disabled (The module is in Stopped
 *     state).
 * - 1 - Transmit and receive operations are enabled (The module is in Running
 *     state).
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXRXS field. */
#define SPI_RD_SR_TXRXS(base) ((SPI_SR_REG(base) & SPI_SR_TXRXS_MASK) >> SPI_SR_TXRXS_SHIFT)
#define SPI_BRD_SR_TXRXS(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TXRXS_SHIFT, SPI_SR_TXRXS_WIDTH))

/*! @brief Set the TXRXS field to a new value. */
#define SPI_WR_SR_TXRXS(base, value) (SPI_RMW_SR(base, (SPI_SR_TXRXS_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TCF_MASK), SPI_SR_TXRXS(value)))
#define SPI_BWR_SR_TXRXS(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_TXRXS_SHIFT), SPI_SR_TXRXS_SHIFT, SPI_SR_TXRXS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TCF[31] (W1C)
 *
 * Indicates that all bits in a frame have been shifted out. TCF remains set
 * until it is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - Transfer not complete.
 * - 1 - Transfer complete.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TCF field. */
#define SPI_RD_SR_TCF(base)  ((SPI_SR_REG(base) & SPI_SR_TCF_MASK) >> SPI_SR_TCF_SHIFT)
#define SPI_BRD_SR_TCF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TCF_SHIFT, SPI_SR_TCF_WIDTH))

/*! @brief Set the TCF field to a new value. */
#define SPI_WR_SR_TCF(base, value) (SPI_RMW_SR(base, (SPI_SR_TCF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK), SPI_SR_TCF(value)))
#define SPI_BWR_SR_TCF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_TCF_SHIFT), SPI_SR_TCF_SHIFT, SPI_SR_TCF_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_RSER - DMA/Interrupt Request Select and Enable Register
 ******************************************************************************/

/*!
 * @brief SPI_RSER - DMA/Interrupt Request Select and Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * RSER controls DMA and interrupt requests. Do not write to the RSER while the
 * module is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_RSER register
 */
/*@{*/
#define SPI_RD_RSER(base)        (SPI_RSER_REG(base))
#define SPI_WR_RSER(base, value) (SPI_RSER_REG(base) = (value))
#define SPI_RMW_RSER(base, mask, value) (SPI_WR_RSER(base, (SPI_RD_RSER(base) & ~(mask)) | (value)))
#define SPI_SET_RSER(base, value) (BME_OR32(&SPI_RSER_REG(base), (uint32_t)(value)))
#define SPI_CLR_RSER(base, value) (BME_AND32(&SPI_RSER_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_RSER(base, value) (BME_XOR32(&SPI_RSER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_RSER bitfields
 */

/*!
 * @name Register SPI_RSER, field RFDF_DIRS[16] (RW)
 *
 * Selects between generating a DMA request or an interrupt request. When the
 * RFDF flag bit in the SR is set, and the RFDF_RE bit in the RSER is set, the
 * RFDF_DIRS bit selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - Interrupt request.
 * - 1 - DMA request.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFDF_DIRS field. */
#define SPI_RD_RSER_RFDF_DIRS(base) ((SPI_RSER_REG(base) & SPI_RSER_RFDF_DIRS_MASK) >> SPI_RSER_RFDF_DIRS_SHIFT)
#define SPI_BRD_RSER_RFDF_DIRS(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_RFDF_DIRS_SHIFT, SPI_RSER_RFDF_DIRS_WIDTH))

/*! @brief Set the RFDF_DIRS field to a new value. */
#define SPI_WR_RSER_RFDF_DIRS(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFDF_DIRS_MASK, SPI_RSER_RFDF_DIRS(value)))
#define SPI_BWR_RSER_RFDF_DIRS(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_RFDF_DIRS_SHIFT), SPI_RSER_RFDF_DIRS_SHIFT, SPI_RSER_RFDF_DIRS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field RFDF_RE[17] (RW)
 *
 * Enables the RFDF flag in the SR to generate a request. The RFDF_DIRS bit
 * selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - RFDF interrupt or DMA requests are disabled.
 * - 1 - RFDF interrupt or DMA requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFDF_RE field. */
#define SPI_RD_RSER_RFDF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_RFDF_RE_MASK) >> SPI_RSER_RFDF_RE_SHIFT)
#define SPI_BRD_RSER_RFDF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_RFDF_RE_SHIFT, SPI_RSER_RFDF_RE_WIDTH))

/*! @brief Set the RFDF_RE field to a new value. */
#define SPI_WR_RSER_RFDF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFDF_RE_MASK, SPI_RSER_RFDF_RE(value)))
#define SPI_BWR_RSER_RFDF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_RFDF_RE_SHIFT), SPI_RSER_RFDF_RE_SHIFT, SPI_RSER_RFDF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field RFOF_RE[19] (RW)
 *
 * Enables the RFOF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - RFOF interrupt requests are disabled.
 * - 1 - RFOF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFOF_RE field. */
#define SPI_RD_RSER_RFOF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_RFOF_RE_MASK) >> SPI_RSER_RFOF_RE_SHIFT)
#define SPI_BRD_RSER_RFOF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_RFOF_RE_SHIFT, SPI_RSER_RFOF_RE_WIDTH))

/*! @brief Set the RFOF_RE field to a new value. */
#define SPI_WR_RSER_RFOF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFOF_RE_MASK, SPI_RSER_RFOF_RE(value)))
#define SPI_BWR_RSER_RFOF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_RFOF_RE_SHIFT), SPI_RSER_RFOF_RE_SHIFT, SPI_RSER_RFOF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFFF_DIRS[24] (RW)
 *
 * Selects between generating a DMA request or an interrupt request. When
 * SR[TFFF] and RSER[TFFF_RE] are set, this field selects between generating an
 * interrupt request or a DMA request.
 *
 * Values:
 * - 0 - TFFF flag generates interrupt requests.
 * - 1 - TFFF flag generates DMA requests.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFFF_DIRS field. */
#define SPI_RD_RSER_TFFF_DIRS(base) ((SPI_RSER_REG(base) & SPI_RSER_TFFF_DIRS_MASK) >> SPI_RSER_TFFF_DIRS_SHIFT)
#define SPI_BRD_RSER_TFFF_DIRS(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_TFFF_DIRS_SHIFT, SPI_RSER_TFFF_DIRS_WIDTH))

/*! @brief Set the TFFF_DIRS field to a new value. */
#define SPI_WR_RSER_TFFF_DIRS(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFFF_DIRS_MASK, SPI_RSER_TFFF_DIRS(value)))
#define SPI_BWR_RSER_TFFF_DIRS(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_TFFF_DIRS_SHIFT), SPI_RSER_TFFF_DIRS_SHIFT, SPI_RSER_TFFF_DIRS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFFF_RE[25] (RW)
 *
 * Enables the TFFF flag in the SR to generate a request. The TFFF_DIRS bit
 * selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - TFFF interrupts or DMA requests are disabled.
 * - 1 - TFFF interrupts or DMA requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFFF_RE field. */
#define SPI_RD_RSER_TFFF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TFFF_RE_MASK) >> SPI_RSER_TFFF_RE_SHIFT)
#define SPI_BRD_RSER_TFFF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_TFFF_RE_SHIFT, SPI_RSER_TFFF_RE_WIDTH))

/*! @brief Set the TFFF_RE field to a new value. */
#define SPI_WR_RSER_TFFF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFFF_RE_MASK, SPI_RSER_TFFF_RE(value)))
#define SPI_BWR_RSER_TFFF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_TFFF_RE_SHIFT), SPI_RSER_TFFF_RE_SHIFT, SPI_RSER_TFFF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFUF_RE[27] (RW)
 *
 * Enables the TFUF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - TFUF interrupt requests are disabled.
 * - 1 - TFUF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFUF_RE field. */
#define SPI_RD_RSER_TFUF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TFUF_RE_MASK) >> SPI_RSER_TFUF_RE_SHIFT)
#define SPI_BRD_RSER_TFUF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_TFUF_RE_SHIFT, SPI_RSER_TFUF_RE_WIDTH))

/*! @brief Set the TFUF_RE field to a new value. */
#define SPI_WR_RSER_TFUF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFUF_RE_MASK, SPI_RSER_TFUF_RE(value)))
#define SPI_BWR_RSER_TFUF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_TFUF_RE_SHIFT), SPI_RSER_TFUF_RE_SHIFT, SPI_RSER_TFUF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field EOQF_RE[28] (RW)
 *
 * Enables the EOQF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - EOQF interrupt requests are disabled.
 * - 1 - EOQF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_EOQF_RE field. */
#define SPI_RD_RSER_EOQF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_EOQF_RE_MASK) >> SPI_RSER_EOQF_RE_SHIFT)
#define SPI_BRD_RSER_EOQF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_EOQF_RE_SHIFT, SPI_RSER_EOQF_RE_WIDTH))

/*! @brief Set the EOQF_RE field to a new value. */
#define SPI_WR_RSER_EOQF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_EOQF_RE_MASK, SPI_RSER_EOQF_RE(value)))
#define SPI_BWR_RSER_EOQF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_EOQF_RE_SHIFT), SPI_RSER_EOQF_RE_SHIFT, SPI_RSER_EOQF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field TCF_RE[31] (RW)
 *
 * Enables TCF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - TCF interrupt requests are disabled.
 * - 1 - TCF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TCF_RE field. */
#define SPI_RD_RSER_TCF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TCF_RE_MASK) >> SPI_RSER_TCF_RE_SHIFT)
#define SPI_BRD_RSER_TCF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_TCF_RE_SHIFT, SPI_RSER_TCF_RE_WIDTH))

/*! @brief Set the TCF_RE field to a new value. */
#define SPI_WR_RSER_TCF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TCF_RE_MASK, SPI_RSER_TCF_RE(value)))
#define SPI_BWR_RSER_TCF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_TCF_RE_SHIFT), SPI_RSER_TCF_RE_SHIFT, SPI_RSER_TCF_RE_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_PUSHR - PUSH TX FIFO Register In Master Mode
 ******************************************************************************/

/*!
 * @brief SPI_PUSHR - PUSH TX FIFO Register In Master Mode (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies data to be transferred to the TX FIFO and CMD FIFO. An 8- or 16-bit
 * write access to the TXDATA field transfers the 16 bits of data to the TX
 * FIFO. A write access to the command fields transfers the 16 bits of command
 * information to the CMD FIFO. In Master mode, the register transfers 16 bits of data
 * to the TX FIFO and 16 bits of command information to the CMD FIFO. In Slave
 * mode, the CMD FIFO is not used and the 16 bits of command information are
 * reserved. The TX FIFO and CMD FIFO must be filled simultaneously. In other words,
 * you must perform write accesses to both the data and command fields for every
 * PUSHR operation. Because both the TX FIFO and CMD FIFO are written to and read
 * from simultaneously, they behave as a single 32 bit FIFO. A read access of
 * PUSHR returns the topmost TX FIFO and CMD FIFO entries concatenated. When the
 * module is disabled, writing to this register does not update the FIFO. Therefore,
 * any reads performed while the module is disabled return the last PUSHR write
 * performed while the module was still enabled.
 */
/*!
 * @name Constants and macros for entire SPI_PUSHR register
 */
/*@{*/
#define SPI_RD_PUSHR(base)       (SPI_PUSHR_REG(base))
#define SPI_WR_PUSHR(base, value) (SPI_PUSHR_REG(base) = (value))
#define SPI_RMW_PUSHR(base, mask, value) (SPI_WR_PUSHR(base, (SPI_RD_PUSHR(base) & ~(mask)) | (value)))
#define SPI_SET_PUSHR(base, value) (BME_OR32(&SPI_PUSHR_REG(base), (uint32_t)(value)))
#define SPI_CLR_PUSHR(base, value) (BME_AND32(&SPI_PUSHR_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_PUSHR(base, value) (BME_XOR32(&SPI_PUSHR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_PUSHR bitfields
 */

/*!
 * @name Register SPI_PUSHR, field TXDATA[15:0] (RW)
 *
 * Holds SPI data to be transferred according to the associated SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_TXDATA field. */
#define SPI_RD_PUSHR_TXDATA(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_TXDATA_MASK) >> SPI_PUSHR_TXDATA_SHIFT)
#define SPI_BRD_PUSHR_TXDATA(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_TXDATA_SHIFT, SPI_PUSHR_TXDATA_WIDTH))

/*! @brief Set the TXDATA field to a new value. */
#define SPI_WR_PUSHR_TXDATA(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_TXDATA_MASK, SPI_PUSHR_TXDATA(value)))
#define SPI_BWR_PUSHR_TXDATA(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_TXDATA_SHIFT), SPI_PUSHR_TXDATA_SHIFT, SPI_PUSHR_TXDATA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field PCS[20:16] (RW)
 *
 * Select which PCS signals are to be asserted for the transfer. Refer to the
 * chip configuration details for the number of PCS signals used in this MCU.
 *
 * Values:
 * - 0 - Negate the PCS[x] signal.
 * - 1 - Assert the PCS[x] signal.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_PCS field. */
#define SPI_RD_PUSHR_PCS(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_PCS_MASK) >> SPI_PUSHR_PCS_SHIFT)
#define SPI_BRD_PUSHR_PCS(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_PCS_SHIFT, SPI_PUSHR_PCS_WIDTH))

/*! @brief Set the PCS field to a new value. */
#define SPI_WR_PUSHR_PCS(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_PCS_MASK, SPI_PUSHR_PCS(value)))
#define SPI_BWR_PUSHR_PCS(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_PCS_SHIFT), SPI_PUSHR_PCS_SHIFT, SPI_PUSHR_PCS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CTCNT[26] (RW)
 *
 * Clears the TCNT field in the TCR register. The TCNT field is cleared before
 * the module starts transmitting the current SPI frame.
 *
 * Values:
 * - 0 - Do not clear the TCR[TCNT] field.
 * - 1 - Clear the TCR[TCNT] field.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CTCNT field. */
#define SPI_RD_PUSHR_CTCNT(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CTCNT_MASK) >> SPI_PUSHR_CTCNT_SHIFT)
#define SPI_BRD_PUSHR_CTCNT(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_CTCNT_SHIFT, SPI_PUSHR_CTCNT_WIDTH))

/*! @brief Set the CTCNT field to a new value. */
#define SPI_WR_PUSHR_CTCNT(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CTCNT_MASK, SPI_PUSHR_CTCNT(value)))
#define SPI_BWR_PUSHR_CTCNT(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_CTCNT_SHIFT), SPI_PUSHR_CTCNT_SHIFT, SPI_PUSHR_CTCNT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field EOQ[27] (RW)
 *
 * Host software uses this bit to signal to the module that the current SPI
 * transfer is the last in a queue. At the end of the transfer, the EOQF bit in the
 * SR is set.
 *
 * Values:
 * - 0 - The SPI data is not the last data to transfer.
 * - 1 - The SPI data is the last data to transfer.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_EOQ field. */
#define SPI_RD_PUSHR_EOQ(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_EOQ_MASK) >> SPI_PUSHR_EOQ_SHIFT)
#define SPI_BRD_PUSHR_EOQ(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_EOQ_SHIFT, SPI_PUSHR_EOQ_WIDTH))

/*! @brief Set the EOQ field to a new value. */
#define SPI_WR_PUSHR_EOQ(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_EOQ_MASK, SPI_PUSHR_EOQ(value)))
#define SPI_BWR_PUSHR_EOQ(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_EOQ_SHIFT), SPI_PUSHR_EOQ_SHIFT, SPI_PUSHR_EOQ_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CTAS[30:28] (RW)
 *
 * Selects which CTAR to use in master mode to specify the transfer attributes
 * for the associated SPI frame. In SPI Slave mode, CTAR0 is used. See the chip
 * configuration details to determine how many CTARs this device has. You should
 * not program a value in this field for a register that is not present.
 *
 * Values:
 * - 000 - CTAR0
 * - 001 - CTAR1
 * - 010 - Reserved
 * - 011 - Reserved
 * - 100 - Reserved
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CTAS field. */
#define SPI_RD_PUSHR_CTAS(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CTAS_MASK) >> SPI_PUSHR_CTAS_SHIFT)
#define SPI_BRD_PUSHR_CTAS(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_CTAS_SHIFT, SPI_PUSHR_CTAS_WIDTH))

/*! @brief Set the CTAS field to a new value. */
#define SPI_WR_PUSHR_CTAS(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CTAS_MASK, SPI_PUSHR_CTAS(value)))
#define SPI_BWR_PUSHR_CTAS(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_CTAS_SHIFT), SPI_PUSHR_CTAS_SHIFT, SPI_PUSHR_CTAS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CONT[31] (RW)
 *
 * Selects a continuous selection format. The bit is used in SPI Master mode.
 * The bit enables the selected PCS signals to remain asserted between transfers.
 *
 * Values:
 * - 0 - Return PCSn signals to their inactive state between transfers.
 * - 1 - Keep PCSn signals asserted between transfers.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CONT field. */
#define SPI_RD_PUSHR_CONT(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CONT_MASK) >> SPI_PUSHR_CONT_SHIFT)
#define SPI_BRD_PUSHR_CONT(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_CONT_SHIFT, SPI_PUSHR_CONT_WIDTH))

/*! @brief Set the CONT field to a new value. */
#define SPI_WR_PUSHR_CONT(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CONT_MASK, SPI_PUSHR_CONT(value)))
#define SPI_BWR_PUSHR_CONT(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_CONT_SHIFT), SPI_PUSHR_CONT_SHIFT, SPI_PUSHR_CONT_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode
 ******************************************************************************/

/*!
 * @brief SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies data to be transferred to the TX FIFO. An 8- or 16-bit write access
 * to PUSHR transfers the 16-bit TXDATA field to the TX FIFO. In master mode,
 * the register transfers the 16 bits of command information to the CMD FIFO and
 * the 16-bit TXDATA field to the TX FIFO. In slave mode, the CMD FIFO is not used
 * and the 16 bits of command information in PUSHR are reserved.
 */
/*!
 * @name Constants and macros for entire SPI_PUSHR_SLAVE register
 */
/*@{*/
#define SPI_RD_PUSHR_SLAVE(base) (SPI_PUSHR_SLAVE_REG(base))
#define SPI_WR_PUSHR_SLAVE(base, value) (SPI_PUSHR_SLAVE_REG(base) = (value))
#define SPI_RMW_PUSHR_SLAVE(base, mask, value) (SPI_WR_PUSHR_SLAVE(base, (SPI_RD_PUSHR_SLAVE(base) & ~(mask)) | (value)))
#define SPI_SET_PUSHR_SLAVE(base, value) (BME_OR32(&SPI_PUSHR_SLAVE_REG(base), (uint32_t)(value)))
#define SPI_CLR_PUSHR_SLAVE(base, value) (BME_AND32(&SPI_PUSHR_SLAVE_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_PUSHR_SLAVE(base, value) (BME_XOR32(&SPI_PUSHR_SLAVE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_PUSHR_SLAVE bitfields
 */

/*!
 * @name Register SPI_PUSHR_SLAVE, field TXDATA[15:0] (RW)
 *
 * Holds SPI data to be transferred according to the associated SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_SLAVE_TXDATA field. */
#define SPI_RD_PUSHR_SLAVE_TXDATA(base) ((SPI_PUSHR_SLAVE_REG(base) & SPI_PUSHR_SLAVE_TXDATA_MASK) >> SPI_PUSHR_SLAVE_TXDATA_SHIFT)
#define SPI_BRD_PUSHR_SLAVE_TXDATA(base) (BME_UBFX32(&SPI_PUSHR_SLAVE_REG(base), SPI_PUSHR_SLAVE_TXDATA_SHIFT, SPI_PUSHR_SLAVE_TXDATA_WIDTH))

/*! @brief Set the TXDATA field to a new value. */
#define SPI_WR_PUSHR_SLAVE_TXDATA(base, value) (SPI_RMW_PUSHR_SLAVE(base, SPI_PUSHR_SLAVE_TXDATA_MASK, SPI_PUSHR_SLAVE_TXDATA(value)))
#define SPI_BWR_PUSHR_SLAVE_TXDATA(base, value) (BME_BFI32(&SPI_PUSHR_SLAVE_REG(base), ((uint32_t)(value) << SPI_PUSHR_SLAVE_TXDATA_SHIFT), SPI_PUSHR_SLAVE_TXDATA_SHIFT, SPI_PUSHR_SLAVE_TXDATA_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_POPR - POP RX FIFO Register
 ******************************************************************************/

/*!
 * @brief SPI_POPR - POP RX FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * POPR is used to read the RX FIFO. Eight- or sixteen-bit read accesses to the
 * POPR have the same effect on the RX FIFO as 32-bit read accesses. A write to
 * this register will generate a Transfer Error.
 */
/*!
 * @name Constants and macros for entire SPI_POPR register
 */
/*@{*/
#define SPI_RD_POPR(base)        (SPI_POPR_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR0 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR0 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR0 register
 */
/*@{*/
#define SPI_RD_TXFR0(base)       (SPI_TXFR0_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR0 bitfields
 */

/*!
 * @name Register SPI_TXFR0, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR0_TXDATA field. */
#define SPI_RD_TXFR0_TXDATA(base) ((SPI_TXFR0_REG(base) & SPI_TXFR0_TXDATA_MASK) >> SPI_TXFR0_TXDATA_SHIFT)
#define SPI_BRD_TXFR0_TXDATA(base) (BME_UBFX32(&SPI_TXFR0_REG(base), SPI_TXFR0_TXDATA_SHIFT, SPI_TXFR0_TXDATA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_TXFR0, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, this field is reserved.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR0_TXCMD_TXDATA field. */
#define SPI_RD_TXFR0_TXCMD_TXDATA(base) ((SPI_TXFR0_REG(base) & SPI_TXFR0_TXCMD_TXDATA_MASK) >> SPI_TXFR0_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR0_TXCMD_TXDATA(base) (BME_UBFX32(&SPI_TXFR0_REG(base), SPI_TXFR0_TXCMD_TXDATA_SHIFT, SPI_TXFR0_TXCMD_TXDATA_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_TXFR1 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR1 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR1 register
 */
/*@{*/
#define SPI_RD_TXFR1(base)       (SPI_TXFR1_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR1 bitfields
 */

/*!
 * @name Register SPI_TXFR1, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR1_TXDATA field. */
#define SPI_RD_TXFR1_TXDATA(base) ((SPI_TXFR1_REG(base) & SPI_TXFR1_TXDATA_MASK) >> SPI_TXFR1_TXDATA_SHIFT)
#define SPI_BRD_TXFR1_TXDATA(base) (BME_UBFX32(&SPI_TXFR1_REG(base), SPI_TXFR1_TXDATA_SHIFT, SPI_TXFR1_TXDATA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_TXFR1, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, this field is reserved.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR1_TXCMD_TXDATA field. */
#define SPI_RD_TXFR1_TXCMD_TXDATA(base) ((SPI_TXFR1_REG(base) & SPI_TXFR1_TXCMD_TXDATA_MASK) >> SPI_TXFR1_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR1_TXCMD_TXDATA(base) (BME_UBFX32(&SPI_TXFR1_REG(base), SPI_TXFR1_TXCMD_TXDATA_SHIFT, SPI_TXFR1_TXCMD_TXDATA_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_TXFR2 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR2 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR2 register
 */
/*@{*/
#define SPI_RD_TXFR2(base)       (SPI_TXFR2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR2 bitfields
 */

/*!
 * @name Register SPI_TXFR2, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR2_TXDATA field. */
#define SPI_RD_TXFR2_TXDATA(base) ((SPI_TXFR2_REG(base) & SPI_TXFR2_TXDATA_MASK) >> SPI_TXFR2_TXDATA_SHIFT)
#define SPI_BRD_TXFR2_TXDATA(base) (BME_UBFX32(&SPI_TXFR2_REG(base), SPI_TXFR2_TXDATA_SHIFT, SPI_TXFR2_TXDATA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_TXFR2, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, this field is reserved.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR2_TXCMD_TXDATA field. */
#define SPI_RD_TXFR2_TXCMD_TXDATA(base) ((SPI_TXFR2_REG(base) & SPI_TXFR2_TXCMD_TXDATA_MASK) >> SPI_TXFR2_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR2_TXCMD_TXDATA(base) (BME_UBFX32(&SPI_TXFR2_REG(base), SPI_TXFR2_TXCMD_TXDATA_SHIFT, SPI_TXFR2_TXCMD_TXDATA_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_TXFR3 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR3 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR3 register
 */
/*@{*/
#define SPI_RD_TXFR3(base)       (SPI_TXFR3_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR3 bitfields
 */

/*!
 * @name Register SPI_TXFR3, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR3_TXDATA field. */
#define SPI_RD_TXFR3_TXDATA(base) ((SPI_TXFR3_REG(base) & SPI_TXFR3_TXDATA_MASK) >> SPI_TXFR3_TXDATA_SHIFT)
#define SPI_BRD_TXFR3_TXDATA(base) (BME_UBFX32(&SPI_TXFR3_REG(base), SPI_TXFR3_TXDATA_SHIFT, SPI_TXFR3_TXDATA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_TXFR3, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, this field is reserved.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR3_TXCMD_TXDATA field. */
#define SPI_RD_TXFR3_TXCMD_TXDATA(base) ((SPI_TXFR3_REG(base) & SPI_TXFR3_TXCMD_TXDATA_MASK) >> SPI_TXFR3_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR3_TXCMD_TXDATA(base) (BME_UBFX32(&SPI_TXFR3_REG(base), SPI_TXFR3_TXCMD_TXDATA_SHIFT, SPI_TXFR3_TXCMD_TXDATA_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_RXFR0 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR0 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR0 register
 */
/*@{*/
#define SPI_RD_RXFR0(base)       (SPI_RXFR0_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR1 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR1 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR1 register
 */
/*@{*/
#define SPI_RD_RXFR1(base)       (SPI_RXFR1_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR2 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR2 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR2 register
 */
/*@{*/
#define SPI_RD_RXFR2(base)       (SPI_RXFR2_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR3 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR3 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR3 register
 */
/*@{*/
#define SPI_RD_RXFR3(base)       (SPI_RXFR3_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_SREX - Status Register Extended
 ******************************************************************************/

/*!
 * @brief SPI_SREX - Status Register Extended (RW)
 *
 * Reset value: 0x00000000U
 *
 * The register contains status fields. The fields reflect the status of the
 * module and indicate the occurrence of events. This register is not writable.
 */
/*!
 * @name Constants and macros for entire SPI_SREX register
 */
/*@{*/
#define SPI_RD_SREX(base)        (SPI_SREX_REG(base))
#define SPI_WR_SREX(base, value) (SPI_SREX_REG(base) = (value))
#define SPI_RMW_SREX(base, mask, value) (SPI_WR_SREX(base, (SPI_RD_SREX(base) & ~(mask)) | (value)))
#define SPI_SET_SREX(base, value) (BME_OR32(&SPI_SREX_REG(base), (uint32_t)(value)))
#define SPI_CLR_SREX(base, value) (BME_AND32(&SPI_SREX_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_SREX(base, value) (BME_XOR32(&SPI_SREX_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_SREX bitfields
 */

/*!
 * @name Register SPI_SREX, field CMDNXTPTR[3:0] (RO)
 *
 * Indicates which CMD FIFO Entry is used during the next transfer. The
 * CMDNXTPTR field is updated every time SPI data due to current command have been
 * transmitted.
 */
/*@{*/
/*! @brief Read current value of the SPI_SREX_CMDNXTPTR field. */
#define SPI_RD_SREX_CMDNXTPTR(base) ((SPI_SREX_REG(base) & SPI_SREX_CMDNXTPTR_MASK) >> SPI_SREX_CMDNXTPTR_SHIFT)
#define SPI_BRD_SREX_CMDNXTPTR(base) (BME_UBFX32(&SPI_SREX_REG(base), SPI_SREX_CMDNXTPTR_SHIFT, SPI_SREX_CMDNXTPTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SREX, field CMDCTR[8:4] (RO)
 *
 * Indicates the number of entries in the CMD FIFO. The CMDCTR is incremented
 * every time the command part of PUSHR is written. The CMDCTR is decremented every
 * time a SPI command is executed (all data frames due to current command frame
 * have been transmitted).
 */
/*@{*/
/*! @brief Read current value of the SPI_SREX_CMDCTR field. */
#define SPI_RD_SREX_CMDCTR(base) ((SPI_SREX_REG(base) & SPI_SREX_CMDCTR_MASK) >> SPI_SREX_CMDCTR_SHIFT)
#define SPI_BRD_SREX_CMDCTR(base) (BME_UBFX32(&SPI_SREX_REG(base), SPI_SREX_CMDCTR_SHIFT, SPI_SREX_CMDCTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SREX, field TXCTR4[11] (RW)
 *
 * This bit is an extension of SR[TXCTR]. The concatenated field {TXCTR4, TXCTR}
 * indicates the number of valid entries in the TX FIFO. This field is
 * incremented every time the PUSHR is written. And this field is decremented every time
 * an SPI command is executed and the SPI data is transferred to the shift
 * register.
 */
/*@{*/
/*! @brief Read current value of the SPI_SREX_TXCTR4 field. */
#define SPI_RD_SREX_TXCTR4(base) ((SPI_SREX_REG(base) & SPI_SREX_TXCTR4_MASK) >> SPI_SREX_TXCTR4_SHIFT)
#define SPI_BRD_SREX_TXCTR4(base) (BME_UBFX32(&SPI_SREX_REG(base), SPI_SREX_TXCTR4_SHIFT, SPI_SREX_TXCTR4_WIDTH))

/*! @brief Set the TXCTR4 field to a new value. */
#define SPI_WR_SREX_TXCTR4(base, value) (SPI_RMW_SREX(base, SPI_SREX_TXCTR4_MASK, SPI_SREX_TXCTR4(value)))
#define SPI_BWR_SREX_TXCTR4(base, value) (BME_BFI32(&SPI_SREX_REG(base), ((uint32_t)(value) << SPI_SREX_TXCTR4_SHIFT), SPI_SREX_TXCTR4_SHIFT, SPI_SREX_TXCTR4_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SREX, field RXCTR4[14] (RW)
 *
 * This bit is an extension of SR[RXCTR]. The concatenated field {RXCTR4, RXCTR}
 * indicates the number of entries in the RX FIFO. This field is decremented
 * every time the POPR is read. And this field is incremented every time data is
 * transferred from the shift register to the RX FIFO.
 */
/*@{*/
/*! @brief Read current value of the SPI_SREX_RXCTR4 field. */
#define SPI_RD_SREX_RXCTR4(base) ((SPI_SREX_REG(base) & SPI_SREX_RXCTR4_MASK) >> SPI_SREX_RXCTR4_SHIFT)
#define SPI_BRD_SREX_RXCTR4(base) (BME_UBFX32(&SPI_SREX_REG(base), SPI_SREX_RXCTR4_SHIFT, SPI_SREX_RXCTR4_WIDTH))

/*! @brief Set the RXCTR4 field to a new value. */
#define SPI_WR_SREX_RXCTR4(base, value) (SPI_RMW_SREX(base, SPI_SREX_RXCTR4_MASK, SPI_SREX_RXCTR4(value)))
#define SPI_BWR_SREX_RXCTR4(base, value) (BME_BFI32(&SPI_SREX_REG(base), ((uint32_t)(value) << SPI_SREX_RXCTR4_SHIFT), SPI_SREX_RXCTR4_SHIFT, SPI_SREX_RXCTR4_WIDTH))
/*@}*/

/*
 * MKV10Z7 UART
 *
 * Serial Communication Interface
 *
 * Registers defined in this header file:
 * - UART_BDH - UART Baud Rate Registers: High
 * - UART_BDL - UART Baud Rate Registers: Low
 * - UART_C1 - UART Control Register 1
 * - UART_C2 - UART Control Register 2
 * - UART_S1 - UART Status Register 1
 * - UART_S2 - UART Status Register 2
 * - UART_C3 - UART Control Register 3
 * - UART_D - UART Data Register
 * - UART_MA1 - UART Match Address Registers 1
 * - UART_MA2 - UART Match Address Registers 2
 * - UART_C4 - UART Control Register 4
 * - UART_C5 - UART Control Register 5
 * - UART_ED - UART Extended Data Register
 * - UART_MODEM - UART Modem Register
 * - UART_PFIFO - UART FIFO Parameters
 * - UART_CFIFO - UART FIFO Control Register
 * - UART_SFIFO - UART FIFO Status Register
 * - UART_TWFIFO - UART FIFO Transmit Watermark
 * - UART_TCFIFO - UART FIFO Transmit Count
 * - UART_RWFIFO - UART FIFO Receive Watermark
 * - UART_RCFIFO - UART FIFO Receive Count
 */

#define UART_INSTANCE_COUNT (2U) /*!< Number of instances of the UART module. */
#define UART0_IDX (0U) /*!< Instance number for UART0. */
#define UART1_IDX (1U) /*!< Instance number for UART1. */

/*******************************************************************************
 * UART_BDH - UART Baud Rate Registers: High
 ******************************************************************************/

/*!
 * @brief UART_BDH - UART Baud Rate Registers: High (RW)
 *
 * Reset value: 0x00U
 *
 * This register, along with the BDL register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting
 * (SBR[12:0]), first write to BDH to buffer the high half of the new value and then write
 * to BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is,
 * when C2[RE] or C2[TE] is set.
 */
/*!
 * @name Constants and macros for entire UART_BDH register
 */
/*@{*/
#define UART_RD_BDH(base)        (UART_BDH_REG(base))
#define UART_WR_BDH(base, value) (UART_BDH_REG(base) = (value))
#define UART_RMW_BDH(base, mask, value) (UART_WR_BDH(base, (UART_RD_BDH(base) & ~(mask)) | (value)))
#define UART_SET_BDH(base, value) (BME_OR8(&UART_BDH_REG(base), (uint8_t)(value)))
#define UART_CLR_BDH(base, value) (BME_AND8(&UART_BDH_REG(base), (uint8_t)(~(value))))
#define UART_TOG_BDH(base, value) (BME_XOR8(&UART_BDH_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_BDH bitfields
 */

/*!
 * @name Register UART_BDH, field SBR[4:0] (RW)
 *
 * The baud rate for the UART is determined by the 13 SBR fields. See Baud rate
 * generation for details. The baud rate generator is disabled until C2[TE] or
 * C2[RE] is set for the first time after reset.The baud rate generator is disabled
 * when SBR = 0. Writing to BDH has no effect without writing to BDL, because
 * writing to BDH puts the data in a temporary location until BDL is written.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_SBR field. */
#define UART_RD_BDH_SBR(base) ((UART_BDH_REG(base) & UART_BDH_SBR_MASK) >> UART_BDH_SBR_SHIFT)
#define UART_BRD_BDH_SBR(base) (BME_UBFX8(&UART_BDH_REG(base), UART_BDH_SBR_SHIFT, UART_BDH_SBR_WIDTH))

/*! @brief Set the SBR field to a new value. */
#define UART_WR_BDH_SBR(base, value) (UART_RMW_BDH(base, UART_BDH_SBR_MASK, UART_BDH_SBR(value)))
#define UART_BWR_BDH_SBR(base, value) (BME_BFI8(&UART_BDH_REG(base), ((uint8_t)(value) << UART_BDH_SBR_SHIFT), UART_BDH_SBR_SHIFT, UART_BDH_SBR_WIDTH))
/*@}*/

/*!
 * @name Register UART_BDH, field SBNS[5] (RW)
 *
 * SBNS selects the number of stop bits present in a data frame. This field
 * valid for all 8, 9 and 10 bit data formats available.
 *
 * Values:
 * - 0 - Data frame consists of a single stop bit.
 * - 1 - Data frame consists of two stop bits.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_SBNS field. */
#define UART_RD_BDH_SBNS(base) ((UART_BDH_REG(base) & UART_BDH_SBNS_MASK) >> UART_BDH_SBNS_SHIFT)
#define UART_BRD_BDH_SBNS(base) (BME_UBFX8(&UART_BDH_REG(base), UART_BDH_SBNS_SHIFT, UART_BDH_SBNS_WIDTH))

/*! @brief Set the SBNS field to a new value. */
#define UART_WR_BDH_SBNS(base, value) (UART_RMW_BDH(base, UART_BDH_SBNS_MASK, UART_BDH_SBNS(value)))
#define UART_BWR_BDH_SBNS(base, value) (BME_BFI8(&UART_BDH_REG(base), ((uint8_t)(value) << UART_BDH_SBNS_SHIFT), UART_BDH_SBNS_SHIFT, UART_BDH_SBNS_WIDTH))
/*@}*/

/*!
 * @name Register UART_BDH, field RXEDGIE[6] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - Hardware interrupts from RXEDGIF disabled using polling.
 * - 1 - RXEDGIF interrupt request enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_RXEDGIE field. */
#define UART_RD_BDH_RXEDGIE(base) ((UART_BDH_REG(base) & UART_BDH_RXEDGIE_MASK) >> UART_BDH_RXEDGIE_SHIFT)
#define UART_BRD_BDH_RXEDGIE(base) (BME_UBFX8(&UART_BDH_REG(base), UART_BDH_RXEDGIE_SHIFT, UART_BDH_RXEDGIE_WIDTH))

/*! @brief Set the RXEDGIE field to a new value. */
#define UART_WR_BDH_RXEDGIE(base, value) (UART_RMW_BDH(base, UART_BDH_RXEDGIE_MASK, UART_BDH_RXEDGIE(value)))
#define UART_BWR_BDH_RXEDGIE(base, value) (BME_BFI8(&UART_BDH_REG(base), ((uint8_t)(value) << UART_BDH_RXEDGIE_SHIFT), UART_BDH_RXEDGIE_SHIFT, UART_BDH_RXEDGIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_BDH, field LBKDIE[7] (RW)
 *
 * Enables the LIN break detect flag, LBKDIF, to generate interrupt requests,
 *
 * Values:
 * - 0 - LBKDIF interrupt requests disabled.
 * - 1 - LBKDIF interrupt requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_LBKDIE field. */
#define UART_RD_BDH_LBKDIE(base) ((UART_BDH_REG(base) & UART_BDH_LBKDIE_MASK) >> UART_BDH_LBKDIE_SHIFT)
#define UART_BRD_BDH_LBKDIE(base) (BME_UBFX8(&UART_BDH_REG(base), UART_BDH_LBKDIE_SHIFT, UART_BDH_LBKDIE_WIDTH))

/*! @brief Set the LBKDIE field to a new value. */
#define UART_WR_BDH_LBKDIE(base, value) (UART_RMW_BDH(base, UART_BDH_LBKDIE_MASK, UART_BDH_LBKDIE(value)))
#define UART_BWR_BDH_LBKDIE(base, value) (BME_BFI8(&UART_BDH_REG(base), ((uint8_t)(value) << UART_BDH_LBKDIE_SHIFT), UART_BDH_LBKDIE_SHIFT, UART_BDH_LBKDIE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_BDL - UART Baud Rate Registers: Low
 ******************************************************************************/

/*!
 * @brief UART_BDL - UART Baud Rate Registers: Low (RW)
 *
 * Reset value: 0x04U
 *
 * This register, along with the BDH register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting, SBR[12:0],
 * first write to BDH to buffer the high half of the new value and then write to
 * BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is, when
 * C2[RE] or C2[TE] is set.
 */
/*!
 * @name Constants and macros for entire UART_BDL register
 */
/*@{*/
#define UART_RD_BDL(base)        (UART_BDL_REG(base))
#define UART_WR_BDL(base, value) (UART_BDL_REG(base) = (value))
#define UART_RMW_BDL(base, mask, value) (UART_WR_BDL(base, (UART_RD_BDL(base) & ~(mask)) | (value)))
#define UART_SET_BDL(base, value) (BME_OR8(&UART_BDL_REG(base), (uint8_t)(value)))
#define UART_CLR_BDL(base, value) (BME_AND8(&UART_BDL_REG(base), (uint8_t)(~(value))))
#define UART_TOG_BDL(base, value) (BME_XOR8(&UART_BDL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_C1 - UART Control Register 1
 ******************************************************************************/

/*!
 * @brief UART_C1 - UART Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register controls various optional features of the UART
 * system.
 */
/*!
 * @name Constants and macros for entire UART_C1 register
 */
/*@{*/
#define UART_RD_C1(base)         (UART_C1_REG(base))
#define UART_WR_C1(base, value)  (UART_C1_REG(base) = (value))
#define UART_RMW_C1(base, mask, value) (UART_WR_C1(base, (UART_RD_C1(base) & ~(mask)) | (value)))
#define UART_SET_C1(base, value) (BME_OR8(&UART_C1_REG(base), (uint8_t)(value)))
#define UART_CLR_C1(base, value) (BME_AND8(&UART_C1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C1(base, value) (BME_XOR8(&UART_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C1 bitfields
 */

/*!
 * @name Register UART_C1, field PT[0] (RW)
 *
 * Determines whether the UART generates and checks for even parity or odd
 * parity. With even parity, an even number of 1s clears the parity bit and an odd
 * number of 1s sets the parity bit. With odd parity, an odd number of 1s clears the
 * parity bit and an even number of 1s sets the parity bit.
 *
 * Values:
 * - 0 - Even parity.
 * - 1 - Odd parity.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_PT field. */
#define UART_RD_C1_PT(base)  ((UART_C1_REG(base) & UART_C1_PT_MASK) >> UART_C1_PT_SHIFT)
#define UART_BRD_C1_PT(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_PT_SHIFT, UART_C1_PT_WIDTH))

/*! @brief Set the PT field to a new value. */
#define UART_WR_C1_PT(base, value) (UART_RMW_C1(base, UART_C1_PT_MASK, UART_C1_PT(value)))
#define UART_BWR_C1_PT(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_PT_SHIFT), UART_C1_PT_SHIFT, UART_C1_PT_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field PE[1] (RW)
 *
 * Enables the parity function. When parity is enabled, parity function inserts
 * a parity bit in the bit position immediately preceding the stop bit.
 *
 * Values:
 * - 0 - Parity function disabled.
 * - 1 - Parity function enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_PE field. */
#define UART_RD_C1_PE(base)  ((UART_C1_REG(base) & UART_C1_PE_MASK) >> UART_C1_PE_SHIFT)
#define UART_BRD_C1_PE(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_PE_SHIFT, UART_C1_PE_WIDTH))

/*! @brief Set the PE field to a new value. */
#define UART_WR_C1_PE(base, value) (UART_RMW_C1(base, UART_C1_PE_MASK, UART_C1_PE(value)))
#define UART_BWR_C1_PE(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_PE_SHIFT), UART_C1_PE_SHIFT, UART_C1_PE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the UART is programmed with ILT = 1, a
 * logic of 1'b0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count. In case the UART is programmed for IDLE line wakeup
 * (RWU = 1 and WAKE = 0), ILT has no effect on when the receiver starts counting
 * logic 1s as idle character bits. In idle line wakeup, an idle character is
 * recognized at anytime the receiver sees 10, 11, or 12 1s depending on the M, PE,
 * and C4[M10] fields.
 *
 * Values:
 * - 0 - Idle character bit count starts after start bit.
 * - 1 - Idle character bit count starts after stop bit.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_ILT field. */
#define UART_RD_C1_ILT(base) ((UART_C1_REG(base) & UART_C1_ILT_MASK) >> UART_C1_ILT_SHIFT)
#define UART_BRD_C1_ILT(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_ILT_SHIFT, UART_C1_ILT_WIDTH))

/*! @brief Set the ILT field to a new value. */
#define UART_WR_C1_ILT(base, value) (UART_RMW_C1(base, UART_C1_ILT_MASK, UART_C1_ILT(value)))
#define UART_BWR_C1_ILT(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_ILT_SHIFT), UART_C1_ILT_SHIFT, UART_C1_ILT_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field WAKE[3] (RW)
 *
 * Determines which condition wakes the UART: Address mark in the most
 * significant bit position of a received data character, or An idle condition on the
 * receive pin input signal.
 *
 * Values:
 * - 0 - Idle line wakeup.
 * - 1 - Address mark wakeup.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_WAKE field. */
#define UART_RD_C1_WAKE(base) ((UART_C1_REG(base) & UART_C1_WAKE_MASK) >> UART_C1_WAKE_SHIFT)
#define UART_BRD_C1_WAKE(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_WAKE_SHIFT, UART_C1_WAKE_WIDTH))

/*! @brief Set the WAKE field to a new value. */
#define UART_WR_C1_WAKE(base, value) (UART_RMW_C1(base, UART_C1_WAKE_MASK, UART_C1_WAKE(value)))
#define UART_BWR_C1_WAKE(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_WAKE_SHIFT), UART_C1_WAKE_SHIFT, UART_C1_WAKE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field M[4] (RW)
 *
 * Values:
 * - 0 - Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) + stop.
 * - 1 - Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_M field. */
#define UART_RD_C1_M(base)   ((UART_C1_REG(base) & UART_C1_M_MASK) >> UART_C1_M_SHIFT)
#define UART_BRD_C1_M(base)  (BME_UBFX8(&UART_C1_REG(base), UART_C1_M_SHIFT, UART_C1_M_WIDTH))

/*! @brief Set the M field to a new value. */
#define UART_WR_C1_M(base, value) (UART_RMW_C1(base, UART_C1_M_MASK, UART_C1_M(value)))
#define UART_BWR_C1_M(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_M_SHIFT), UART_C1_M_SHIFT, UART_C1_M_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0 - Selects internal loop back mode. The receiver input is internally
 *     connected to transmitter output.
 * - 1 - Single wire UART mode where the receiver input is connected to the
 *     transmit pin input signal.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_RSRC field. */
#define UART_RD_C1_RSRC(base) ((UART_C1_REG(base) & UART_C1_RSRC_MASK) >> UART_C1_RSRC_SHIFT)
#define UART_BRD_C1_RSRC(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_RSRC_SHIFT, UART_C1_RSRC_WIDTH))

/*! @brief Set the RSRC field to a new value. */
#define UART_WR_C1_RSRC(base, value) (UART_RMW_C1(base, UART_C1_RSRC_MASK, UART_C1_RSRC(value)))
#define UART_BWR_C1_RSRC(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_RSRC_SHIFT), UART_C1_RSRC_SHIFT, UART_C1_RSRC_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field UARTSWAI[6] (RW)
 *
 * Values:
 * - 0 - UART clock continues to run in Wait mode.
 * - 1 - UART clock freezes while CPU is in Wait mode.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_UARTSWAI field. */
#define UART_RD_C1_UARTSWAI(base) ((UART_C1_REG(base) & UART_C1_UARTSWAI_MASK) >> UART_C1_UARTSWAI_SHIFT)
#define UART_BRD_C1_UARTSWAI(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_UARTSWAI_SHIFT, UART_C1_UARTSWAI_WIDTH))

/*! @brief Set the UARTSWAI field to a new value. */
#define UART_WR_C1_UARTSWAI(base, value) (UART_RMW_C1(base, UART_C1_UARTSWAI_MASK, UART_C1_UARTSWAI(value)))
#define UART_BWR_C1_UARTSWAI(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_UARTSWAI_SHIFT), UART_C1_UARTSWAI_SHIFT, UART_C1_UARTSWAI_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the RxD pin is disconnected from the UART and the
 * transmitter output is internally connected to the receiver input. The transmitter and
 * the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - Loop mode where transmitter output is internally connected to receiver
 *     input. The receiver input is determined by RSRC.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_LOOPS field. */
#define UART_RD_C1_LOOPS(base) ((UART_C1_REG(base) & UART_C1_LOOPS_MASK) >> UART_C1_LOOPS_SHIFT)
#define UART_BRD_C1_LOOPS(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_LOOPS_SHIFT, UART_C1_LOOPS_WIDTH))

/*! @brief Set the LOOPS field to a new value. */
#define UART_WR_C1_LOOPS(base, value) (UART_RMW_C1(base, UART_C1_LOOPS_MASK, UART_C1_LOOPS(value)))
#define UART_BWR_C1_LOOPS(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_LOOPS_SHIFT), UART_C1_LOOPS_SHIFT, UART_C1_LOOPS_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_C2 - UART Control Register 2
 ******************************************************************************/

/*!
 * @brief UART_C2 - UART Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register can be read or written at any time.
 */
/*!
 * @name Constants and macros for entire UART_C2 register
 */
/*@{*/
#define UART_RD_C2(base)         (UART_C2_REG(base))
#define UART_WR_C2(base, value)  (UART_C2_REG(base) = (value))
#define UART_RMW_C2(base, mask, value) (UART_WR_C2(base, (UART_RD_C2(base) & ~(mask)) | (value)))
#define UART_SET_C2(base, value) (BME_OR8(&UART_C2_REG(base), (uint8_t)(value)))
#define UART_CLR_C2(base, value) (BME_AND8(&UART_C2_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C2(base, value) (BME_XOR8(&UART_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C2 bitfields
 */

/*!
 * @name Register UART_C2, field SBK[0] (RW)
 *
 * Toggling SBK sends one break character from the following: See Transmitting
 * break characters for the number of logic 0s for the different configurations.
 * Toggling implies clearing the SBK field before the break character has finished
 * transmitting. As long as SBK is set, the transmitter continues to send
 * complete break characters (10, 11, or 12 bits, or 13 or 14 bits). Ensure that C2[TE]
 * is asserted atleast 1 clock before assertion of this bit. 10, 11, or 12 logic
 * 0s if S2[BRK13] is cleared 13 or 14 logic 0s if S2[BRK13] is set.
 *
 * Values:
 * - 0 - Normal transmitter operation.
 * - 1 - Queue break characters to be sent.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_SBK field. */
#define UART_RD_C2_SBK(base) ((UART_C2_REG(base) & UART_C2_SBK_MASK) >> UART_C2_SBK_SHIFT)
#define UART_BRD_C2_SBK(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_SBK_SHIFT, UART_C2_SBK_WIDTH))

/*! @brief Set the SBK field to a new value. */
#define UART_WR_C2_SBK(base, value) (UART_RMW_C2(base, UART_C2_SBK_MASK, UART_C2_SBK(value)))
#define UART_BWR_C2_SBK(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_SBK_SHIFT), UART_C2_SBK_SHIFT, UART_C2_SBK_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field RWU[1] (RW)
 *
 * This field can be set to place the UART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * C1[WAKE] is clear or an address match when C1[WAKE] is set. RWU must be set only with
 * C1[WAKE] = 0 (wakeup on idle) if the channel is currently not idle. This can
 * be determined by S2[RAF]. If the flag is set to wake up an IDLE event and the
 * channel is already idle, it is possible that the UART will discard data. This
 * is because the data must be received or a LIN break detected after an IDLE is
 * detected before IDLE is allowed to reasserted.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - RWU enables the wakeup function and inhibits further receiver interrupt
 *     requests. Normally, hardware wakes the receiver by automatically clearing
 *     RWU.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RWU field. */
#define UART_RD_C2_RWU(base) ((UART_C2_REG(base) & UART_C2_RWU_MASK) >> UART_C2_RWU_SHIFT)
#define UART_BRD_C2_RWU(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_RWU_SHIFT, UART_C2_RWU_WIDTH))

/*! @brief Set the RWU field to a new value. */
#define UART_WR_C2_RWU(base, value) (UART_RMW_C2(base, UART_C2_RWU_MASK, UART_C2_RWU(value)))
#define UART_BWR_C2_RWU(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_RWU_SHIFT), UART_C2_RWU_SHIFT, UART_C2_RWU_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field RE[2] (RW)
 *
 * Enables the UART receiver.
 *
 * Values:
 * - 0 - Receiver off.
 * - 1 - Receiver on.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RE field. */
#define UART_RD_C2_RE(base)  ((UART_C2_REG(base) & UART_C2_RE_MASK) >> UART_C2_RE_SHIFT)
#define UART_BRD_C2_RE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_RE_SHIFT, UART_C2_RE_WIDTH))

/*! @brief Set the RE field to a new value. */
#define UART_WR_C2_RE(base, value) (UART_RMW_C2(base, UART_C2_RE_MASK, UART_C2_RE(value)))
#define UART_BWR_C2_RE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_RE_SHIFT), UART_C2_RE_SHIFT, UART_C2_RE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field TE[3] (RW)
 *
 * Enables the UART transmitter. TE can be used to queue an idle preamble by
 * clearing and then setting TE.
 *
 * Values:
 * - 0 - Transmitter off.
 * - 1 - Transmitter on.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TE field. */
#define UART_RD_C2_TE(base)  ((UART_C2_REG(base) & UART_C2_TE_MASK) >> UART_C2_TE_SHIFT)
#define UART_BRD_C2_TE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_TE_SHIFT, UART_C2_TE_WIDTH))

/*! @brief Set the TE field to a new value. */
#define UART_WR_C2_TE(base, value) (UART_RMW_C2(base, UART_C2_TE_MASK, UART_C2_TE(value)))
#define UART_BWR_C2_TE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_TE_SHIFT), UART_C2_TE_SHIFT, UART_C2_TE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field ILIE[4] (RW)
 *
 * Enables the idle line flag, S1[IDLE], to generate interrupt requests
 *
 * Values:
 * - 0 - IDLE interrupt requests disabled.
 * - 1 - IDLE interrupt requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_ILIE field. */
#define UART_RD_C2_ILIE(base) ((UART_C2_REG(base) & UART_C2_ILIE_MASK) >> UART_C2_ILIE_SHIFT)
#define UART_BRD_C2_ILIE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_ILIE_SHIFT, UART_C2_ILIE_WIDTH))

/*! @brief Set the ILIE field to a new value. */
#define UART_WR_C2_ILIE(base, value) (UART_RMW_C2(base, UART_C2_ILIE_MASK, UART_C2_ILIE(value)))
#define UART_BWR_C2_ILIE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_ILIE_SHIFT), UART_C2_ILIE_SHIFT, UART_C2_ILIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field RIE[5] (RW)
 *
 * Enables S1[RDRF] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[RDMAS].
 *
 * Values:
 * - 0 - RDRF interrupt and DMA transfer requests disabled.
 * - 1 - RDRF interrupt or DMA transfer requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RIE field. */
#define UART_RD_C2_RIE(base) ((UART_C2_REG(base) & UART_C2_RIE_MASK) >> UART_C2_RIE_SHIFT)
#define UART_BRD_C2_RIE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_RIE_SHIFT, UART_C2_RIE_WIDTH))

/*! @brief Set the RIE field to a new value. */
#define UART_WR_C2_RIE(base, value) (UART_RMW_C2(base, UART_C2_RIE_MASK, UART_C2_RIE(value)))
#define UART_BWR_C2_RIE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_RIE_SHIFT), UART_C2_RIE_SHIFT, UART_C2_RIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field TCIE[6] (RW)
 *
 * Enables the transmission complete flag, S1[TC], to generate interrupt
 * requests .
 *
 * Values:
 * - 0 - TC interrupt requests disabled.
 * - 1 - TC interrupt requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TCIE field. */
#define UART_RD_C2_TCIE(base) ((UART_C2_REG(base) & UART_C2_TCIE_MASK) >> UART_C2_TCIE_SHIFT)
#define UART_BRD_C2_TCIE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_TCIE_SHIFT, UART_C2_TCIE_WIDTH))

/*! @brief Set the TCIE field to a new value. */
#define UART_WR_C2_TCIE(base, value) (UART_RMW_C2(base, UART_C2_TCIE_MASK, UART_C2_TCIE(value)))
#define UART_BWR_C2_TCIE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_TCIE_SHIFT), UART_C2_TCIE_SHIFT, UART_C2_TCIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field TIE[7] (RW)
 *
 * Enables S1[TDRE] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[TDMAS]. If C2[TIE] and C5[TDMAS] are both set, then TCIE
 * must be cleared, and D[D] must not be written unless servicing a DMA request.
 *
 * Values:
 * - 0 - TDRE interrupt and DMA transfer requests disabled.
 * - 1 - TDRE interrupt or DMA transfer requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TIE field. */
#define UART_RD_C2_TIE(base) ((UART_C2_REG(base) & UART_C2_TIE_MASK) >> UART_C2_TIE_SHIFT)
#define UART_BRD_C2_TIE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_TIE_SHIFT, UART_C2_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define UART_WR_C2_TIE(base, value) (UART_RMW_C2(base, UART_C2_TIE_MASK, UART_C2_TIE(value)))
#define UART_BWR_C2_TIE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_TIE_SHIFT), UART_C2_TIE_SHIFT, UART_C2_TIE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_S1 - UART Status Register 1
 ******************************************************************************/

/*!
 * @brief UART_S1 - UART Status Register 1 (RO)
 *
 * Reset value: 0xC0U
 *
 * The S1 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. This register can also be polled by the MCU to check the
 * status of its fields. To clear a flag, the status register should be read followed
 * by a read or write to D register, depending on the interrupt flag type. Other
 * instructions can be executed between the two steps as long the handling of
 * I/O is not compromised, but the order of operations is important for flag
 * clearing. When a flag is configured to trigger a DMA request, assertion of the
 * associated DMA done signal from the DMA controller clears the flag. If the
 * condition that results in the assertion of the flag, interrupt, or DMA request is not
 * resolved prior to clearing the flag, the flag, and interrupt/DMA request,
 * reasserts. For example, if the DMA or interrupt service routine fails to write
 * sufficient data to the transmit buffer to raise it above the watermark level, the
 * flag reasserts and generates another interrupt or DMA request. Reading an
 * empty data register to clear one of the flags of the S1 register causes the FIFO
 * pointers to become misaligned. A receive FIFO flush reinitializes the
 * pointers. A better way to prevent this situation is to always leave one byte in FIFO
 * and this byte will be read eventually in clearing the flag bit.
 */
/*!
 * @name Constants and macros for entire UART_S1 register
 */
/*@{*/
#define UART_RD_S1(base)         (UART_S1_REG(base))
/*@}*/

/*
 * Constants & macros for individual UART_S1 bitfields
 */

/*!
 * @name Register UART_S1, field PF[0] (RO)
 *
 * PF is set when PE is set and the parity of the received data does not match
 * its parity bit. The PF is not set in the case of an overrun condition. When PF
 * is set, it indicates only that a dataword was received with parity error since
 * the last time it was cleared. There is no guarantee that the first dataword
 * read from the receive buffer has a parity error or that there is only one
 * dataword in the buffer that was received with a parity error, unless the receive
 * buffer has a depth of one. To clear PF, read S1 and then read D., S2[LBKDE] is
 * disabled, Within the receive buffer structure the received dataword is tagged
 * if it is received with a parity error. This information is available by reading
 * the ED register prior to reading the D register.
 *
 * Values:
 * - 0 - No parity error detected since the last time this flag was cleared. If
 *     the receive buffer has a depth greater than 1, then there may be data in
 *     the receive buffer what was received with a parity error.
 * - 1 - At least one dataword was received with a parity error since the last
 *     time this flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_PF field. */
#define UART_RD_S1_PF(base)  ((UART_S1_REG(base) & UART_S1_PF_MASK) >> UART_S1_PF_SHIFT)
#define UART_BRD_S1_PF(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_PF_SHIFT, UART_S1_PF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field FE[1] (RO)
 *
 * FE is set when a logic 0 is accepted as the stop bit. When BDH[SBNS] is set,
 * then FE will set when a logic 0 is accepted for either of the two stop bits.
 * FE does not set in the case of an overrun or while the LIN break detect feature
 * is enabled (S2[LBKDE] = 1). FE inhibits further data reception until it is
 * cleared. To clear FE, read S1 with FE set and then read D. The last data in the
 * receive buffer represents the data that was received with the frame error
 * enabled.
 *
 * Values:
 * - 0 - No framing error detected.
 * - 1 - Framing error.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_FE field. */
#define UART_RD_S1_FE(base)  ((UART_S1_REG(base) & UART_S1_FE_MASK) >> UART_S1_FE_SHIFT)
#define UART_BRD_S1_FE(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_FE_SHIFT, UART_S1_FE_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field NF[2] (RO)
 *
 * NF is set when the UART detects noise on the receiver input. NF does not
 * become set in the case of an overrun or while the LIN break detect feature is
 * enabled (S2[LBKDE] = 1). When NF is set, it indicates only that a dataword has
 * been received with noise since the last time it was cleared. There is no
 * guarantee that the first dataword read from the receive buffer has noise or that there
 * is only one dataword in the buffer that was received with noise unless the
 * receive buffer has a depth of one. To clear NF, read S1 and then read D.
 *
 * Values:
 * - 0 - No noise detected since the last time this flag was cleared. If the
 *     receive buffer has a depth greater than 1 then there may be data in the
 *     receiver buffer that was received with noise.
 * - 1 - At least one dataword was received with noise detected since the last
 *     time the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_NF field. */
#define UART_RD_S1_NF(base)  ((UART_S1_REG(base) & UART_S1_NF_MASK) >> UART_S1_NF_SHIFT)
#define UART_BRD_S1_NF(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_NF_SHIFT, UART_S1_NF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field OR[3] (RO)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the UART data registers is not
 * affected. If the OR flag is set, no data is stored in the data buffer even if
 * sufficient room exists. Additionally, while the OR flag is set, the RDRF and IDLE
 * flags are blocked from asserting, that is, transition from an inactive to an
 * active state. To clear OR, read S1 when OR is set and then read D. See
 * functional description for more details regarding the operation of the OR bit.If
 * LBKDE is enabled and a LIN Break is detected, the OR field asserts if S2[LBKDIF]
 * is not cleared before the next data character is received.
 *
 * Values:
 * - 0 - No overrun has occurred since the last time the flag was cleared.
 * - 1 - Overrun has occurred or the overrun flag has not been cleared since the
 *     last overrun occured.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_OR field. */
#define UART_RD_S1_OR(base)  ((UART_S1_REG(base) & UART_S1_OR_MASK) >> UART_S1_OR_SHIFT)
#define UART_BRD_S1_OR(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_OR_SHIFT, UART_S1_OR_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field IDLE[4] (RO)
 *
 * After the IDLE flag is cleared, a frame must be received (although not
 * necessarily stored in the data buffer, for example if C2[RWU] is set), or a LIN
 * break character must set the S2[LBKDIF] flag before an idle condition can set the
 * IDLE flag. To clear IDLE, read UART status S1 with IDLE set and then read D.
 * IDLE is set when either of the following appear on the receiver input: 10
 * consecutive logic 1s if C1[M] = 0 11 consecutive logic 1s if C1[M] = 1 and C4[M10]
 * = 0 12 consecutive logic 1s if C1[M] = 1, C4[M10] = 1, and C1[PE] = 1 When RWU
 * is set and WAKE is cleared, an idle line condition sets the IDLE flag if
 * RWUID is set, else the IDLE flag does not become set.
 *
 * Values:
 * - 0 - Receiver input is either active now or has never become active since
 *     the IDLE flag was last cleared.
 * - 1 - Receiver input has become idle or the flag has not been cleared since
 *     it last asserted.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_IDLE field. */
#define UART_RD_S1_IDLE(base) ((UART_S1_REG(base) & UART_S1_IDLE_MASK) >> UART_S1_IDLE_SHIFT)
#define UART_BRD_S1_IDLE(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_IDLE_SHIFT, UART_S1_IDLE_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field RDRF[5] (RO)
 *
 * RDRF is set when the number of datawords in the receive buffer is equal to or
 * more than the number indicated by RWFIFO[RXWATER]. A dataword that is in the
 * process of being received is not included in the count. To clear RDRF, read S1
 * when RDRF is set and then read D. For more efficient interrupt and DMA
 * operation, read all data except the final value from the buffer, using D/C3[T8]/ED.
 * Then read S1 and the final data value, resulting in the clearing of the RDRF
 * flag. Even if RDRF is set, data will continue to be received until an overrun
 * condition occurs.RDRF is prevented from setting while S2[LBKDE] is set.
 * Additionally, when S2[LBKDE] is set, the received datawords are stored in the receive
 * buffer but over-write each other.
 *
 * Values:
 * - 0 - The number of datawords in the receive buffer is less than the number
 *     indicated by RXWATER.
 * - 1 - The number of datawords in the receive buffer is equal to or greater
 *     than the number indicated by RXWATER at some point in time since this flag
 *     was last cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_RDRF field. */
#define UART_RD_S1_RDRF(base) ((UART_S1_REG(base) & UART_S1_RDRF_MASK) >> UART_S1_RDRF_SHIFT)
#define UART_BRD_S1_RDRF(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_RDRF_SHIFT, UART_S1_RDRF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field TC[6] (RO)
 *
 * TC is set when the transmit buffer is empty and no data, preamble, or break
 * character is being transmitted. When TC is set, the transmit data output signal
 * becomes idle (logic 1). TC is cleared by reading S1 with TC set and then
 * doing one of the following: Writing to D to transmit new data. Queuing a preamble
 * by clearing and then setting C2[TE]. Queuing a break character by writing 1 to
 * SBK in C2.
 *
 * Values:
 * - 0 - Transmitter active (sending data, a preamble, or a break).
 * - 1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
/*! @brief Read current value of the UART_S1_TC field. */
#define UART_RD_S1_TC(base)  ((UART_S1_REG(base) & UART_S1_TC_MASK) >> UART_S1_TC_SHIFT)
#define UART_BRD_S1_TC(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_TC_SHIFT, UART_S1_TC_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field TDRE[7] (RO)
 *
 * TDRE will set when the number of datawords in the transmit buffer (D and
 * C3[T8])is equal to or less than the number indicated by TWFIFO[TXWATER]. A
 * character that is in the process of being transmitted is not included in the count.
 * To clear TDRE, read S1 when TDRE is set and then write to the UART data
 * register (D). For more efficient interrupt servicing, all data except the final value
 * to be written to the buffer must be written to D/C3[T8]. Then S1 can be read
 * before writing the final data value, resulting in the clearing of the TRDE
 * flag. This is more efficient because the TDRE reasserts until the watermark has
 * been exceeded. So, attempting to clear the TDRE with every write will be
 * ineffective until sufficient data has been written.
 *
 * Values:
 * - 0 - The amount of data in the transmit buffer is greater than the value
 *     indicated by TWFIFO[TXWATER].
 * - 1 - The amount of data in the transmit buffer is less than or equal to the
 *     value indicated by TWFIFO[TXWATER] at some point in time since the flag
 *     has been cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_TDRE field. */
#define UART_RD_S1_TDRE(base) ((UART_S1_REG(base) & UART_S1_TDRE_MASK) >> UART_S1_TDRE_SHIFT)
#define UART_BRD_S1_TDRE(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_TDRE_SHIFT, UART_S1_TDRE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_S2 - UART Status Register 2
 ******************************************************************************/

/*!
 * @brief UART_S2 - UART Status Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * The S2 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. Also, this register can be polled by the MCU to check the
 * status of these bits. This register can be read or written at any time, with the
 * exception of the MSBF and RXINV bits, which should be changed by the user only
 * between transmit and receive packets.
 */
/*!
 * @name Constants and macros for entire UART_S2 register
 */
/*@{*/
#define UART_RD_S2(base)         (UART_S2_REG(base))
#define UART_WR_S2(base, value)  (UART_S2_REG(base) = (value))
#define UART_RMW_S2(base, mask, value) (UART_WR_S2(base, (UART_RD_S2(base) & ~(mask)) | (value)))
#define UART_SET_S2(base, value) (BME_OR8(&UART_S2_REG(base), (uint8_t)(value)))
#define UART_CLR_S2(base, value) (BME_AND8(&UART_S2_REG(base), (uint8_t)(~(value))))
#define UART_TOG_S2(base, value) (BME_XOR8(&UART_S2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_S2 bitfields
 */

/*!
 * @name Register UART_S2, field RAF[0] (RO)
 *
 * RAF is set when the UART receiver detects a logic 0 during the RT1 time
 * period of the start bit search. RAF is cleared when the receiver detects an idle
 * character.
 *
 * Values:
 * - 0 - UART receiver idle/inactive waiting for a start bit.
 * - 1 - UART receiver active, RxD input not idle.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RAF field. */
#define UART_RD_S2_RAF(base) ((UART_S2_REG(base) & UART_S2_RAF_MASK) >> UART_S2_RAF_SHIFT)
#define UART_BRD_S2_RAF(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_RAF_SHIFT, UART_S2_RAF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDE[1] (RW)
 *
 * Enables the LIN Break detection feature. While LBKDE is set, S1[RDRF],
 * S1[NF], S1[FE], and S1[PF] are prevented from setting. When LBKDE is set, see .
 * Overrun operation
 *
 * Values:
 * - 0 - Break character detection is disabled.
 * - 1 - Break character is detected at length of 11 bit times if C1[M] = 0 or
 *     12 bits time if C1[M] = 1.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_LBKDE field. */
#define UART_RD_S2_LBKDE(base) ((UART_S2_REG(base) & UART_S2_LBKDE_MASK) >> UART_S2_LBKDE_SHIFT)
#define UART_BRD_S2_LBKDE(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_LBKDE_SHIFT, UART_S2_LBKDE_WIDTH))

/*! @brief Set the LBKDE field to a new value. */
#define UART_WR_S2_LBKDE(base, value) (UART_RMW_S2(base, (UART_S2_LBKDE_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_LBKDE(value)))
#define UART_BWR_S2_LBKDE(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_LBKDE_SHIFT), UART_S2_LBKDE_SHIFT, UART_S2_LBKDE_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field BRK13[2] (RW)
 *
 * Determines whether the transmit break character is 10, 11, or 12 bits long,
 * or 13 or 14 bits long. See for the length of the break character for the
 * different configurations. The detection of a framing error is not affected by this
 * field. Transmitting break characters
 *
 * Values:
 * - 0 - Break character is 10, 11, or 12 bits long.
 * - 1 - Break character is 13 or 14 bits long.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_BRK13 field. */
#define UART_RD_S2_BRK13(base) ((UART_S2_REG(base) & UART_S2_BRK13_MASK) >> UART_S2_BRK13_SHIFT)
#define UART_BRD_S2_BRK13(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_BRK13_SHIFT, UART_S2_BRK13_WIDTH))

/*! @brief Set the BRK13 field to a new value. */
#define UART_WR_S2_BRK13(base, value) (UART_RMW_S2(base, (UART_S2_BRK13_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_BRK13(value)))
#define UART_BWR_S2_BRK13(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_BRK13_SHIFT), UART_S2_BRK13_SHIFT, UART_S2_BRK13_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field RWUID[3] (RW)
 *
 * When RWU is set and WAKE is cleared, this field controls whether the idle
 * character that wakes the receiver sets S1[IDLE].
 *
 * Values:
 * - 0 - S1[IDLE] is not set upon detection of an idle character.
 * - 1 - S1[IDLE] is set upon detection of an idle character.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RWUID field. */
#define UART_RD_S2_RWUID(base) ((UART_S2_REG(base) & UART_S2_RWUID_MASK) >> UART_S2_RWUID_SHIFT)
#define UART_BRD_S2_RWUID(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_RWUID_SHIFT, UART_S2_RWUID_WIDTH))

/*! @brief Set the RWUID field to a new value. */
#define UART_WR_S2_RWUID(base, value) (UART_RMW_S2(base, (UART_S2_RWUID_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_RWUID(value)))
#define UART_BWR_S2_RWUID(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_RWUID_SHIFT), UART_S2_RWUID_SHIFT, UART_S2_RWUID_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field RXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the received data input. In NRZ
 * format, a one is represented by a mark and a zero is represented by a space for
 * normal polarity, and the opposite for inverted polarity. Setting RXINV
 * inverts the RxD input for data bits, start and stop bits, break, and idle.
 *
 * Values:
 * - 0 - Receive data is not inverted.
 * - 1 - Receive data is inverted.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RXINV field. */
#define UART_RD_S2_RXINV(base) ((UART_S2_REG(base) & UART_S2_RXINV_MASK) >> UART_S2_RXINV_SHIFT)
#define UART_BRD_S2_RXINV(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_RXINV_SHIFT, UART_S2_RXINV_WIDTH))

/*! @brief Set the RXINV field to a new value. */
#define UART_WR_S2_RXINV(base, value) (UART_RMW_S2(base, (UART_S2_RXINV_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_RXINV(value)))
#define UART_BWR_S2_RXINV(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_RXINV_SHIFT), UART_S2_RXINV_SHIFT, UART_S2_RXINV_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field MSBF[5] (RW)
 *
 * Setting this field reverses the order of the bits that are transmitted and
 * received on the wire. This field does not affect the polarity of the bits, the
 * location of the parity bit, or the location of the start or stop bits.
 *
 * Values:
 * - 0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 1 - MSB (bit8, bit7 or bit6) is the first bit that is transmitted following
 *     the start bit, depending on the setting of C1[M] and C1[PE]. Further, the
 *     first bit received after the start bit is identified as bit8, bit7, or
 *     bit6, depending on the setting of C1[M] and C1[PE].
 */
/*@{*/
/*! @brief Read current value of the UART_S2_MSBF field. */
#define UART_RD_S2_MSBF(base) ((UART_S2_REG(base) & UART_S2_MSBF_MASK) >> UART_S2_MSBF_SHIFT)
#define UART_BRD_S2_MSBF(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_MSBF_SHIFT, UART_S2_MSBF_WIDTH))

/*! @brief Set the MSBF field to a new value. */
#define UART_WR_S2_MSBF(base, value) (UART_RMW_S2(base, (UART_S2_MSBF_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_MSBF(value)))
#define UART_BWR_S2_MSBF(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_MSBF_SHIFT), UART_S2_MSBF_SHIFT, UART_S2_MSBF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field RXEDGIF[6] (W1C)
 *
 * RXEDGIF is set when an active edge occurs on the RxD pin. The active edge is
 * falling if RXINV = 0, and rising if RXINV=1. RXEDGIF is cleared by writing a 1
 * to it. See for additional details. RXEDGIF description The active edge is
 * detected only in two wire mode and on receiving data coming from the RxD pin.
 *
 * Values:
 * - 0 - No active edge on the receive pin has occurred.
 * - 1 - An active edge on the receive pin has occurred.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RXEDGIF field. */
#define UART_RD_S2_RXEDGIF(base) ((UART_S2_REG(base) & UART_S2_RXEDGIF_MASK) >> UART_S2_RXEDGIF_SHIFT)
#define UART_BRD_S2_RXEDGIF(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_RXEDGIF_SHIFT, UART_S2_RXEDGIF_WIDTH))

/*! @brief Set the RXEDGIF field to a new value. */
#define UART_WR_S2_RXEDGIF(base, value) (UART_RMW_S2(base, (UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_RXEDGIF(value)))
#define UART_BWR_S2_RXEDGIF(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_RXEDGIF_SHIFT), UART_S2_RXEDGIF_SHIFT, UART_S2_RXEDGIF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDIF[7] (W1C)
 *
 * LBKDIF is set when LBKDE is set and a LIN break character is detected on the
 * receiver input. The LIN break characters are 11 consecutive logic 0s if C1[M]
 * = 0 or 12 consecutive logic 0s if C1[M] = 1. LBKDIF is set after receiving the
 * last LIN break character. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No LIN break character detected.
 * - 1 - LIN break character detected.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_LBKDIF field. */
#define UART_RD_S2_LBKDIF(base) ((UART_S2_REG(base) & UART_S2_LBKDIF_MASK) >> UART_S2_LBKDIF_SHIFT)
#define UART_BRD_S2_LBKDIF(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_LBKDIF_SHIFT, UART_S2_LBKDIF_WIDTH))

/*! @brief Set the LBKDIF field to a new value. */
#define UART_WR_S2_LBKDIF(base, value) (UART_RMW_S2(base, (UART_S2_LBKDIF_MASK | UART_S2_RXEDGIF_MASK), UART_S2_LBKDIF(value)))
#define UART_BWR_S2_LBKDIF(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_LBKDIF_SHIFT), UART_S2_LBKDIF_SHIFT, UART_S2_LBKDIF_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_C3 - UART Control Register 3
 ******************************************************************************/

/*!
 * @brief UART_C3 - UART Control Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Writing R8 does not have any effect. TXDIR and TXINV can be changed only
 * between transmit and receive packets.
 */
/*!
 * @name Constants and macros for entire UART_C3 register
 */
/*@{*/
#define UART_RD_C3(base)         (UART_C3_REG(base))
#define UART_WR_C3(base, value)  (UART_C3_REG(base) = (value))
#define UART_RMW_C3(base, mask, value) (UART_WR_C3(base, (UART_RD_C3(base) & ~(mask)) | (value)))
#define UART_SET_C3(base, value) (BME_OR8(&UART_C3_REG(base), (uint8_t)(value)))
#define UART_CLR_C3(base, value) (BME_AND8(&UART_C3_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C3(base, value) (BME_XOR8(&UART_C3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C3 bitfields
 */

/*!
 * @name Register UART_C3, field PEIE[0] (RW)
 *
 * Enables the parity error flag, S1[PF], to generate interrupt requests.
 *
 * Values:
 * - 0 - PF interrupt requests are disabled.
 * - 1 - PF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_PEIE field. */
#define UART_RD_C3_PEIE(base) ((UART_C3_REG(base) & UART_C3_PEIE_MASK) >> UART_C3_PEIE_SHIFT)
#define UART_BRD_C3_PEIE(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_PEIE_SHIFT, UART_C3_PEIE_WIDTH))

/*! @brief Set the PEIE field to a new value. */
#define UART_WR_C3_PEIE(base, value) (UART_RMW_C3(base, UART_C3_PEIE_MASK, UART_C3_PEIE(value)))
#define UART_BWR_C3_PEIE(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_PEIE_SHIFT), UART_C3_PEIE_SHIFT, UART_C3_PEIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field FEIE[1] (RW)
 *
 * Enables the framing error flag, S1[FE], to generate interrupt requests.
 *
 * Values:
 * - 0 - FE interrupt requests are disabled.
 * - 1 - FE interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_FEIE field. */
#define UART_RD_C3_FEIE(base) ((UART_C3_REG(base) & UART_C3_FEIE_MASK) >> UART_C3_FEIE_SHIFT)
#define UART_BRD_C3_FEIE(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_FEIE_SHIFT, UART_C3_FEIE_WIDTH))

/*! @brief Set the FEIE field to a new value. */
#define UART_WR_C3_FEIE(base, value) (UART_RMW_C3(base, UART_C3_FEIE_MASK, UART_C3_FEIE(value)))
#define UART_BWR_C3_FEIE(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_FEIE_SHIFT), UART_C3_FEIE_SHIFT, UART_C3_FEIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field NEIE[2] (RW)
 *
 * Enables the noise flag, S1[NF], to generate interrupt requests.
 *
 * Values:
 * - 0 - NF interrupt requests are disabled.
 * - 1 - NF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_NEIE field. */
#define UART_RD_C3_NEIE(base) ((UART_C3_REG(base) & UART_C3_NEIE_MASK) >> UART_C3_NEIE_SHIFT)
#define UART_BRD_C3_NEIE(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_NEIE_SHIFT, UART_C3_NEIE_WIDTH))

/*! @brief Set the NEIE field to a new value. */
#define UART_WR_C3_NEIE(base, value) (UART_RMW_C3(base, UART_C3_NEIE_MASK, UART_C3_NEIE(value)))
#define UART_BWR_C3_NEIE(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_NEIE_SHIFT), UART_C3_NEIE_SHIFT, UART_C3_NEIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field ORIE[3] (RW)
 *
 * Enables the overrun error flag, S1[OR], to generate interrupt requests.
 *
 * Values:
 * - 0 - OR interrupts are disabled.
 * - 1 - OR interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_ORIE field. */
#define UART_RD_C3_ORIE(base) ((UART_C3_REG(base) & UART_C3_ORIE_MASK) >> UART_C3_ORIE_SHIFT)
#define UART_BRD_C3_ORIE(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_ORIE_SHIFT, UART_C3_ORIE_WIDTH))

/*! @brief Set the ORIE field to a new value. */
#define UART_WR_C3_ORIE(base, value) (UART_RMW_C3(base, UART_C3_ORIE_MASK, UART_C3_ORIE(value)))
#define UART_BWR_C3_ORIE(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_ORIE_SHIFT), UART_C3_ORIE_SHIFT, UART_C3_ORIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field TXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the transmitted data output. In
 * NRZ format, a one is represented by a mark and a zero is represented by a space
 * for normal polarity, and the opposite for inverted polarity. Setting TXINV
 * inverts all transmitted values, including idle, break, start, and stop bits. In
 * loop mode, if TXINV is set, the receiver gets the transmit inversion bit when
 * RXINV is disabled.
 *
 * Values:
 * - 0 - Transmit data is not inverted.
 * - 1 - Transmit data is inverted.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_TXINV field. */
#define UART_RD_C3_TXINV(base) ((UART_C3_REG(base) & UART_C3_TXINV_MASK) >> UART_C3_TXINV_SHIFT)
#define UART_BRD_C3_TXINV(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_TXINV_SHIFT, UART_C3_TXINV_WIDTH))

/*! @brief Set the TXINV field to a new value. */
#define UART_WR_C3_TXINV(base, value) (UART_RMW_C3(base, UART_C3_TXINV_MASK, UART_C3_TXINV(value)))
#define UART_BWR_C3_TXINV(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_TXINV_SHIFT), UART_C3_TXINV_SHIFT, UART_C3_TXINV_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field TXDIR[5] (RW)
 *
 * Determines whether the TXD pin is used as an input or output in the
 * single-wire mode of operation. This field is relevant only to the single wire mode.
 *
 * Values:
 * - 0 - TXD pin is an input in single wire mode.
 * - 1 - TXD pin is an output in single wire mode.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_TXDIR field. */
#define UART_RD_C3_TXDIR(base) ((UART_C3_REG(base) & UART_C3_TXDIR_MASK) >> UART_C3_TXDIR_SHIFT)
#define UART_BRD_C3_TXDIR(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_TXDIR_SHIFT, UART_C3_TXDIR_WIDTH))

/*! @brief Set the TXDIR field to a new value. */
#define UART_WR_C3_TXDIR(base, value) (UART_RMW_C3(base, UART_C3_TXDIR_MASK, UART_C3_TXDIR(value)))
#define UART_BWR_C3_TXDIR(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_TXDIR_SHIFT), UART_C3_TXDIR_SHIFT, UART_C3_TXDIR_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field T8[6] (RW)
 *
 * T8 is the ninth data bit transmitted when the UART is configured for 9-bit
 * data format, that is, if C1[M] = 1 or C4[M10] = 1. If the value of T8 is the
 * same as in the previous transmission, T8 does not have to be rewritten. The same
 * value is transmitted until T8 is rewritten. To correctly transmit the 9th bit,
 * write UARTx_C3[T8] to the desired value, then write the UARTx_D register with
 * the remaining data.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_T8 field. */
#define UART_RD_C3_T8(base)  ((UART_C3_REG(base) & UART_C3_T8_MASK) >> UART_C3_T8_SHIFT)
#define UART_BRD_C3_T8(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_T8_SHIFT, UART_C3_T8_WIDTH))

/*! @brief Set the T8 field to a new value. */
#define UART_WR_C3_T8(base, value) (UART_RMW_C3(base, UART_C3_T8_MASK, UART_C3_T8(value)))
#define UART_BWR_C3_T8(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_T8_SHIFT), UART_C3_T8_SHIFT, UART_C3_T8_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field R8[7] (RO)
 *
 * R8 is the ninth data bit received when the UART is configured for 9-bit data
 * format, that is, if C1[M] = 1 or C4[M10] = 1. The R8 value corresponds to the
 * current data value in the UARTx_D register. To read the 9th bit, read the
 * value of UARTx_C3[R8], then read the UARTx_D register.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_R8 field. */
#define UART_RD_C3_R8(base)  ((UART_C3_REG(base) & UART_C3_R8_MASK) >> UART_C3_R8_SHIFT)
#define UART_BRD_C3_R8(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_R8_SHIFT, UART_C3_R8_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_D - UART Data Register
 ******************************************************************************/

/*!
 * @brief UART_D - UART Data Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data register and writes go to the write-only transmit
 * data register. In 8-bit or 9-bit data format, only UART data register (D)
 * needs to be accessed to clear the S1[RDRF] bit (assuming receiver buffer level is
 * less than RWFIFO[RXWATER]). The C3 register needs to be read, prior to the D
 * register, only if the ninth bit of data needs to be captured. Similarly, the
 * ED register needs to be read, prior to the D register, only if the additional
 * flag data for the dataword needs to be captured. In the normal 8-bit mode (M
 * bit cleared) if the parity is enabled, you get seven data bits and one parity
 * bit. That one parity bit is loaded into the D register. So, for the data bits,
 * mask off the parity bit from the value you read out of this register. When
 * transmitting in 9-bit data format and using 8-bit write instructions, write first
 * to transmit bit 8 in UART control register 3 (C3[T8]), then D. A write to
 * C3[T8] stores the data in a temporary register. If D register is written first,
 * and then the new data on data bus is stored in D, the temporary value written by
 * the last write to C3[T8] gets stored in the C3[T8] register.
 */
/*!
 * @name Constants and macros for entire UART_D register
 */
/*@{*/
#define UART_RD_D(base)          (UART_D_REG(base))
#define UART_WR_D(base, value)   (UART_D_REG(base) = (value))
#define UART_RMW_D(base, mask, value) (UART_WR_D(base, (UART_RD_D(base) & ~(mask)) | (value)))
#define UART_SET_D(base, value)  (BME_OR8(&UART_D_REG(base), (uint8_t)(value)))
#define UART_CLR_D(base, value)  (BME_AND8(&UART_D_REG(base), (uint8_t)(~(value))))
#define UART_TOG_D(base, value)  (BME_XOR8(&UART_D_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_MA1 - UART Match Address Registers 1
 ******************************************************************************/

/*!
 * @brief UART_MA1 - UART Match Address Registers 1 (RW)
 *
 * Reset value: 0x00U
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated C4[MAEN] field is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. These registers can be read and written at
 * anytime.
 */
/*!
 * @name Constants and macros for entire UART_MA1 register
 */
/*@{*/
#define UART_RD_MA1(base)        (UART_MA1_REG(base))
#define UART_WR_MA1(base, value) (UART_MA1_REG(base) = (value))
#define UART_RMW_MA1(base, mask, value) (UART_WR_MA1(base, (UART_RD_MA1(base) & ~(mask)) | (value)))
#define UART_SET_MA1(base, value) (BME_OR8(&UART_MA1_REG(base), (uint8_t)(value)))
#define UART_CLR_MA1(base, value) (BME_AND8(&UART_MA1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_MA1(base, value) (BME_XOR8(&UART_MA1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_MA2 - UART Match Address Registers 2
 ******************************************************************************/

/*!
 * @brief UART_MA2 - UART Match Address Registers 2 (RW)
 *
 * Reset value: 0x00U
 *
 * These registers can be read and written at anytime. The MA1 and MA2 registers
 * are compared to input data addresses when the most significant bit is set and
 * the associated C4[MAEN] field is set. If a match occurs, the following data
 * is transferred to the data register. If a match fails, the following data is
 * discarded.
 */
/*!
 * @name Constants and macros for entire UART_MA2 register
 */
/*@{*/
#define UART_RD_MA2(base)        (UART_MA2_REG(base))
#define UART_WR_MA2(base, value) (UART_MA2_REG(base) = (value))
#define UART_RMW_MA2(base, mask, value) (UART_WR_MA2(base, (UART_RD_MA2(base) & ~(mask)) | (value)))
#define UART_SET_MA2(base, value) (BME_OR8(&UART_MA2_REG(base), (uint8_t)(value)))
#define UART_CLR_MA2(base, value) (BME_AND8(&UART_MA2_REG(base), (uint8_t)(~(value))))
#define UART_TOG_MA2(base, value) (BME_XOR8(&UART_MA2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_C4 - UART Control Register 4
 ******************************************************************************/

/*!
 * @brief UART_C4 - UART Control Register 4 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_C4 register
 */
/*@{*/
#define UART_RD_C4(base)         (UART_C4_REG(base))
#define UART_WR_C4(base, value)  (UART_C4_REG(base) = (value))
#define UART_RMW_C4(base, mask, value) (UART_WR_C4(base, (UART_RD_C4(base) & ~(mask)) | (value)))
#define UART_SET_C4(base, value) (BME_OR8(&UART_C4_REG(base), (uint8_t)(value)))
#define UART_CLR_C4(base, value) (BME_AND8(&UART_C4_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C4(base, value) (BME_XOR8(&UART_C4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C4 bitfields
 */

/*!
 * @name Register UART_C4, field BRFA[4:0] (RW)
 *
 * This bit field is used to add more timing resolution to the average baud
 * frequency, in increments of 1/32. See Baud rate generation for more information.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_BRFA field. */
#define UART_RD_C4_BRFA(base) ((UART_C4_REG(base) & UART_C4_BRFA_MASK) >> UART_C4_BRFA_SHIFT)
#define UART_BRD_C4_BRFA(base) (BME_UBFX8(&UART_C4_REG(base), UART_C4_BRFA_SHIFT, UART_C4_BRFA_WIDTH))

/*! @brief Set the BRFA field to a new value. */
#define UART_WR_C4_BRFA(base, value) (UART_RMW_C4(base, UART_C4_BRFA_MASK, UART_C4_BRFA(value)))
#define UART_BWR_C4_BRFA(base, value) (BME_BFI8(&UART_C4_REG(base), ((uint8_t)(value) << UART_C4_BRFA_SHIFT), UART_C4_BRFA_SHIFT, UART_C4_BRFA_WIDTH))
/*@}*/

/*!
 * @name Register UART_C4, field M10[5] (RW)
 *
 * Causes a tenth, non-memory mapped bit to be part of the serial transmission.
 * This tenth bit is generated and interpreted as a parity bit. The M10 field
 * does not affect the LIN send or detect break behavior. If M10 is set, then both
 * C1[M] and C1[PE] must also be set. See Data format for more information.
 *
 * Values:
 * - 0 - The parity bit is the ninth bit in the serial transmission.
 * - 1 - The parity bit is the tenth bit in the serial transmission.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_M10 field. */
#define UART_RD_C4_M10(base) ((UART_C4_REG(base) & UART_C4_M10_MASK) >> UART_C4_M10_SHIFT)
#define UART_BRD_C4_M10(base) (BME_UBFX8(&UART_C4_REG(base), UART_C4_M10_SHIFT, UART_C4_M10_WIDTH))

/*! @brief Set the M10 field to a new value. */
#define UART_WR_C4_M10(base, value) (UART_RMW_C4(base, UART_C4_M10_MASK, UART_C4_M10(value)))
#define UART_BWR_C4_M10(base, value) (BME_BFI8(&UART_C4_REG(base), ((uint8_t)(value) << UART_C4_M10_SHIFT), UART_C4_M10_SHIFT, UART_C4_M10_WIDTH))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN2[6] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN1 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA2 register. If no match occurs, the data is discarded. If a
 *     match occurs, data is transferred to the data buffer.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_MAEN2 field. */
#define UART_RD_C4_MAEN2(base) ((UART_C4_REG(base) & UART_C4_MAEN2_MASK) >> UART_C4_MAEN2_SHIFT)
#define UART_BRD_C4_MAEN2(base) (BME_UBFX8(&UART_C4_REG(base), UART_C4_MAEN2_SHIFT, UART_C4_MAEN2_WIDTH))

/*! @brief Set the MAEN2 field to a new value. */
#define UART_WR_C4_MAEN2(base, value) (UART_RMW_C4(base, UART_C4_MAEN2_MASK, UART_C4_MAEN2(value)))
#define UART_BWR_C4_MAEN2(base, value) (BME_BFI8(&UART_C4_REG(base), ((uint8_t)(value) << UART_C4_MAEN2_SHIFT), UART_C4_MAEN2_SHIFT, UART_C4_MAEN2_WIDTH))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN1[7] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN2 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA1 register. If no match occurs, the data is discarded. If match
 *     occurs, data is transferred to the data buffer.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_MAEN1 field. */
#define UART_RD_C4_MAEN1(base) ((UART_C4_REG(base) & UART_C4_MAEN1_MASK) >> UART_C4_MAEN1_SHIFT)
#define UART_BRD_C4_MAEN1(base) (BME_UBFX8(&UART_C4_REG(base), UART_C4_MAEN1_SHIFT, UART_C4_MAEN1_WIDTH))

/*! @brief Set the MAEN1 field to a new value. */
#define UART_WR_C4_MAEN1(base, value) (UART_RMW_C4(base, UART_C4_MAEN1_MASK, UART_C4_MAEN1(value)))
#define UART_BWR_C4_MAEN1(base, value) (BME_BFI8(&UART_C4_REG(base), ((uint8_t)(value) << UART_C4_MAEN1_SHIFT), UART_C4_MAEN1_SHIFT, UART_C4_MAEN1_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_C5 - UART Control Register 5
 ******************************************************************************/

/*!
 * @brief UART_C5 - UART Control Register 5 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_C5 register
 */
/*@{*/
#define UART_RD_C5(base)         (UART_C5_REG(base))
#define UART_WR_C5(base, value)  (UART_C5_REG(base) = (value))
#define UART_RMW_C5(base, mask, value) (UART_WR_C5(base, (UART_RD_C5(base) & ~(mask)) | (value)))
#define UART_SET_C5(base, value) (BME_OR8(&UART_C5_REG(base), (uint8_t)(value)))
#define UART_CLR_C5(base, value) (BME_AND8(&UART_C5_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C5(base, value) (BME_XOR8(&UART_C5_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C5 bitfields
 */

/*!
 * @name Register UART_C5, field RDMAS[5] (RW)
 *
 * Configures the receiver data register full flag, S1[RDRF], to generate
 * interrupt or DMA requests if C2[RIE] is set. If C2[RIE] is cleared, and S1[RDRF] is
 * set, the RDRF DMA and RDFR interrupt request signals are not asserted,
 * regardless of the state of RDMAS.
 *
 * Values:
 * - 0 - If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is
 *     asserted to request an interrupt service.
 * - 1 - If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_RDMAS field. */
#define UART_RD_C5_RDMAS(base) ((UART_C5_REG(base) & UART_C5_RDMAS_MASK) >> UART_C5_RDMAS_SHIFT)
#define UART_BRD_C5_RDMAS(base) (BME_UBFX8(&UART_C5_REG(base), UART_C5_RDMAS_SHIFT, UART_C5_RDMAS_WIDTH))

/*! @brief Set the RDMAS field to a new value. */
#define UART_WR_C5_RDMAS(base, value) (UART_RMW_C5(base, UART_C5_RDMAS_MASK, UART_C5_RDMAS(value)))
#define UART_BWR_C5_RDMAS(base, value) (BME_BFI8(&UART_C5_REG(base), ((uint8_t)(value) << UART_C5_RDMAS_SHIFT), UART_C5_RDMAS_SHIFT, UART_C5_RDMAS_WIDTH))
/*@}*/

/*!
 * @name Register UART_C5, field TDMAS[7] (RW)
 *
 * Configures the transmit data register empty flag, S1[TDRE], to generate
 * interrupt or DMA requests if C2[TIE] is set. If C2[TIE] is cleared, TDRE DMA and
 * TDRE interrupt request signals are not asserted when the TDRE flag is set,
 * regardless of the state of TDMAS. If C2[TIE] and TDMAS are both set, then C2[TCIE]
 * must be cleared, and D must not be written unless a DMA request is being
 * serviced.
 *
 * Values:
 * - 0 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt
 *     request signal is asserted to request interrupt service.
 * - 1 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request
 *     signal is asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_TDMAS field. */
#define UART_RD_C5_TDMAS(base) ((UART_C5_REG(base) & UART_C5_TDMAS_MASK) >> UART_C5_TDMAS_SHIFT)
#define UART_BRD_C5_TDMAS(base) (BME_UBFX8(&UART_C5_REG(base), UART_C5_TDMAS_SHIFT, UART_C5_TDMAS_WIDTH))

/*! @brief Set the TDMAS field to a new value. */
#define UART_WR_C5_TDMAS(base, value) (UART_RMW_C5(base, UART_C5_TDMAS_MASK, UART_C5_TDMAS(value)))
#define UART_BWR_C5_TDMAS(base, value) (BME_BFI8(&UART_C5_REG(base), ((uint8_t)(value) << UART_C5_TDMAS_SHIFT), UART_C5_TDMAS_SHIFT, UART_C5_TDMAS_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_ED - UART Extended Data Register
 ******************************************************************************/

/*!
 * @brief UART_ED - UART Extended Data Register (RO)
 *
 * Reset value: 0x00U
 *
 * This register contains additional information flags that are stored with a
 * received dataword. This register may be read at any time but contains valid data
 * only if there is a dataword in the receive FIFO. The data contained in this
 * register represents additional information regarding the conditions on which a
 * dataword was received. The importance of this data varies with the
 * application, and in some cases maybe completely optional. These fields automatically
 * update to reflect the conditions of the next dataword whenever D is read. If
 * S1[NF] and S1[PF] have not been set since the last time the receive buffer was
 * empty, the NOISY and PARITYE fields will be zero.
 */
/*!
 * @name Constants and macros for entire UART_ED register
 */
/*@{*/
#define UART_RD_ED(base)         (UART_ED_REG(base))
/*@}*/

/*
 * Constants & macros for individual UART_ED bitfields
 */

/*!
 * @name Register UART_ED, field PARITYE[6] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with a
 * parity error.
 *
 * Values:
 * - 0 - The dataword was received without a parity error.
 * - 1 - The dataword was received with a parity error.
 */
/*@{*/
/*! @brief Read current value of the UART_ED_PARITYE field. */
#define UART_RD_ED_PARITYE(base) ((UART_ED_REG(base) & UART_ED_PARITYE_MASK) >> UART_ED_PARITYE_SHIFT)
#define UART_BRD_ED_PARITYE(base) (BME_UBFX8(&UART_ED_REG(base), UART_ED_PARITYE_SHIFT, UART_ED_PARITYE_WIDTH))
/*@}*/

/*!
 * @name Register UART_ED, field NOISY[7] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with
 * noise.
 *
 * Values:
 * - 0 - The dataword was received without noise.
 * - 1 - The data was received with noise.
 */
/*@{*/
/*! @brief Read current value of the UART_ED_NOISY field. */
#define UART_RD_ED_NOISY(base) ((UART_ED_REG(base) & UART_ED_NOISY_MASK) >> UART_ED_NOISY_SHIFT)
#define UART_BRD_ED_NOISY(base) (BME_UBFX8(&UART_ED_REG(base), UART_ED_NOISY_SHIFT, UART_ED_NOISY_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_MODEM - UART Modem Register
 ******************************************************************************/

/*!
 * @brief UART_MODEM - UART Modem Register (RW)
 *
 * Reset value: 0x00U
 *
 * The MODEM register controls options for setting the modem configuration.
 */
/*!
 * @name Constants and macros for entire UART_MODEM register
 */
/*@{*/
#define UART_RD_MODEM(base)      (UART_MODEM_REG(base))
#define UART_WR_MODEM(base, value) (UART_MODEM_REG(base) = (value))
#define UART_RMW_MODEM(base, mask, value) (UART_WR_MODEM(base, (UART_RD_MODEM(base) & ~(mask)) | (value)))
#define UART_SET_MODEM(base, value) (BME_OR8(&UART_MODEM_REG(base), (uint8_t)(value)))
#define UART_CLR_MODEM(base, value) (BME_AND8(&UART_MODEM_REG(base), (uint8_t)(~(value))))
#define UART_TOG_MODEM(base, value) (BME_XOR8(&UART_MODEM_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_MODEM bitfields
 */

/*!
 * @name Register UART_MODEM, field TXCTSE[0] (RW)
 *
 * TXCTSE controls the operation of the transmitter. TXCTSE can be set
 * independently from the state of TXRTSE and RXRTSE.
 *
 * Values:
 * - 0 - CTS has no effect on the transmitter.
 * - 1 - Enables clear-to-send operation. The transmitter checks the state of
 *     CTS each time it is ready to send a character. If CTS is asserted, the
 *     character is sent. If CTS is deasserted, the signal TXD remains in the mark
 *     state and transmission is delayed until CTS is asserted. Changes in CTS as a
 *     character is being sent do not affect its transmission.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXCTSE field. */
#define UART_RD_MODEM_TXCTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_TXCTSE_MASK) >> UART_MODEM_TXCTSE_SHIFT)
#define UART_BRD_MODEM_TXCTSE(base) (BME_UBFX8(&UART_MODEM_REG(base), UART_MODEM_TXCTSE_SHIFT, UART_MODEM_TXCTSE_WIDTH))

/*! @brief Set the TXCTSE field to a new value. */
#define UART_WR_MODEM_TXCTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXCTSE_MASK, UART_MODEM_TXCTSE(value)))
#define UART_BWR_MODEM_TXCTSE(base, value) (BME_BFI8(&UART_MODEM_REG(base), ((uint8_t)(value) << UART_MODEM_TXCTSE_SHIFT), UART_MODEM_TXCTSE_SHIFT, UART_MODEM_TXCTSE_WIDTH))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSE[1] (RW)
 *
 * Controls RTS before and after a transmission.
 *
 * Values:
 * - 0 - The transmitter has no effect on RTS.
 * - 1 - When a character is placed into an empty transmitter data buffer , RTS
 *     asserts one bit time before the start bit is transmitted. RTS deasserts
 *     one bit time after all characters in the transmitter data buffer and shift
 *     register are completely sent, including the last stop bit. (FIFO) (FIFO)
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXRTSE field. */
#define UART_RD_MODEM_TXRTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_TXRTSE_MASK) >> UART_MODEM_TXRTSE_SHIFT)
#define UART_BRD_MODEM_TXRTSE(base) (BME_UBFX8(&UART_MODEM_REG(base), UART_MODEM_TXRTSE_SHIFT, UART_MODEM_TXRTSE_WIDTH))

/*! @brief Set the TXRTSE field to a new value. */
#define UART_WR_MODEM_TXRTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXRTSE_MASK, UART_MODEM_TXRTSE(value)))
#define UART_BWR_MODEM_TXRTSE(base, value) (BME_BFI8(&UART_MODEM_REG(base), ((uint8_t)(value) << UART_MODEM_TXRTSE_SHIFT), UART_MODEM_TXRTSE_SHIFT, UART_MODEM_TXRTSE_WIDTH))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSPOL[2] (RW)
 *
 * Controls the polarity of the transmitter RTS. TXRTSPOL does not affect the
 * polarity of the receiver RTS. RTS will remain negated in the active low state
 * unless TXRTSE is set.
 *
 * Values:
 * - 0 - Transmitter RTS is active low.
 * - 1 - Transmitter RTS is active high.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXRTSPOL field. */
#define UART_RD_MODEM_TXRTSPOL(base) ((UART_MODEM_REG(base) & UART_MODEM_TXRTSPOL_MASK) >> UART_MODEM_TXRTSPOL_SHIFT)
#define UART_BRD_MODEM_TXRTSPOL(base) (BME_UBFX8(&UART_MODEM_REG(base), UART_MODEM_TXRTSPOL_SHIFT, UART_MODEM_TXRTSPOL_WIDTH))

/*! @brief Set the TXRTSPOL field to a new value. */
#define UART_WR_MODEM_TXRTSPOL(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXRTSPOL_MASK, UART_MODEM_TXRTSPOL(value)))
#define UART_BWR_MODEM_TXRTSPOL(base, value) (BME_BFI8(&UART_MODEM_REG(base), ((uint8_t)(value) << UART_MODEM_TXRTSPOL_SHIFT), UART_MODEM_TXRTSPOL_SHIFT, UART_MODEM_TXRTSPOL_WIDTH))
/*@}*/

/*!
 * @name Register UART_MODEM, field RXRTSE[3] (RW)
 *
 * Allows the RTS output to control the CTS input of the transmitting device to
 * prevent receiver overrun. Do not set both RXRTSE and TXRTSE.
 *
 * Values:
 * - 0 - The receiver has no effect on RTS.
 * - 1 - RTS is deasserted if the number of characters in the receiver data
 *     register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted
 *     when the number of characters in the receiver data register (FIFO) is less
 *     than RWFIFO[RXWATER]. See Hardware flow control
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_RXRTSE field. */
#define UART_RD_MODEM_RXRTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_RXRTSE_MASK) >> UART_MODEM_RXRTSE_SHIFT)
#define UART_BRD_MODEM_RXRTSE(base) (BME_UBFX8(&UART_MODEM_REG(base), UART_MODEM_RXRTSE_SHIFT, UART_MODEM_RXRTSE_WIDTH))

/*! @brief Set the RXRTSE field to a new value. */
#define UART_WR_MODEM_RXRTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_RXRTSE_MASK, UART_MODEM_RXRTSE(value)))
#define UART_BWR_MODEM_RXRTSE(base, value) (BME_BFI8(&UART_MODEM_REG(base), ((uint8_t)(value) << UART_MODEM_RXRTSE_SHIFT), UART_MODEM_RXRTSE_SHIFT, UART_MODEM_RXRTSE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_PFIFO - UART FIFO Parameters
 ******************************************************************************/

/*!
 * @brief UART_PFIFO - UART FIFO Parameters (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability for the programmer to turn on and off FIFO
 * functionality. It also provides the size of the FIFO that has been
 * implemented. This register may be read at any time. This register must be written only
 * when C2[RE] and C2[TE] are cleared/not set and when the data buffer/FIFO is
 * empty.
 */
/*!
 * @name Constants and macros for entire UART_PFIFO register
 */
/*@{*/
#define UART_RD_PFIFO(base)      (UART_PFIFO_REG(base))
#define UART_WR_PFIFO(base, value) (UART_PFIFO_REG(base) = (value))
#define UART_RMW_PFIFO(base, mask, value) (UART_WR_PFIFO(base, (UART_RD_PFIFO(base) & ~(mask)) | (value)))
#define UART_SET_PFIFO(base, value) (BME_OR8(&UART_PFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_PFIFO(base, value) (BME_AND8(&UART_PFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_PFIFO(base, value) (BME_XOR8(&UART_PFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_PFIFO bitfields
 */

/*!
 * @name Register UART_PFIFO, field RXFIFOSIZE[2:0] (RO)
 *
 * The maximum number of receive datawords that can be stored in the receive
 * buffer before an overrun occurs. This field is read only.
 *
 * Values:
 * - 000 - Receive FIFO/Buffer depth = 1 dataword.
 * - 001 - Receive FIFO/Buffer depth = 4 datawords.
 * - 010 - Receive FIFO/Buffer depth = 8 datawords.
 * - 011 - Receive FIFO/Buffer depth = 16 datawords.
 * - 100 - Receive FIFO/Buffer depth = 32 datawords.
 * - 101 - Receive FIFO/Buffer depth = 64 datawords.
 * - 110 - Receive FIFO/Buffer depth = 128 datawords.
 * - 111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_RXFIFOSIZE field. */
#define UART_RD_PFIFO_RXFIFOSIZE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_RXFIFOSIZE_MASK) >> UART_PFIFO_RXFIFOSIZE_SHIFT)
#define UART_BRD_PFIFO_RXFIFOSIZE(base) (BME_UBFX8(&UART_PFIFO_REG(base), UART_PFIFO_RXFIFOSIZE_SHIFT, UART_PFIFO_RXFIFOSIZE_WIDTH))
/*@}*/

/*!
 * @name Register UART_PFIFO, field RXFE[3] (RW)
 *
 * When this field is set, the built in FIFO structure for the receive buffer is
 * enabled. The size of the FIFO structure is indicated by the RXFIFOSIZE field.
 * If this field is not set, the receive buffer operates as a FIFO of depth one
 * dataword regardless of the value in RXFIFOSIZE. Both C2[TE] and C2[RE] must be
 * cleared prior to changing this field. Additionally, TXFLUSH and RXFLUSH
 * commands must be issued immediately after changing this field.
 *
 * Values:
 * - 0 - Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
 * - 1 - Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_RXFE field. */
#define UART_RD_PFIFO_RXFE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_RXFE_MASK) >> UART_PFIFO_RXFE_SHIFT)
#define UART_BRD_PFIFO_RXFE(base) (BME_UBFX8(&UART_PFIFO_REG(base), UART_PFIFO_RXFE_SHIFT, UART_PFIFO_RXFE_WIDTH))

/*! @brief Set the RXFE field to a new value. */
#define UART_WR_PFIFO_RXFE(base, value) (UART_RMW_PFIFO(base, UART_PFIFO_RXFE_MASK, UART_PFIFO_RXFE(value)))
#define UART_BWR_PFIFO_RXFE(base, value) (BME_BFI8(&UART_PFIFO_REG(base), ((uint8_t)(value) << UART_PFIFO_RXFE_SHIFT), UART_PFIFO_RXFE_SHIFT, UART_PFIFO_RXFE_WIDTH))
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFIFOSIZE[6:4] (RO)
 *
 * The maximum number of transmit datawords that can be stored in the transmit
 * buffer. This field is read only.
 *
 * Values:
 * - 000 - Transmit FIFO/Buffer depth = 1 dataword.
 * - 001 - Transmit FIFO/Buffer depth = 4 datawords.
 * - 010 - Transmit FIFO/Buffer depth = 8 datawords.
 * - 011 - Transmit FIFO/Buffer depth = 16 datawords.
 * - 100 - Transmit FIFO/Buffer depth = 32 datawords.
 * - 101 - Transmit FIFO/Buffer depth = 64 datawords.
 * - 110 - Transmit FIFO/Buffer depth = 128 datawords.
 * - 111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_TXFIFOSIZE field. */
#define UART_RD_PFIFO_TXFIFOSIZE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_TXFIFOSIZE_MASK) >> UART_PFIFO_TXFIFOSIZE_SHIFT)
#define UART_BRD_PFIFO_TXFIFOSIZE(base) (BME_UBFX8(&UART_PFIFO_REG(base), UART_PFIFO_TXFIFOSIZE_SHIFT, UART_PFIFO_TXFIFOSIZE_WIDTH))
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFE[7] (RW)
 *
 * When this field is set, the built in FIFO structure for the transmit buffer
 * is enabled. The size of the FIFO structure is indicated by TXFIFOSIZE. If this
 * field is not set, the transmit buffer operates as a FIFO of depth one dataword
 * regardless of the value in TXFIFOSIZE. Both C2[TE] and C2[RE] must be cleared
 * prior to changing this field. Additionally, TXFLUSH and RXFLUSH commands must
 * be issued immediately after changing this field.
 *
 * Values:
 * - 0 - Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
 * - 1 - Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_TXFE field. */
#define UART_RD_PFIFO_TXFE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_TXFE_MASK) >> UART_PFIFO_TXFE_SHIFT)
#define UART_BRD_PFIFO_TXFE(base) (BME_UBFX8(&UART_PFIFO_REG(base), UART_PFIFO_TXFE_SHIFT, UART_PFIFO_TXFE_WIDTH))

/*! @brief Set the TXFE field to a new value. */
#define UART_WR_PFIFO_TXFE(base, value) (UART_RMW_PFIFO(base, UART_PFIFO_TXFE_MASK, UART_PFIFO_TXFE(value)))
#define UART_BWR_PFIFO_TXFE(base, value) (BME_BFI8(&UART_PFIFO_REG(base), ((uint8_t)(value) << UART_PFIFO_TXFE_SHIFT), UART_PFIFO_TXFE_SHIFT, UART_PFIFO_TXFE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_CFIFO - UART FIFO Control Register
 ******************************************************************************/

/*!
 * @brief UART_CFIFO - UART FIFO Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to program various control fields for FIFO
 * operation. This register may be read or written at any time. Note that
 * writing to TXFLUSH and RXFLUSH may result in data loss and requires careful action
 * to prevent unintended/unpredictable behavior. Therefore, it is recommended that
 * TE and RE be cleared prior to flushing the corresponding FIFO.
 */
/*!
 * @name Constants and macros for entire UART_CFIFO register
 */
/*@{*/
#define UART_RD_CFIFO(base)      (UART_CFIFO_REG(base))
#define UART_WR_CFIFO(base, value) (UART_CFIFO_REG(base) = (value))
#define UART_RMW_CFIFO(base, mask, value) (UART_WR_CFIFO(base, (UART_RD_CFIFO(base) & ~(mask)) | (value)))
#define UART_SET_CFIFO(base, value) (BME_OR8(&UART_CFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_CFIFO(base, value) (BME_AND8(&UART_CFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_CFIFO(base, value) (BME_XOR8(&UART_CFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_CFIFO bitfields
 */

/*!
 * @name Register UART_CFIFO, field RXUFE[0] (RW)
 *
 * When this field is set, the RXUF flag generates an interrupt to the host.
 *
 * Values:
 * - 0 - RXUF flag does not generate an interrupt to the host.
 * - 1 - RXUF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_RXUFE field. */
#define UART_RD_CFIFO_RXUFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_RXUFE_MASK) >> UART_CFIFO_RXUFE_SHIFT)
#define UART_BRD_CFIFO_RXUFE(base) (BME_UBFX8(&UART_CFIFO_REG(base), UART_CFIFO_RXUFE_SHIFT, UART_CFIFO_RXUFE_WIDTH))

/*! @brief Set the RXUFE field to a new value. */
#define UART_WR_CFIFO_RXUFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXUFE_MASK, UART_CFIFO_RXUFE(value)))
#define UART_BWR_CFIFO_RXUFE(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_RXUFE_SHIFT), UART_CFIFO_RXUFE_SHIFT, UART_CFIFO_RXUFE_WIDTH))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXOFE[1] (RW)
 *
 * When this field is set, the TXOF flag generates an interrupt to the host.
 *
 * Values:
 * - 0 - TXOF flag does not generate an interrupt to the host.
 * - 1 - TXOF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_TXOFE field. */
#define UART_RD_CFIFO_TXOFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_TXOFE_MASK) >> UART_CFIFO_TXOFE_SHIFT)
#define UART_BRD_CFIFO_TXOFE(base) (BME_UBFX8(&UART_CFIFO_REG(base), UART_CFIFO_TXOFE_SHIFT, UART_CFIFO_TXOFE_WIDTH))

/*! @brief Set the TXOFE field to a new value. */
#define UART_WR_CFIFO_TXOFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_TXOFE_MASK, UART_CFIFO_TXOFE(value)))
#define UART_BWR_CFIFO_TXOFE(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_TXOFE_SHIFT), UART_CFIFO_TXOFE_SHIFT, UART_CFIFO_TXOFE_WIDTH))
/*@}*/

/*!
 * @name Register UART_CFIFO, field RXOFE[2] (RW)
 *
 * When this field is set, the RXOF flag generates an interrupt to the host.
 *
 * Values:
 * - 0 - RXOF flag does not generate an interrupt to the host.
 * - 1 - RXOF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_RXOFE field. */
#define UART_RD_CFIFO_RXOFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_RXOFE_MASK) >> UART_CFIFO_RXOFE_SHIFT)
#define UART_BRD_CFIFO_RXOFE(base) (BME_UBFX8(&UART_CFIFO_REG(base), UART_CFIFO_RXOFE_SHIFT, UART_CFIFO_RXOFE_WIDTH))

/*! @brief Set the RXOFE field to a new value. */
#define UART_WR_CFIFO_RXOFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXOFE_MASK, UART_CFIFO_RXOFE(value)))
#define UART_BWR_CFIFO_RXOFE(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_RXOFE_SHIFT), UART_CFIFO_RXOFE_SHIFT, UART_CFIFO_RXOFE_WIDTH))
/*@}*/

/*!
 * @name Register UART_CFIFO, field RXFLUSH[6] (WORZ)
 *
 * Writing to this field causes all data that is stored in the receive
 * FIFO/buffer to be flushed. This does not affect data that is in the receive shift
 * register.
 *
 * Values:
 * - 0 - No flush operation occurs.
 * - 1 - All data in the receive FIFO/buffer is cleared out.
 */
/*@{*/
/*! @brief Set the RXFLUSH field to a new value. */
#define UART_WR_CFIFO_RXFLUSH(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXFLUSH_MASK, UART_CFIFO_RXFLUSH(value)))
#define UART_BWR_CFIFO_RXFLUSH(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_RXFLUSH_SHIFT), UART_CFIFO_RXFLUSH_SHIFT, UART_CFIFO_RXFLUSH_WIDTH))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXFLUSH[7] (WORZ)
 *
 * Writing to this field causes all data that is stored in the transmit
 * FIFO/buffer to be flushed. This does not affect data that is in the transmit shift
 * register.
 *
 * Values:
 * - 0 - No flush operation occurs.
 * - 1 - All data in the transmit FIFO/Buffer is cleared out.
 */
/*@{*/
/*! @brief Set the TXFLUSH field to a new value. */
#define UART_WR_CFIFO_TXFLUSH(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_TXFLUSH_MASK, UART_CFIFO_TXFLUSH(value)))
#define UART_BWR_CFIFO_TXFLUSH(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_TXFLUSH_SHIFT), UART_CFIFO_TXFLUSH_SHIFT, UART_CFIFO_TXFLUSH_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_SFIFO - UART FIFO Status Register
 ******************************************************************************/

/*!
 * @brief UART_SFIFO - UART FIFO Status Register (RW)
 *
 * Reset value: 0xC0U
 *
 * This register provides status information regarding the transmit and receiver
 * buffers/FIFOs, including interrupt information. This register may be written
 * to or read at any time.
 */
/*!
 * @name Constants and macros for entire UART_SFIFO register
 */
/*@{*/
#define UART_RD_SFIFO(base)      (UART_SFIFO_REG(base))
#define UART_WR_SFIFO(base, value) (UART_SFIFO_REG(base) = (value))
#define UART_RMW_SFIFO(base, mask, value) (UART_WR_SFIFO(base, (UART_RD_SFIFO(base) & ~(mask)) | (value)))
#define UART_SET_SFIFO(base, value) (BME_OR8(&UART_SFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_SFIFO(base, value) (BME_AND8(&UART_SFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_SFIFO(base, value) (BME_XOR8(&UART_SFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_SFIFO bitfields
 */

/*!
 * @name Register UART_SFIFO, field RXUF[0] (W1C)
 *
 * Indicates that more data has been read from the receive buffer than was
 * present. This field will assert regardless of the value of CFIFO[RXUFE]. However,
 * an interrupt will be issued to the host only if CFIFO[RXUFE] is set. This flag
 * is cleared by writing a 1.
 *
 * Values:
 * - 0 - No receive buffer underflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one receive buffer underflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXUF field. */
#define UART_RD_SFIFO_RXUF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXUF_MASK) >> UART_SFIFO_RXUF_SHIFT)
#define UART_BRD_SFIFO_RXUF(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_RXUF_SHIFT, UART_SFIFO_RXUF_WIDTH))

/*! @brief Set the RXUF field to a new value. */
#define UART_WR_SFIFO_RXUF(base, value) (UART_RMW_SFIFO(base, (UART_SFIFO_RXUF_MASK | UART_SFIFO_TXOF_MASK | UART_SFIFO_RXOF_MASK), UART_SFIFO_RXUF(value)))
#define UART_BWR_SFIFO_RXUF(base, value) (BME_BFI8(&UART_SFIFO_REG(base), ((uint8_t)(value) << UART_SFIFO_RXUF_SHIFT), UART_SFIFO_RXUF_SHIFT, UART_SFIFO_RXUF_WIDTH))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXOF[1] (W1C)
 *
 * Indicates that more data has been written to the transmit buffer than it can
 * hold. This field will assert regardless of the value of CFIFO[TXOFE]. However,
 * an interrupt will be issued to the host only if CFIFO[TXOFE] is set. This
 * flag is cleared by writing a 1.
 *
 * Values:
 * - 0 - No transmit buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one transmit buffer overflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_TXOF field. */
#define UART_RD_SFIFO_TXOF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_TXOF_MASK) >> UART_SFIFO_TXOF_SHIFT)
#define UART_BRD_SFIFO_TXOF(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_TXOF_SHIFT, UART_SFIFO_TXOF_WIDTH))

/*! @brief Set the TXOF field to a new value. */
#define UART_WR_SFIFO_TXOF(base, value) (UART_RMW_SFIFO(base, (UART_SFIFO_TXOF_MASK | UART_SFIFO_RXUF_MASK | UART_SFIFO_RXOF_MASK), UART_SFIFO_TXOF(value)))
#define UART_BWR_SFIFO_TXOF(base, value) (BME_BFI8(&UART_SFIFO_REG(base), ((uint8_t)(value) << UART_SFIFO_TXOF_SHIFT), UART_SFIFO_TXOF_SHIFT, UART_SFIFO_TXOF_WIDTH))
/*@}*/

/*!
 * @name Register UART_SFIFO, field RXOF[2] (W1C)
 *
 * Indicates that more data has been written to the receive buffer than it can
 * hold. This field will assert regardless of the value of CFIFO[RXOFE]. However,
 * an interrupt will be issued to the host only if CFIFO[RXOFE] is set. This flag
 * is cleared by writing a 1.
 *
 * Values:
 * - 0 - No receive buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one receive buffer overflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXOF field. */
#define UART_RD_SFIFO_RXOF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXOF_MASK) >> UART_SFIFO_RXOF_SHIFT)
#define UART_BRD_SFIFO_RXOF(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_RXOF_SHIFT, UART_SFIFO_RXOF_WIDTH))

/*! @brief Set the RXOF field to a new value. */
#define UART_WR_SFIFO_RXOF(base, value) (UART_RMW_SFIFO(base, (UART_SFIFO_RXOF_MASK | UART_SFIFO_RXUF_MASK | UART_SFIFO_TXOF_MASK), UART_SFIFO_RXOF(value)))
#define UART_BWR_SFIFO_RXOF(base, value) (BME_BFI8(&UART_SFIFO_REG(base), ((uint8_t)(value) << UART_SFIFO_RXOF_SHIFT), UART_SFIFO_RXOF_SHIFT, UART_SFIFO_RXOF_WIDTH))
/*@}*/

/*!
 * @name Register UART_SFIFO, field RXEMPT[6] (RO)
 *
 * Asserts when there is no data in the receive FIFO/Buffer. This field does not
 * take into account data that is in the receive shift register.
 *
 * Values:
 * - 0 - Receive buffer is not empty.
 * - 1 - Receive buffer is empty.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXEMPT field. */
#define UART_RD_SFIFO_RXEMPT(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXEMPT_MASK) >> UART_SFIFO_RXEMPT_SHIFT)
#define UART_BRD_SFIFO_RXEMPT(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_RXEMPT_SHIFT, UART_SFIFO_RXEMPT_WIDTH))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXEMPT[7] (RO)
 *
 * Asserts when there is no data in the Transmit FIFO/buffer. This field does
 * not take into account data that is in the transmit shift register.
 *
 * Values:
 * - 0 - Transmit buffer is not empty.
 * - 1 - Transmit buffer is empty.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_TXEMPT field. */
#define UART_RD_SFIFO_TXEMPT(base) ((UART_SFIFO_REG(base) & UART_SFIFO_TXEMPT_MASK) >> UART_SFIFO_TXEMPT_SHIFT)
#define UART_BRD_SFIFO_TXEMPT(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_TXEMPT_SHIFT, UART_SFIFO_TXEMPT_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_TWFIFO - UART FIFO Transmit Watermark
 ******************************************************************************/

/*!
 * @brief UART_TWFIFO - UART FIFO Transmit Watermark (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of needing additional transmit data. This register may be read at any
 * time but must be written only when C2[TE] is not set. Changing the value of the
 * watermark will not clear the S1[TDRE] flag.
 */
/*!
 * @name Constants and macros for entire UART_TWFIFO register
 */
/*@{*/
#define UART_RD_TWFIFO(base)     (UART_TWFIFO_REG(base))
#define UART_WR_TWFIFO(base, value) (UART_TWFIFO_REG(base) = (value))
#define UART_RMW_TWFIFO(base, mask, value) (UART_WR_TWFIFO(base, (UART_RD_TWFIFO(base) & ~(mask)) | (value)))
#define UART_SET_TWFIFO(base, value) (BME_OR8(&UART_TWFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_TWFIFO(base, value) (BME_AND8(&UART_TWFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_TWFIFO(base, value) (BME_XOR8(&UART_TWFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_TCFIFO - UART FIFO Transmit Count
 ******************************************************************************/

/*!
 * @brief UART_TCFIFO - UART FIFO Transmit Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the transmit buffer/FIFO. It may be read at any time.
 */
/*!
 * @name Constants and macros for entire UART_TCFIFO register
 */
/*@{*/
#define UART_RD_TCFIFO(base)     (UART_TCFIFO_REG(base))
/*@}*/

/*******************************************************************************
 * UART_RWFIFO - UART FIFO Receive Watermark
 ******************************************************************************/

/*!
 * @brief UART_RWFIFO - UART FIFO Receive Watermark (RW)
 *
 * Reset value: 0x01U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of the need to remove data from the receiver FIFO/buffer. This register
 * may be read at any time but must be written only when C2[RE] is not asserted.
 * Changing the value in this register will not clear S1[RDRF].
 */
/*!
 * @name Constants and macros for entire UART_RWFIFO register
 */
/*@{*/
#define UART_RD_RWFIFO(base)     (UART_RWFIFO_REG(base))
#define UART_WR_RWFIFO(base, value) (UART_RWFIFO_REG(base) = (value))
#define UART_RMW_RWFIFO(base, mask, value) (UART_WR_RWFIFO(base, (UART_RD_RWFIFO(base) & ~(mask)) | (value)))
#define UART_SET_RWFIFO(base, value) (BME_OR8(&UART_RWFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_RWFIFO(base, value) (BME_AND8(&UART_RWFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_RWFIFO(base, value) (BME_XOR8(&UART_RWFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_RCFIFO - UART FIFO Receive Count
 ******************************************************************************/

/*!
 * @brief UART_RCFIFO - UART FIFO Receive Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the receive FIFO/buffer. It may be read at any time.
 */
/*!
 * @name Constants and macros for entire UART_RCFIFO register
 */
/*@{*/
#define UART_RD_RCFIFO(base)     (UART_RCFIFO_REG(base))
/*@}*/

/*
 * MKV10Z7 WDOG
 *
 * Generation 2008 Watchdog Timer
 *
 * Registers defined in this header file:
 * - WDOG_STCTRLH - Watchdog Status and Control Register High
 * - WDOG_STCTRLL - Watchdog Status and Control Register Low
 * - WDOG_TOVALH - Watchdog Time-out Value Register High
 * - WDOG_TOVALL - Watchdog Time-out Value Register Low
 * - WDOG_WINH - Watchdog Window Register High
 * - WDOG_WINL - Watchdog Window Register Low
 * - WDOG_REFRESH - Watchdog Refresh register
 * - WDOG_UNLOCK - Watchdog Unlock register
 * - WDOG_TMROUTH - Watchdog Timer Output Register High
 * - WDOG_TMROUTL - Watchdog Timer Output Register Low
 * - WDOG_RSTCNT - Watchdog Reset Count register
 * - WDOG_PRESC - Watchdog Prescaler register
 */

#define WDOG_INSTANCE_COUNT (1U) /*!< Number of instances of the WDOG module. */
#define WDOG_IDX (0U) /*!< Instance number for WDOG. */

/*******************************************************************************
 * WDOG_STCTRLH - Watchdog Status and Control Register High
 ******************************************************************************/

/*!
 * @brief WDOG_STCTRLH - Watchdog Status and Control Register High (RW)
 *
 * Reset value: 0x01D3U
 */
/*!
 * @name Constants and macros for entire WDOG_STCTRLH register
 */
/*@{*/
#define WDOG_RD_STCTRLH(base)    (WDOG_STCTRLH_REG(base))
#define WDOG_WR_STCTRLH(base, value) (WDOG_STCTRLH_REG(base) = (value))
#define WDOG_RMW_STCTRLH(base, mask, value) (WDOG_WR_STCTRLH(base, (WDOG_RD_STCTRLH(base) & ~(mask)) | (value)))
#define WDOG_SET_STCTRLH(base, value) (BME_OR16(&WDOG_STCTRLH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_STCTRLH(base, value) (BME_AND16(&WDOG_STCTRLH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_STCTRLH(base, value) (BME_XOR16(&WDOG_STCTRLH_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_STCTRLH bitfields
 */

/*!
 * @name Register WDOG_STCTRLH, field WDOGEN[0] (RW)
 *
 * Enables or disables the WDOG's operation. In the disabled state, the watchdog
 * timer is kept in the reset state, but the other exception conditions can
 * still trigger a reset/interrupt. A change in the value of this bit must be held
 * for more than one WDOG_CLK cycle for the WDOG to be enabled or disabled.
 *
 * Values:
 * - 0 - WDOG is disabled.
 * - 1 - WDOG is enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WDOGEN field. */
#define WDOG_RD_STCTRLH_WDOGEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WDOGEN_MASK) >> WDOG_STCTRLH_WDOGEN_SHIFT)
#define WDOG_BRD_STCTRLH_WDOGEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WDOGEN_SHIFT, WDOG_STCTRLH_WDOGEN_WIDTH))

/*! @brief Set the WDOGEN field to a new value. */
#define WDOG_WR_STCTRLH_WDOGEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WDOGEN_MASK, WDOG_STCTRLH_WDOGEN(value)))
#define WDOG_BWR_STCTRLH_WDOGEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_WDOGEN_SHIFT), WDOG_STCTRLH_WDOGEN_SHIFT, WDOG_STCTRLH_WDOGEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field CLKSRC[1] (RW)
 *
 * Selects clock source for the WDOG timer and other internal timing operations.
 *
 * Values:
 * - 0 - WDOG clock sourced from LPO .
 * - 1 - WDOG clock sourced from alternate clock source.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_CLKSRC field. */
#define WDOG_RD_STCTRLH_CLKSRC(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_CLKSRC_MASK) >> WDOG_STCTRLH_CLKSRC_SHIFT)
#define WDOG_BRD_STCTRLH_CLKSRC(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_CLKSRC_SHIFT, WDOG_STCTRLH_CLKSRC_WIDTH))

/*! @brief Set the CLKSRC field to a new value. */
#define WDOG_WR_STCTRLH_CLKSRC(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_CLKSRC_MASK, WDOG_STCTRLH_CLKSRC(value)))
#define WDOG_BWR_STCTRLH_CLKSRC(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_CLKSRC_SHIFT), WDOG_STCTRLH_CLKSRC_SHIFT, WDOG_STCTRLH_CLKSRC_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field IRQRSTEN[2] (RW)
 *
 * Used to enable the debug breadcrumbs feature. A change in this bit is updated
 * immediately, as opposed to updating after WCT.
 *
 * Values:
 * - 0 - WDOG time-out generates reset only.
 * - 1 - WDOG time-out initially generates an interrupt. After WCT, it generates
 *     a reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_IRQRSTEN field. */
#define WDOG_RD_STCTRLH_IRQRSTEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_IRQRSTEN_MASK) >> WDOG_STCTRLH_IRQRSTEN_SHIFT)
#define WDOG_BRD_STCTRLH_IRQRSTEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_IRQRSTEN_SHIFT, WDOG_STCTRLH_IRQRSTEN_WIDTH))

/*! @brief Set the IRQRSTEN field to a new value. */
#define WDOG_WR_STCTRLH_IRQRSTEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_IRQRSTEN_MASK, WDOG_STCTRLH_IRQRSTEN(value)))
#define WDOG_BWR_STCTRLH_IRQRSTEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_IRQRSTEN_SHIFT), WDOG_STCTRLH_IRQRSTEN_SHIFT, WDOG_STCTRLH_IRQRSTEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field WINEN[3] (RW)
 *
 * Enables Windowing mode.
 *
 * Values:
 * - 0 - Windowing mode is disabled.
 * - 1 - Windowing mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WINEN field. */
#define WDOG_RD_STCTRLH_WINEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WINEN_MASK) >> WDOG_STCTRLH_WINEN_SHIFT)
#define WDOG_BRD_STCTRLH_WINEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WINEN_SHIFT, WDOG_STCTRLH_WINEN_WIDTH))

/*! @brief Set the WINEN field to a new value. */
#define WDOG_WR_STCTRLH_WINEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WINEN_MASK, WDOG_STCTRLH_WINEN(value)))
#define WDOG_BWR_STCTRLH_WINEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_WINEN_SHIFT), WDOG_STCTRLH_WINEN_SHIFT, WDOG_STCTRLH_WINEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field ALLOWUPDATE[4] (RW)
 *
 * Enables updates to watchdog write-once registers, after the reset-triggered
 * initial configuration window (WCT) closes, through unlock sequence.
 *
 * Values:
 * - 0 - No further updates allowed to WDOG write-once registers.
 * - 1 - WDOG write-once registers can be unlocked for updating.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_ALLOWUPDATE field. */
#define WDOG_RD_STCTRLH_ALLOWUPDATE(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_ALLOWUPDATE_MASK) >> WDOG_STCTRLH_ALLOWUPDATE_SHIFT)
#define WDOG_BRD_STCTRLH_ALLOWUPDATE(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_ALLOWUPDATE_SHIFT, WDOG_STCTRLH_ALLOWUPDATE_WIDTH))

/*! @brief Set the ALLOWUPDATE field to a new value. */
#define WDOG_WR_STCTRLH_ALLOWUPDATE(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_ALLOWUPDATE_MASK, WDOG_STCTRLH_ALLOWUPDATE(value)))
#define WDOG_BWR_STCTRLH_ALLOWUPDATE(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_ALLOWUPDATE_SHIFT), WDOG_STCTRLH_ALLOWUPDATE_SHIFT, WDOG_STCTRLH_ALLOWUPDATE_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field DBGEN[5] (RW)
 *
 * Enables or disables WDOG in Debug mode.
 *
 * Values:
 * - 0 - WDOG is disabled in CPU Debug mode.
 * - 1 - WDOG is enabled in CPU Debug mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_DBGEN field. */
#define WDOG_RD_STCTRLH_DBGEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_DBGEN_MASK) >> WDOG_STCTRLH_DBGEN_SHIFT)
#define WDOG_BRD_STCTRLH_DBGEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DBGEN_SHIFT, WDOG_STCTRLH_DBGEN_WIDTH))

/*! @brief Set the DBGEN field to a new value. */
#define WDOG_WR_STCTRLH_DBGEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_DBGEN_MASK, WDOG_STCTRLH_DBGEN(value)))
#define WDOG_BWR_STCTRLH_DBGEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_DBGEN_SHIFT), WDOG_STCTRLH_DBGEN_SHIFT, WDOG_STCTRLH_DBGEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field STOPEN[6] (RW)
 *
 * Enables or disables WDOG in Stop mode.
 *
 * Values:
 * - 0 - WDOG is disabled in CPU Stop mode.
 * - 1 - WDOG is enabled in CPU Stop mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_STOPEN field. */
#define WDOG_RD_STCTRLH_STOPEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_STOPEN_MASK) >> WDOG_STCTRLH_STOPEN_SHIFT)
#define WDOG_BRD_STCTRLH_STOPEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_STOPEN_SHIFT, WDOG_STCTRLH_STOPEN_WIDTH))

/*! @brief Set the STOPEN field to a new value. */
#define WDOG_WR_STCTRLH_STOPEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_STOPEN_MASK, WDOG_STCTRLH_STOPEN(value)))
#define WDOG_BWR_STCTRLH_STOPEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_STOPEN_SHIFT), WDOG_STCTRLH_STOPEN_SHIFT, WDOG_STCTRLH_STOPEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field WAITEN[7] (RW)
 *
 * Enables or disables WDOG in Wait mode.
 *
 * Values:
 * - 0 - WDOG is disabled in CPU Wait mode.
 * - 1 - WDOG is enabled in CPU Wait mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WAITEN field. */
#define WDOG_RD_STCTRLH_WAITEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WAITEN_MASK) >> WDOG_STCTRLH_WAITEN_SHIFT)
#define WDOG_BRD_STCTRLH_WAITEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WAITEN_SHIFT, WDOG_STCTRLH_WAITEN_WIDTH))

/*! @brief Set the WAITEN field to a new value. */
#define WDOG_WR_STCTRLH_WAITEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WAITEN_MASK, WDOG_STCTRLH_WAITEN(value)))
#define WDOG_BWR_STCTRLH_WAITEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_WAITEN_SHIFT), WDOG_STCTRLH_WAITEN_SHIFT, WDOG_STCTRLH_WAITEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field TESTWDOG[10] (RW)
 *
 * Puts the watchdog in the functional test mode. In this mode, the watchdog
 * timer and the associated compare and reset generation logic is tested for correct
 * operation. The clock for the timer is switched from the main watchdog clock
 * to the fast clock input for watchdog functional test. The TESTSEL bit selects
 * the test to be run.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_TESTWDOG field. */
#define WDOG_RD_STCTRLH_TESTWDOG(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_TESTWDOG_MASK) >> WDOG_STCTRLH_TESTWDOG_SHIFT)
#define WDOG_BRD_STCTRLH_TESTWDOG(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTWDOG_SHIFT, WDOG_STCTRLH_TESTWDOG_WIDTH))

/*! @brief Set the TESTWDOG field to a new value. */
#define WDOG_WR_STCTRLH_TESTWDOG(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_TESTWDOG_MASK, WDOG_STCTRLH_TESTWDOG(value)))
#define WDOG_BWR_STCTRLH_TESTWDOG(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_TESTWDOG_SHIFT), WDOG_STCTRLH_TESTWDOG_SHIFT, WDOG_STCTRLH_TESTWDOG_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field TESTSEL[11] (RW)
 *
 * Effective only if TESTWDOG is set. Selects the test to be run on the watchdog
 * timer.
 *
 * Values:
 * - 0 - Quick test. The timer runs in normal operation. You can load a small
 *     time-out value to do a quick test.
 * - 1 - Byte test. Puts the timer in the byte test mode where individual bytes
 *     of the timer are enabled for operation and are compared for time-out
 *     against the corresponding byte of the programmed time-out value. Select the
 *     byte through BYTESEL[1:0] for testing.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_TESTSEL field. */
#define WDOG_RD_STCTRLH_TESTSEL(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_TESTSEL_MASK) >> WDOG_STCTRLH_TESTSEL_SHIFT)
#define WDOG_BRD_STCTRLH_TESTSEL(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTSEL_SHIFT, WDOG_STCTRLH_TESTSEL_WIDTH))

/*! @brief Set the TESTSEL field to a new value. */
#define WDOG_WR_STCTRLH_TESTSEL(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_TESTSEL_MASK, WDOG_STCTRLH_TESTSEL(value)))
#define WDOG_BWR_STCTRLH_TESTSEL(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_TESTSEL_SHIFT), WDOG_STCTRLH_TESTSEL_SHIFT, WDOG_STCTRLH_TESTSEL_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field BYTESEL[13:12] (RW)
 *
 * This 2-bit field selects the byte to be tested when the watchdog is in the
 * byte test mode.
 *
 * Values:
 * - 00 - Byte 0 selected
 * - 01 - Byte 1 selected
 * - 10 - Byte 2 selected
 * - 11 - Byte 3 selected
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_BYTESEL field. */
#define WDOG_RD_STCTRLH_BYTESEL(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_BYTESEL_MASK) >> WDOG_STCTRLH_BYTESEL_SHIFT)
#define WDOG_BRD_STCTRLH_BYTESEL(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_BYTESEL_SHIFT, WDOG_STCTRLH_BYTESEL_WIDTH))

/*! @brief Set the BYTESEL field to a new value. */
#define WDOG_WR_STCTRLH_BYTESEL(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_BYTESEL_MASK, WDOG_STCTRLH_BYTESEL(value)))
#define WDOG_BWR_STCTRLH_BYTESEL(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_BYTESEL_SHIFT), WDOG_STCTRLH_BYTESEL_SHIFT, WDOG_STCTRLH_BYTESEL_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field DISTESTWDOG[14] (RW)
 *
 * Allows the WDOG's functional test mode to be disabled permanently. After it
 * is set, it can only be cleared by a reset. It cannot be unlocked for editing
 * after it is set.
 *
 * Values:
 * - 0 - WDOG functional test mode is not disabled.
 * - 1 - WDOG functional test mode is disabled permanently until reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_DISTESTWDOG field. */
#define WDOG_RD_STCTRLH_DISTESTWDOG(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_DISTESTWDOG_MASK) >> WDOG_STCTRLH_DISTESTWDOG_SHIFT)
#define WDOG_BRD_STCTRLH_DISTESTWDOG(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DISTESTWDOG_SHIFT, WDOG_STCTRLH_DISTESTWDOG_WIDTH))

/*! @brief Set the DISTESTWDOG field to a new value. */
#define WDOG_WR_STCTRLH_DISTESTWDOG(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_DISTESTWDOG_MASK, WDOG_STCTRLH_DISTESTWDOG(value)))
#define WDOG_BWR_STCTRLH_DISTESTWDOG(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_DISTESTWDOG_SHIFT), WDOG_STCTRLH_DISTESTWDOG_SHIFT, WDOG_STCTRLH_DISTESTWDOG_WIDTH))
/*@}*/

/*******************************************************************************
 * WDOG_STCTRLL - Watchdog Status and Control Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_STCTRLL - Watchdog Status and Control Register Low (RW)
 *
 * Reset value: 0x0001U
 */
/*!
 * @name Constants and macros for entire WDOG_STCTRLL register
 */
/*@{*/
#define WDOG_RD_STCTRLL(base)    (WDOG_STCTRLL_REG(base))
#define WDOG_WR_STCTRLL(base, value) (WDOG_STCTRLL_REG(base) = (value))
#define WDOG_RMW_STCTRLL(base, mask, value) (WDOG_WR_STCTRLL(base, (WDOG_RD_STCTRLL(base) & ~(mask)) | (value)))
#define WDOG_SET_STCTRLL(base, value) (BME_OR16(&WDOG_STCTRLL_REG(base), (uint16_t)(value)))
#define WDOG_CLR_STCTRLL(base, value) (BME_AND16(&WDOG_STCTRLL_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_STCTRLL(base, value) (BME_XOR16(&WDOG_STCTRLL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_STCTRLL bitfields
 */

/*!
 * @name Register WDOG_STCTRLL, field INTFLG[15] (RW)
 *
 * Interrupt flag. It is set when an exception occurs. IRQRSTEN = 1 is a
 * precondition to set this flag. INTFLG = 1 results in an interrupt being issued
 * followed by a reset, WCT later. The interrupt can be cleared by writing 1 to this
 * bit. It also gets cleared on a system reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLL_INTFLG field. */
#define WDOG_RD_STCTRLL_INTFLG(base) ((WDOG_STCTRLL_REG(base) & WDOG_STCTRLL_INTFLG_MASK) >> WDOG_STCTRLL_INTFLG_SHIFT)
#define WDOG_BRD_STCTRLL_INTFLG(base) (BME_UBFX16(&WDOG_STCTRLL_REG(base), WDOG_STCTRLL_INTFLG_SHIFT, WDOG_STCTRLL_INTFLG_WIDTH))

/*! @brief Set the INTFLG field to a new value. */
#define WDOG_WR_STCTRLL_INTFLG(base, value) (WDOG_RMW_STCTRLL(base, WDOG_STCTRLL_INTFLG_MASK, WDOG_STCTRLL_INTFLG(value)))
#define WDOG_BWR_STCTRLL_INTFLG(base, value) (BME_BFI16(&WDOG_STCTRLL_REG(base), ((uint16_t)(value) << WDOG_STCTRLL_INTFLG_SHIFT), WDOG_STCTRLL_INTFLG_SHIFT, WDOG_STCTRLL_INTFLG_WIDTH))
/*@}*/

/*******************************************************************************
 * WDOG_TOVALH - Watchdog Time-out Value Register High
 ******************************************************************************/

/*!
 * @brief WDOG_TOVALH - Watchdog Time-out Value Register High (RW)
 *
 * Reset value: 0x004CU
 */
/*!
 * @name Constants and macros for entire WDOG_TOVALH register
 */
/*@{*/
#define WDOG_RD_TOVALH(base)     (WDOG_TOVALH_REG(base))
#define WDOG_WR_TOVALH(base, value) (WDOG_TOVALH_REG(base) = (value))
#define WDOG_RMW_TOVALH(base, mask, value) (WDOG_WR_TOVALH(base, (WDOG_RD_TOVALH(base) & ~(mask)) | (value)))
#define WDOG_SET_TOVALH(base, value) (BME_OR16(&WDOG_TOVALH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_TOVALH(base, value) (BME_AND16(&WDOG_TOVALH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_TOVALH(base, value) (BME_XOR16(&WDOG_TOVALH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_TOVALL - Watchdog Time-out Value Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_TOVALL - Watchdog Time-out Value Register Low (RW)
 *
 * Reset value: 0x4B4CU
 *
 * The time-out value of the watchdog must be set to a minimum of four watchdog
 * clock cycles. This is to take into account the delay in new settings taking
 * effect in the watchdog clock domain.
 */
/*!
 * @name Constants and macros for entire WDOG_TOVALL register
 */
/*@{*/
#define WDOG_RD_TOVALL(base)     (WDOG_TOVALL_REG(base))
#define WDOG_WR_TOVALL(base, value) (WDOG_TOVALL_REG(base) = (value))
#define WDOG_RMW_TOVALL(base, mask, value) (WDOG_WR_TOVALL(base, (WDOG_RD_TOVALL(base) & ~(mask)) | (value)))
#define WDOG_SET_TOVALL(base, value) (BME_OR16(&WDOG_TOVALL_REG(base), (uint16_t)(value)))
#define WDOG_CLR_TOVALL(base, value) (BME_AND16(&WDOG_TOVALL_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_TOVALL(base, value) (BME_XOR16(&WDOG_TOVALL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_WINH - Watchdog Window Register High
 ******************************************************************************/

/*!
 * @brief WDOG_WINH - Watchdog Window Register High (RW)
 *
 * Reset value: 0x0000U
 *
 * You must set the Window Register value lower than the Time-out Value Register.
 */
/*!
 * @name Constants and macros for entire WDOG_WINH register
 */
/*@{*/
#define WDOG_RD_WINH(base)       (WDOG_WINH_REG(base))
#define WDOG_WR_WINH(base, value) (WDOG_WINH_REG(base) = (value))
#define WDOG_RMW_WINH(base, mask, value) (WDOG_WR_WINH(base, (WDOG_RD_WINH(base) & ~(mask)) | (value)))
#define WDOG_SET_WINH(base, value) (BME_OR16(&WDOG_WINH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_WINH(base, value) (BME_AND16(&WDOG_WINH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_WINH(base, value) (BME_XOR16(&WDOG_WINH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_WINL - Watchdog Window Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_WINL - Watchdog Window Register Low (RW)
 *
 * Reset value: 0x0010U
 *
 * You must set the Window Register value lower than the Time-out Value Register.
 */
/*!
 * @name Constants and macros for entire WDOG_WINL register
 */
/*@{*/
#define WDOG_RD_WINL(base)       (WDOG_WINL_REG(base))
#define WDOG_WR_WINL(base, value) (WDOG_WINL_REG(base) = (value))
#define WDOG_RMW_WINL(base, mask, value) (WDOG_WR_WINL(base, (WDOG_RD_WINL(base) & ~(mask)) | (value)))
#define WDOG_SET_WINL(base, value) (BME_OR16(&WDOG_WINL_REG(base), (uint16_t)(value)))
#define WDOG_CLR_WINL(base, value) (BME_AND16(&WDOG_WINL_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_WINL(base, value) (BME_XOR16(&WDOG_WINL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_REFRESH - Watchdog Refresh register
 ******************************************************************************/

/*!
 * @brief WDOG_REFRESH - Watchdog Refresh register (RW)
 *
 * Reset value: 0xB480U
 */
/*!
 * @name Constants and macros for entire WDOG_REFRESH register
 */
/*@{*/
#define WDOG_RD_REFRESH(base)    (WDOG_REFRESH_REG(base))
#define WDOG_WR_REFRESH(base, value) (WDOG_REFRESH_REG(base) = (value))
#define WDOG_RMW_REFRESH(base, mask, value) (WDOG_WR_REFRESH(base, (WDOG_RD_REFRESH(base) & ~(mask)) | (value)))
#define WDOG_SET_REFRESH(base, value) (BME_OR16(&WDOG_REFRESH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_REFRESH(base, value) (BME_AND16(&WDOG_REFRESH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_REFRESH(base, value) (BME_XOR16(&WDOG_REFRESH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_UNLOCK - Watchdog Unlock register
 ******************************************************************************/

/*!
 * @brief WDOG_UNLOCK - Watchdog Unlock register (RW)
 *
 * Reset value: 0xD928U
 */
/*!
 * @name Constants and macros for entire WDOG_UNLOCK register
 */
/*@{*/
#define WDOG_RD_UNLOCK(base)     (WDOG_UNLOCK_REG(base))
#define WDOG_WR_UNLOCK(base, value) (WDOG_UNLOCK_REG(base) = (value))
#define WDOG_RMW_UNLOCK(base, mask, value) (WDOG_WR_UNLOCK(base, (WDOG_RD_UNLOCK(base) & ~(mask)) | (value)))
#define WDOG_SET_UNLOCK(base, value) (BME_OR16(&WDOG_UNLOCK_REG(base), (uint16_t)(value)))
#define WDOG_CLR_UNLOCK(base, value) (BME_AND16(&WDOG_UNLOCK_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_UNLOCK(base, value) (BME_XOR16(&WDOG_UNLOCK_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_TMROUTH - Watchdog Timer Output Register High
 ******************************************************************************/

/*!
 * @brief WDOG_TMROUTH - Watchdog Timer Output Register High (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire WDOG_TMROUTH register
 */
/*@{*/
#define WDOG_RD_TMROUTH(base)    (WDOG_TMROUTH_REG(base))
#define WDOG_WR_TMROUTH(base, value) (WDOG_TMROUTH_REG(base) = (value))
#define WDOG_RMW_TMROUTH(base, mask, value) (WDOG_WR_TMROUTH(base, (WDOG_RD_TMROUTH(base) & ~(mask)) | (value)))
#define WDOG_SET_TMROUTH(base, value) (BME_OR16(&WDOG_TMROUTH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_TMROUTH(base, value) (BME_AND16(&WDOG_TMROUTH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_TMROUTH(base, value) (BME_XOR16(&WDOG_TMROUTH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_TMROUTL - Watchdog Timer Output Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_TMROUTL - Watchdog Timer Output Register Low (RW)
 *
 * Reset value: 0x0000U
 *
 * During Stop mode, the WDOG_TIMER_OUT will be caught at the pre-stop value of
 * the watchdog timer. After exiting Stop mode, a maximum delay of 1 WDOG_CLK
 * cycle + 3 bus clock cycles will occur before the WDOG_TIMER_OUT starts following
 * the watchdog timer.
 */
/*!
 * @name Constants and macros for entire WDOG_TMROUTL register
 */
/*@{*/
#define WDOG_RD_TMROUTL(base)    (WDOG_TMROUTL_REG(base))
#define WDOG_WR_TMROUTL(base, value) (WDOG_TMROUTL_REG(base) = (value))
#define WDOG_RMW_TMROUTL(base, mask, value) (WDOG_WR_TMROUTL(base, (WDOG_RD_TMROUTL(base) & ~(mask)) | (value)))
#define WDOG_SET_TMROUTL(base, value) (BME_OR16(&WDOG_TMROUTL_REG(base), (uint16_t)(value)))
#define WDOG_CLR_TMROUTL(base, value) (BME_AND16(&WDOG_TMROUTL_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_TMROUTL(base, value) (BME_XOR16(&WDOG_TMROUTL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_RSTCNT - Watchdog Reset Count register
 ******************************************************************************/

/*!
 * @brief WDOG_RSTCNT - Watchdog Reset Count register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire WDOG_RSTCNT register
 */
/*@{*/
#define WDOG_RD_RSTCNT(base)     (WDOG_RSTCNT_REG(base))
#define WDOG_WR_RSTCNT(base, value) (WDOG_RSTCNT_REG(base) = (value))
#define WDOG_RMW_RSTCNT(base, mask, value) (WDOG_WR_RSTCNT(base, (WDOG_RD_RSTCNT(base) & ~(mask)) | (value)))
#define WDOG_SET_RSTCNT(base, value) (BME_OR16(&WDOG_RSTCNT_REG(base), (uint16_t)(value)))
#define WDOG_CLR_RSTCNT(base, value) (BME_AND16(&WDOG_RSTCNT_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_RSTCNT(base, value) (BME_XOR16(&WDOG_RSTCNT_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_PRESC - Watchdog Prescaler register
 ******************************************************************************/

/*!
 * @brief WDOG_PRESC - Watchdog Prescaler register (RW)
 *
 * Reset value: 0x0400U
 */
/*!
 * @name Constants and macros for entire WDOG_PRESC register
 */
/*@{*/
#define WDOG_RD_PRESC(base)      (WDOG_PRESC_REG(base))
#define WDOG_WR_PRESC(base, value) (WDOG_PRESC_REG(base) = (value))
#define WDOG_RMW_PRESC(base, mask, value) (WDOG_WR_PRESC(base, (WDOG_RD_PRESC(base) & ~(mask)) | (value)))
#define WDOG_SET_PRESC(base, value) (BME_OR16(&WDOG_PRESC_REG(base), (uint16_t)(value)))
#define WDOG_CLR_PRESC(base, value) (BME_AND16(&WDOG_PRESC_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_PRESC(base, value) (BME_XOR16(&WDOG_PRESC_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_PRESC bitfields
 */

/*!
 * @name Register WDOG_PRESC, field PRESCVAL[10:8] (RW)
 *
 * 3-bit prescaler for the watchdog clock source. A value of zero indicates no
 * division of the input WDOG clock. The watchdog clock is divided by (PRESCVAL +
 * 1) to provide the prescaled WDOG_CLK.
 */
/*@{*/
/*! @brief Read current value of the WDOG_PRESC_PRESCVAL field. */
#define WDOG_RD_PRESC_PRESCVAL(base) ((WDOG_PRESC_REG(base) & WDOG_PRESC_PRESCVAL_MASK) >> WDOG_PRESC_PRESCVAL_SHIFT)
#define WDOG_BRD_PRESC_PRESCVAL(base) (BME_UBFX16(&WDOG_PRESC_REG(base), WDOG_PRESC_PRESCVAL_SHIFT, WDOG_PRESC_PRESCVAL_WIDTH))

/*! @brief Set the PRESCVAL field to a new value. */
#define WDOG_WR_PRESC_PRESCVAL(base, value) (WDOG_RMW_PRESC(base, WDOG_PRESC_PRESCVAL_MASK, WDOG_PRESC_PRESCVAL(value)))
#define WDOG_BWR_PRESC_PRESCVAL(base, value) (BME_BFI16(&WDOG_PRESC_REG(base), ((uint16_t)(value) << WDOG_PRESC_PRESCVAL_SHIFT), WDOG_PRESC_PRESCVAL_SHIFT, WDOG_PRESC_PRESCVAL_WIDTH))
/*@}*/

/* Instance numbers for core modules */
#define JTAG_IDX (0) /*!< Instance number for JTAG. */
#define TPIU_IDX (0) /*!< Instance number for TPIU. */
#define SCB_IDX (0) /*!< Instance number for SCB. */
#define CoreDebug_IDX (0) /*!< Instance number for CoreDebug. */

#endif /* __MKV10Z7_EXTENSION_H__ */
/* EOF */
